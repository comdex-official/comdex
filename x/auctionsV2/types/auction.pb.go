// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/auctionsV2/v1beta1/auction.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	types "github.com/comdex-official/comdex/x/liquidationsV2/types"
	_ "github.com/cosmos/cosmos-sdk/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AuctionHistorical struct {
	AuctionId         uint64             `protobuf:"varint,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty" yaml:"auction_id"`
	AuctionHistorical *Auction           `protobuf:"bytes,2,opt,name=auction_historical,json=auctionHistorical,proto3" json:"auction_historical,omitempty" yaml:"auction_historical"`
	LockedVault       *types.LockedVault `protobuf:"bytes,3,opt,name=locked_vault,json=lockedVault,proto3" json:"locked_vault,omitempty" yaml:"locked_vault"`
}

func (m *AuctionHistorical) Reset()         { *m = AuctionHistorical{} }
func (m *AuctionHistorical) String() string { return proto.CompactTextString(m) }
func (*AuctionHistorical) ProtoMessage()    {}
func (*AuctionHistorical) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ee47f5a405fa8ba, []int{0}
}
func (m *AuctionHistorical) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionHistorical) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionHistorical.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionHistorical) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionHistorical.Merge(m, src)
}
func (m *AuctionHistorical) XXX_Size() int {
	return m.Size()
}
func (m *AuctionHistorical) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionHistorical.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionHistorical proto.InternalMessageInfo

func (m *AuctionHistorical) GetAuctionId() uint64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *AuctionHistorical) GetAuctionHistorical() *Auction {
	if m != nil {
		return m.AuctionHistorical
	}
	return nil
}

func (m *AuctionHistorical) GetLockedVault() *types.LockedVault {
	if m != nil {
		return m.LockedVault
	}
	return nil
}

type Auction struct {
	AuctionId       uint64                                  `protobuf:"varint,1,opt,name=auction_id,json=auctionId,proto3" json:"auction_id,omitempty" yaml:"auction_id"`
	CollateralToken github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,2,opt,name=collateral_token,json=collateralToken,proto3,casttype=github.com/cosmos/cosmos-sdk/types.Coin" json:"collateral_token" yaml:"collateral_token"`
	DebtToken       github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,3,opt,name=debt_token,json=debtToken,proto3,casttype=github.com/cosmos/cosmos-sdk/types.Coin" json:"debt_token" yaml:"inflow_token_target_amount"`
	ActiveBiddingId uint64                                  `protobuf:"varint,4,opt,name=active_bidding_id,json=activeBiddingId,proto3" json:"active_bidding_id,omitempty" yaml:"active_bidding_id"`
	BiddingIds      []*BidOwnerMapping                      `protobuf:"bytes,5,rep,name=bidding_ids,json=biddingIds,proto3" json:"bidding_ids,omitempty" yaml:"bidding_ids"`
	// price indicator only for dutch auctions
	CollateralTokenAuctionPrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,7,opt,name=collateral_token_auction_price,json=collateralTokenAuctionPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"collateral_token_auction_price" yaml:"outflow_token_auction_price"`
	CollateralTokenOraclePrice  cosmossdk_io_math.LegacyDec `protobuf:"bytes,8,opt,name=collateral_token_oracle_price,json=collateralTokenOraclePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"collateral_token_oracle_price" yaml:"outflow_token_oracle_price"`
	DebtTokenOraclePrice        cosmossdk_io_math.LegacyDec `protobuf:"bytes,9,opt,name=debt_token_oracle_price,json=debtTokenOraclePrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"debt_token_oracle_price" yaml:"inflow_token_oracle_price"`
	LockedVaultId               uint64                      `protobuf:"varint,10,opt,name=locked_vault_id,json=lockedVaultId,proto3" json:"locked_vault_id,omitempty" yaml:"locked_vault_id"`
	StartTime                   time.Time                   `protobuf:"bytes,11,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time" yaml:"start_time"`
	EndTime                     time.Time                   `protobuf:"bytes,12,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time" yaml:"end_time"`
	AppId                       uint64                      `protobuf:"varint,13,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty" yaml:"app_id"`
	AuctionType                 bool                        `protobuf:"varint,14,opt,name=auction_type,json=auctionType,proto3" json:"auction_type,omitempty" yaml:"auction_type"`
	CollateralAssetId           uint64                      `protobuf:"varint,15,opt,name=collateral_asset_id,json=collateralAssetId,proto3" json:"collateral_asset_id,omitempty" yaml:"collateral_asset_id"`
	DebtAssetId                 uint64                      `protobuf:"varint,16,opt,name=debt_asset_id,json=debtAssetId,proto3" json:"debt_asset_id,omitempty" yaml:"debt_asset_id"`
	BonusAmount                 cosmossdk_io_math.Int       `protobuf:"bytes,17,opt,name=bonus_amount,json=bonusAmount,proto3,customtype=cosmossdk.io/math.Int" json:"bonus_amount" yaml:"bonus_amount"`
	CollateralTokenInitialPrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,18,opt,name=collateral_token_initial_price,json=collateralTokenInitialPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"collateral_token_initial_price" yaml:"collateral_token_initial_price"`
}

func (m *Auction) Reset()         { *m = Auction{} }
func (m *Auction) String() string { return proto.CompactTextString(m) }
func (*Auction) ProtoMessage()    {}
func (*Auction) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ee47f5a405fa8ba, []int{1}
}
func (m *Auction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Auction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Auction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Auction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Auction.Merge(m, src)
}
func (m *Auction) XXX_Size() int {
	return m.Size()
}
func (m *Auction) XXX_DiscardUnknown() {
	xxx_messageInfo_Auction.DiscardUnknown(m)
}

var xxx_messageInfo_Auction proto.InternalMessageInfo

func (m *Auction) GetAuctionId() uint64 {
	if m != nil {
		return m.AuctionId
	}
	return 0
}

func (m *Auction) GetCollateralToken() github_com_cosmos_cosmos_sdk_types.Coin {
	if m != nil {
		return m.CollateralToken
	}
	return github_com_cosmos_cosmos_sdk_types.Coin{}
}

func (m *Auction) GetDebtToken() github_com_cosmos_cosmos_sdk_types.Coin {
	if m != nil {
		return m.DebtToken
	}
	return github_com_cosmos_cosmos_sdk_types.Coin{}
}

func (m *Auction) GetActiveBiddingId() uint64 {
	if m != nil {
		return m.ActiveBiddingId
	}
	return 0
}

func (m *Auction) GetBiddingIds() []*BidOwnerMapping {
	if m != nil {
		return m.BiddingIds
	}
	return nil
}

func (m *Auction) GetLockedVaultId() uint64 {
	if m != nil {
		return m.LockedVaultId
	}
	return 0
}

func (m *Auction) GetStartTime() time.Time {
	if m != nil {
		return m.StartTime
	}
	return time.Time{}
}

func (m *Auction) GetEndTime() time.Time {
	if m != nil {
		return m.EndTime
	}
	return time.Time{}
}

func (m *Auction) GetAppId() uint64 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *Auction) GetAuctionType() bool {
	if m != nil {
		return m.AuctionType
	}
	return false
}

func (m *Auction) GetCollateralAssetId() uint64 {
	if m != nil {
		return m.CollateralAssetId
	}
	return 0
}

func (m *Auction) GetDebtAssetId() uint64 {
	if m != nil {
		return m.DebtAssetId
	}
	return 0
}

type BidOwnerMapping struct {
	BidId    uint64 `protobuf:"varint,1,opt,name=bid_id,json=bidId,proto3" json:"bid_id,omitempty"`
	BidOwner string `protobuf:"bytes,2,opt,name=bid_owner,json=bidOwner,proto3" json:"bid_owner,omitempty"`
}

func (m *BidOwnerMapping) Reset()         { *m = BidOwnerMapping{} }
func (m *BidOwnerMapping) String() string { return proto.CompactTextString(m) }
func (*BidOwnerMapping) ProtoMessage()    {}
func (*BidOwnerMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ee47f5a405fa8ba, []int{2}
}
func (m *BidOwnerMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BidOwnerMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BidOwnerMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BidOwnerMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BidOwnerMapping.Merge(m, src)
}
func (m *BidOwnerMapping) XXX_Size() int {
	return m.Size()
}
func (m *BidOwnerMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_BidOwnerMapping.DiscardUnknown(m)
}

var xxx_messageInfo_BidOwnerMapping proto.InternalMessageInfo

func (m *BidOwnerMapping) GetBidId() uint64 {
	if m != nil {
		return m.BidId
	}
	return 0
}

func (m *BidOwnerMapping) GetBidOwner() string {
	if m != nil {
		return m.BidOwner
	}
	return ""
}

type LimitBidProtocolData struct {
	CollateralAssetId uint64                      `protobuf:"varint,1,opt,name=collateral_asset_id,json=collateralAssetId,proto3" json:"collateral_asset_id,omitempty" yaml:"collateral_asset_id"`
	DebtAssetId       uint64                      `protobuf:"varint,2,opt,name=debt_asset_id,json=debtAssetId,proto3" json:"debt_asset_id,omitempty" yaml:"debt_asset_id"`
	BidValue          cosmossdk_io_math.Int       `protobuf:"bytes,3,opt,name=bid_value,json=bidValue,proto3,customtype=cosmossdk.io/math.Int" json:"bid_value" yaml:"bid_value"`
	MaxDiscount       cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=max_discount,json=maxDiscount,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_discount" yaml:"max_discount"`
}

func (m *LimitBidProtocolData) Reset()         { *m = LimitBidProtocolData{} }
func (m *LimitBidProtocolData) String() string { return proto.CompactTextString(m) }
func (*LimitBidProtocolData) ProtoMessage()    {}
func (*LimitBidProtocolData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ee47f5a405fa8ba, []int{3}
}
func (m *LimitBidProtocolData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimitBidProtocolData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimitBidProtocolData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimitBidProtocolData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimitBidProtocolData.Merge(m, src)
}
func (m *LimitBidProtocolData) XXX_Size() int {
	return m.Size()
}
func (m *LimitBidProtocolData) XXX_DiscardUnknown() {
	xxx_messageInfo_LimitBidProtocolData.DiscardUnknown(m)
}

var xxx_messageInfo_LimitBidProtocolData proto.InternalMessageInfo

func (m *LimitBidProtocolData) GetCollateralAssetId() uint64 {
	if m != nil {
		return m.CollateralAssetId
	}
	return 0
}

func (m *LimitBidProtocolData) GetDebtAssetId() uint64 {
	if m != nil {
		return m.DebtAssetId
	}
	return 0
}

type LimitBidProtocolDataForQuery struct {
	CollateralAssetId    uint64                      `protobuf:"varint,1,opt,name=collateral_asset_id,json=collateralAssetId,proto3" json:"collateral_asset_id,omitempty" yaml:"collateral_asset_id"`
	DebtAssetId          uint64                      `protobuf:"varint,2,opt,name=debt_asset_id,json=debtAssetId,proto3" json:"debt_asset_id,omitempty" yaml:"debt_asset_id"`
	BidValue             cosmossdk_io_math.Int       `protobuf:"bytes,3,opt,name=bid_value,json=bidValue,proto3,customtype=cosmossdk.io/math.Int" json:"bid_value" yaml:"bid_value"`
	MaxDiscount          cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=max_discount,json=maxDiscount,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_discount" yaml:"max_discount"`
	CollateralAssetDenom string                      `protobuf:"bytes,5,opt,name=collateral_asset_denom,json=collateralAssetDenom,proto3" json:"collateral_asset_denom,omitempty" yaml:"collateral_asset_denom"`
	DebtAssetDenom       string                      `protobuf:"bytes,6,opt,name=debt_asset_denom,json=debtAssetDenom,proto3" json:"debt_asset_denom,omitempty" yaml:"debt_asset_denom"`
}

func (m *LimitBidProtocolDataForQuery) Reset()         { *m = LimitBidProtocolDataForQuery{} }
func (m *LimitBidProtocolDataForQuery) String() string { return proto.CompactTextString(m) }
func (*LimitBidProtocolDataForQuery) ProtoMessage()    {}
func (*LimitBidProtocolDataForQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ee47f5a405fa8ba, []int{4}
}
func (m *LimitBidProtocolDataForQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimitBidProtocolDataForQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimitBidProtocolDataForQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimitBidProtocolDataForQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimitBidProtocolDataForQuery.Merge(m, src)
}
func (m *LimitBidProtocolDataForQuery) XXX_Size() int {
	return m.Size()
}
func (m *LimitBidProtocolDataForQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_LimitBidProtocolDataForQuery.DiscardUnknown(m)
}

var xxx_messageInfo_LimitBidProtocolDataForQuery proto.InternalMessageInfo

func (m *LimitBidProtocolDataForQuery) GetCollateralAssetId() uint64 {
	if m != nil {
		return m.CollateralAssetId
	}
	return 0
}

func (m *LimitBidProtocolDataForQuery) GetDebtAssetId() uint64 {
	if m != nil {
		return m.DebtAssetId
	}
	return 0
}

func (m *LimitBidProtocolDataForQuery) GetCollateralAssetDenom() string {
	if m != nil {
		return m.CollateralAssetDenom
	}
	return ""
}

func (m *LimitBidProtocolDataForQuery) GetDebtAssetDenom() string {
	if m != nil {
		return m.DebtAssetDenom
	}
	return ""
}

type LimitBidProtocolDataWithUserForQuery struct {
	CollateralAssetId    uint64                      `protobuf:"varint,1,opt,name=collateral_asset_id,json=collateralAssetId,proto3" json:"collateral_asset_id,omitempty" yaml:"collateral_asset_id"`
	DebtAssetId          uint64                      `protobuf:"varint,2,opt,name=debt_asset_id,json=debtAssetId,proto3" json:"debt_asset_id,omitempty" yaml:"debt_asset_id"`
	BidValue             cosmossdk_io_math.Int       `protobuf:"bytes,3,opt,name=bid_value,json=bidValue,proto3,customtype=cosmossdk.io/math.Int" json:"bid_value" yaml:"bid_value"`
	MaxDiscount          cosmossdk_io_math.LegacyDec `protobuf:"bytes,4,opt,name=max_discount,json=maxDiscount,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"max_discount" yaml:"max_discount"`
	CollateralAssetDenom string                      `protobuf:"bytes,5,opt,name=collateral_asset_denom,json=collateralAssetDenom,proto3" json:"collateral_asset_denom,omitempty" yaml:"collateral_asset_denom"`
	DebtAssetDenom       string                      `protobuf:"bytes,6,opt,name=debt_asset_denom,json=debtAssetDenom,proto3" json:"debt_asset_denom,omitempty" yaml:"debt_asset_denom"`
	UserBidValue         cosmossdk_io_math.Int       `protobuf:"bytes,7,opt,name=user_bid_value,json=userBidValue,proto3,customtype=cosmossdk.io/math.Int" json:"user_bid_value" yaml:"user_bid_value"`
}

func (m *LimitBidProtocolDataWithUserForQuery) Reset()         { *m = LimitBidProtocolDataWithUserForQuery{} }
func (m *LimitBidProtocolDataWithUserForQuery) String() string { return proto.CompactTextString(m) }
func (*LimitBidProtocolDataWithUserForQuery) ProtoMessage()    {}
func (*LimitBidProtocolDataWithUserForQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ee47f5a405fa8ba, []int{5}
}
func (m *LimitBidProtocolDataWithUserForQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LimitBidProtocolDataWithUserForQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LimitBidProtocolDataWithUserForQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LimitBidProtocolDataWithUserForQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LimitBidProtocolDataWithUserForQuery.Merge(m, src)
}
func (m *LimitBidProtocolDataWithUserForQuery) XXX_Size() int {
	return m.Size()
}
func (m *LimitBidProtocolDataWithUserForQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_LimitBidProtocolDataWithUserForQuery.DiscardUnknown(m)
}

var xxx_messageInfo_LimitBidProtocolDataWithUserForQuery proto.InternalMessageInfo

func (m *LimitBidProtocolDataWithUserForQuery) GetCollateralAssetId() uint64 {
	if m != nil {
		return m.CollateralAssetId
	}
	return 0
}

func (m *LimitBidProtocolDataWithUserForQuery) GetDebtAssetId() uint64 {
	if m != nil {
		return m.DebtAssetId
	}
	return 0
}

func (m *LimitBidProtocolDataWithUserForQuery) GetCollateralAssetDenom() string {
	if m != nil {
		return m.CollateralAssetDenom
	}
	return ""
}

func (m *LimitBidProtocolDataWithUserForQuery) GetDebtAssetDenom() string {
	if m != nil {
		return m.DebtAssetDenom
	}
	return ""
}

func init() {
	proto.RegisterType((*AuctionHistorical)(nil), "comdex.auctionsV2.v1beta1.AuctionHistorical")
	proto.RegisterType((*Auction)(nil), "comdex.auctionsV2.v1beta1.Auction")
	proto.RegisterType((*BidOwnerMapping)(nil), "comdex.auctionsV2.v1beta1.bidOwnerMapping")
	proto.RegisterType((*LimitBidProtocolData)(nil), "comdex.auctionsV2.v1beta1.LimitBidProtocolData")
	proto.RegisterType((*LimitBidProtocolDataForQuery)(nil), "comdex.auctionsV2.v1beta1.LimitBidProtocolDataForQuery")
	proto.RegisterType((*LimitBidProtocolDataWithUserForQuery)(nil), "comdex.auctionsV2.v1beta1.LimitBidProtocolDataWithUserForQuery")
}

func init() {
	proto.RegisterFile("comdex/auctionsV2/v1beta1/auction.proto", fileDescriptor_8ee47f5a405fa8ba)
}

var fileDescriptor_8ee47f5a405fa8ba = []byte{
	// 1202 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0x4d, 0x6f, 0xdc, 0x44,
	0x18, 0x8e, 0xf3, 0xd5, 0xec, 0xec, 0xa6, 0x9b, 0x75, 0x93, 0x76, 0xbb, 0x69, 0xd6, 0xdb, 0x11,
	0xd0, 0x08, 0xa9, 0x5e, 0xb5, 0x54, 0x1c, 0x2a, 0x2e, 0x35, 0x29, 0x74, 0x51, 0x68, 0x8b, 0x15,
	0x5a, 0x84, 0x40, 0xab, 0xb1, 0x3d, 0xd9, 0x8c, 0xe2, 0xf5, 0x18, 0x7b, 0x36, 0x4d, 0x2e, 0xfc,
	0x01, 0x24, 0x14, 0xc4, 0x4f, 0xe0, 0xcf, 0xf4, 0x58, 0x89, 0x0b, 0xe2, 0x60, 0x20, 0xf9, 0x07,
	0x3e, 0xc2, 0x05, 0xcd, 0x87, 0xd7, 0xde, 0x8f, 0x28, 0x29, 0x70, 0xa3, 0xa7, 0xec, 0xcc, 0xbc,
	0xef, 0xf3, 0x3e, 0xf3, 0xcc, 0x33, 0xaf, 0x27, 0xe0, 0x96, 0x4b, 0xfb, 0x1e, 0x3e, 0x6c, 0xa3,
	0x81, 0xcb, 0x08, 0x0d, 0xe2, 0x67, 0x77, 0xdb, 0x07, 0x77, 0x1c, 0xcc, 0xd0, 0x9d, 0x6c, 0xca,
	0x0c, 0x23, 0xca, 0xa8, 0x7e, 0x5d, 0x06, 0x9a, 0x79, 0xa0, 0xa9, 0x02, 0x1b, 0xab, 0x3d, 0xda,
	0xa3, 0x22, 0xaa, 0xcd, 0x7f, 0xc9, 0x84, 0x86, 0xd1, 0xa3, 0xb4, 0xe7, 0xe3, 0xb6, 0x18, 0x39,
	0x83, 0xdd, 0x36, 0x23, 0x7d, 0x1c, 0x33, 0xd4, 0x0f, 0x55, 0x40, 0xd3, 0xa5, 0x71, 0x9f, 0xc6,
	0x6d, 0x07, 0xc5, 0x78, 0x58, 0xd4, 0xa5, 0x44, 0x55, 0x6c, 0xdc, 0x56, 0xd4, 0x7c, 0xf2, 0xcd,
	0x80, 0x78, 0x68, 0x9c, 0x5e, 0x36, 0x8d, 0x65, 0x38, 0xfc, 0x69, 0x16, 0xd4, 0x1e, 0x48, 0x72,
	0x8f, 0x48, 0xcc, 0x68, 0x44, 0x5c, 0xe4, 0xeb, 0xf7, 0x00, 0x50, 0x8c, 0xbb, 0xc4, 0xab, 0x6b,
	0x2d, 0x6d, 0x73, 0xde, 0x5a, 0x4b, 0x13, 0xa3, 0x76, 0x84, 0xfa, 0xfe, 0x7d, 0x98, 0xaf, 0x41,
	0xbb, 0xa4, 0x06, 0x1d, 0x4f, 0x0f, 0x81, 0x9e, 0xad, 0xec, 0x0d, 0xb1, 0xea, 0xb3, 0x2d, 0x6d,
	0xb3, 0x7c, 0x17, 0x9a, 0x67, 0x2a, 0x61, 0xaa, 0xfa, 0xd6, 0x46, 0x9a, 0x18, 0xd7, 0x47, 0x2b,
	0xe4, 0x38, 0xd0, 0xae, 0xa1, 0x09, 0x9e, 0xbb, 0xa0, 0xe2, 0x53, 0x77, 0x1f, 0x7b, 0xdd, 0x03,
	0x34, 0xf0, 0x59, 0x7d, 0x4e, 0xd4, 0x7a, 0x37, 0xab, 0x35, 0xaa, 0xc1, 0xb0, 0xde, 0xb6, 0x48,
	0x79, 0xc6, 0x33, 0xac, 0x6b, 0x69, 0x62, 0x5c, 0x91, 0x35, 0x8b, 0x48, 0xd0, 0x2e, 0xfb, 0x79,
	0x14, 0xfc, 0x71, 0x19, 0x5c, 0x52, 0x2c, 0xff, 0xa1, 0x36, 0xc7, 0x1a, 0x58, 0x71, 0xa9, 0xef,
	0x23, 0x86, 0x23, 0xe4, 0x77, 0x19, 0xdd, 0xc7, 0x81, 0x92, 0xe6, 0xba, 0x29, 0x8f, 0xd4, 0xe4,
	0x47, 0x3a, 0x24, 0xf9, 0x21, 0x25, 0x81, 0xf5, 0xc9, 0xcb, 0xc4, 0x98, 0x49, 0x13, 0xe3, 0x9a,
	0xc4, 0x1e, 0x07, 0x80, 0x7f, 0x26, 0xc6, 0xad, 0x1e, 0x61, 0x7b, 0x03, 0x87, 0x6f, 0xb9, 0xad,
	0xac, 0x21, 0xff, 0xdc, 0x8e, 0xbd, 0xfd, 0x36, 0x3b, 0x0a, 0x71, 0x2c, 0xb0, 0xec, 0x6a, 0x9e,
	0xbd, 0xc3, 0x93, 0xf5, 0xef, 0x35, 0x00, 0x3c, 0xec, 0x30, 0x45, 0x66, 0xee, 0x3c, 0x32, 0x3b,
	0x8a, 0xcc, 0x4d, 0x49, 0x86, 0x04, 0xbb, 0x3e, 0x7d, 0x21, 0x93, 0xbb, 0x0c, 0x45, 0x3d, 0xcc,
	0xba, 0xa8, 0x4f, 0x07, 0x01, 0x7b, 0x2d, 0x5a, 0x25, 0x4e, 0x41, 0x12, 0x7a, 0x04, 0x6a, 0xc8,
	0x65, 0xe4, 0x00, 0x77, 0x1d, 0xe2, 0x79, 0x24, 0xe8, 0x71, 0x81, 0xe7, 0x85, 0xc0, 0x37, 0xd2,
	0xc4, 0xa8, 0x2b, 0x81, 0xc7, 0x43, 0xa0, 0x5d, 0x95, 0x73, 0x96, 0x9c, 0xea, 0x78, 0xba, 0x0b,
	0xca, 0xf9, 0x7a, 0x5c, 0x5f, 0x68, 0xcd, 0x15, 0x6d, 0x31, 0xc5, 0x82, 0x0e, 0xf1, 0x9e, 0xbc,
	0x08, 0x70, 0xf4, 0x29, 0x0a, 0x43, 0x12, 0xf4, 0xac, 0xab, 0x69, 0x62, 0xe8, 0xb2, 0x5e, 0x01,
	0x08, 0xda, 0xc0, 0xc9, 0x6a, 0xc4, 0x5c, 0xbf, 0xe6, 0xf8, 0x89, 0x74, 0xb3, 0xe3, 0x0f, 0x23,
	0xe2, 0xe2, 0xfa, 0xa5, 0x96, 0xb6, 0x59, 0xb2, 0x3a, 0x5c, 0xb8, 0x5f, 0x13, 0x63, 0x5d, 0x2a,
	0x10, 0x7b, 0xfb, 0x26, 0xa1, 0xed, 0x3e, 0x62, 0x7b, 0xe6, 0x36, 0xee, 0x21, 0xf7, 0x68, 0x0b,
	0xbb, 0x69, 0x62, 0x40, 0x59, 0x8f, 0x0e, 0x58, 0x41, 0xd8, 0x11, 0x3c, 0x68, 0xaf, 0x8f, 0x1d,
	0xa2, 0x32, 0xe5, 0x53, 0xbe, 0xaa, 0x7f, 0xa7, 0x81, 0x8d, 0x09, 0x42, 0x34, 0x42, 0xae, 0x8f,
	0x15, 0x9f, 0x25, 0xc1, 0xe7, 0xd1, 0xc5, 0xf8, 0xdc, 0x9c, 0xc6, 0xa7, 0x08, 0x07, 0xed, 0xc6,
	0x18, 0x9d, 0x27, 0x62, 0x55, 0xb2, 0xf9, 0x16, 0x5c, 0xcb, 0xdd, 0x35, 0x4a, 0xa3, 0x24, 0x68,
	0x7c, 0x7c, 0x31, 0x1a, 0xad, 0x29, 0x76, 0x1b, 0x65, 0xb1, 0x3a, 0xb4, 0x50, 0xb1, 0xbe, 0x05,
	0xaa, 0xc5, 0x1b, 0xcd, 0xbd, 0x04, 0x84, 0x97, 0x1a, 0x69, 0x62, 0x5c, 0x9d, 0xbc, 0xf2, 0xc2,
	0x49, 0xcb, 0x85, 0x5b, 0xdf, 0xf1, 0xf4, 0x2f, 0x00, 0x88, 0x19, 0x8a, 0x58, 0x97, 0x77, 0xe1,
	0x7a, 0x59, 0xdc, 0x90, 0x86, 0x29, 0x5b, 0xb4, 0x99, 0xb5, 0x68, 0x73, 0x27, 0x6b, 0xd1, 0xd6,
	0x86, 0xba, 0x22, 0xaa, 0x17, 0xe4, 0xb9, 0xf0, 0xf8, 0x37, 0x43, 0xb3, 0x4b, 0x62, 0x82, 0x87,
	0xeb, 0x36, 0x58, 0xc2, 0x81, 0x27, 0x71, 0x2b, 0xe7, 0xe2, 0xae, 0x2b, 0xdc, 0xaa, 0xc4, 0xcd,
	0x32, 0x25, 0xea, 0x25, 0x1c, 0x78, 0x02, 0x73, 0x13, 0x2c, 0xa2, 0x30, 0xe4, 0x1b, 0x5d, 0x16,
	0x1b, 0xad, 0xa5, 0x89, 0xb1, 0xac, 0x2e, 0x8d, 0x98, 0x87, 0xf6, 0x02, 0x0a, 0xc3, 0x8e, 0xa7,
	0x77, 0x40, 0x25, 0x33, 0x16, 0xbf, 0x8a, 0xf5, 0xcb, 0x2d, 0x6d, 0x73, 0xc9, 0x7a, 0xe7, 0x24,
	0x31, 0xca, 0xca, 0x51, 0x3b, 0x47, 0x21, 0xce, 0x5b, 0x63, 0x31, 0x18, 0xda, 0x65, 0x94, 0xc7,
	0xe8, 0x8f, 0xc1, 0x95, 0x82, 0xe7, 0x50, 0x1c, 0x63, 0x21, 0x75, 0x55, 0x30, 0x68, 0xa6, 0x89,
	0xd1, 0x98, 0xe8, 0x5d, 0x59, 0x10, 0xb4, 0x6b, 0xf9, 0xec, 0x03, 0x3e, 0xd9, 0xf1, 0xf4, 0x0f,
	0xc0, 0xb2, 0xb0, 0xcd, 0x10, 0x69, 0x45, 0x20, 0xd5, 0xd3, 0xc4, 0x58, 0x95, 0x48, 0x23, 0xcb,
	0xd0, 0x2e, 0xf3, 0x71, 0x96, 0xfd, 0x1c, 0x54, 0x1c, 0x1a, 0x0c, 0x62, 0xd5, 0x89, 0xea, 0x35,
	0xe1, 0xb4, 0x7b, 0xca, 0x69, 0x6b, 0x93, 0x4e, 0xeb, 0x04, 0x2c, 0xdf, 0x66, 0x31, 0x15, 0xda,
	0x65, 0x31, 0x7c, 0x20, 0x46, 0xfa, 0x0f, 0xd3, 0x2e, 0x3b, 0x09, 0x08, 0x23, 0xc8, 0x57, 0xae,
	0xd6, 0x45, 0xad, 0xed, 0x8b, 0xb9, 0xfa, 0xed, 0xe9, 0x1d, 0x7d, 0x14, 0x72, 0xf2, 0xbe, 0x77,
	0xe4, 0xb2, 0x70, 0x38, 0x7c, 0x08, 0xaa, 0x63, 0x7d, 0x4b, 0x5f, 0x03, 0x8b, 0x0e, 0xf1, 0x86,
	0x1f, 0x26, 0x7b, 0xc1, 0x21, 0x5e, 0xc7, 0xd3, 0xd7, 0x41, 0x89, 0x4f, 0x53, 0x1e, 0x2a, 0xbe,
	0x3a, 0x25, 0x7b, 0x29, 0x4b, 0x85, 0x3f, 0xcf, 0x82, 0xd5, 0x6d, 0xd2, 0x27, 0xcc, 0x22, 0xde,
	0x53, 0xee, 0x3d, 0x97, 0xfa, 0x5b, 0x88, 0xa1, 0xb3, 0x8e, 0x56, 0xfb, 0xcf, 0x8e, 0x76, 0xf6,
	0x75, 0x8e, 0xf6, 0xb1, 0xdc, 0xc3, 0x01, 0xf2, 0x07, 0x58, 0x7c, 0xac, 0x4a, 0xd6, 0x9d, 0xf3,
	0xce, 0x75, 0x65, 0xd8, 0xc2, 0x65, 0x1e, 0x14, 0xdb, 0x7e, 0xc6, 0x7f, 0xea, 0x5f, 0x83, 0x4a,
	0x1f, 0x1d, 0x76, 0x3d, 0x12, 0xbb, 0xc2, 0x2a, 0xf3, 0x02, 0xf2, 0xfe, 0xc5, 0x8e, 0x4f, 0x19,
	0xa6, 0x08, 0x00, 0xed, 0x72, 0x1f, 0x1d, 0x6e, 0x65, 0xa3, 0xbf, 0xe6, 0xc0, 0x8d, 0x69, 0xaa,
	0x7e, 0x44, 0xa3, 0xcf, 0x06, 0x38, 0x3a, 0x7a, 0xa3, 0xee, 0xbf, 0x50, 0x57, 0x7f, 0x0e, 0xae,
	0x4e, 0xe8, 0xe2, 0xe1, 0x80, 0xf6, 0xeb, 0x0b, 0xa2, 0xd0, 0xcd, 0x34, 0x31, 0x36, 0xce, 0xd0,
	0x4f, 0xc4, 0x41, 0x7b, 0x75, 0x4c, 0xc2, 0x2d, 0x3e, 0xad, 0x3f, 0x04, 0x2b, 0x05, 0x99, 0x24,
	0xe4, 0xa2, 0x80, 0x5c, 0xcf, 0xdf, 0x61, 0xe3, 0x11, 0xd0, 0xbe, 0x3c, 0xd4, 0x52, 0xc0, 0xc0,
	0x3f, 0xe6, 0xc1, 0x5b, 0xd3, 0x4e, 0xff, 0x39, 0x61, 0x7b, 0x9f, 0xc7, 0x38, 0x7a, 0xe3, 0x82,
	0xff, 0x81, 0x0b, 0xf4, 0xaf, 0xc0, 0xe5, 0x41, 0x8c, 0xa3, 0x6e, 0xae, 0xa9, 0x7c, 0x10, 0xbe,
	0x7f, 0x9e, 0xa6, 0x6b, 0xb2, 0xc2, 0x68, 0x32, 0xb4, 0x2b, 0x7c, 0xc2, 0x52, 0xe2, 0x5a, 0x8f,
	0x5f, 0x9e, 0x34, 0xb5, 0x57, 0x27, 0x4d, 0xed, 0xf7, 0x93, 0xa6, 0x76, 0x7c, 0xda, 0x9c, 0x79,
	0x75, 0xda, 0x9c, 0xf9, 0xe5, 0xb4, 0x39, 0xf3, 0xe5, 0xbd, 0x91, 0xc7, 0x37, 0x7f, 0xf3, 0xde,
	0xa6, 0xbb, 0xbb, 0xc4, 0x25, 0xc8, 0x57, 0xe3, 0xf6, 0xc8, 0xff, 0xae, 0xe2, 0x39, 0xee, 0x2c,
	0x8a, 0x87, 0xc7, 0x7b, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x49, 0x8f, 0xd6, 0xe2, 0xdd, 0x0e,
	0x00, 0x00,
}

func (m *AuctionHistorical) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionHistorical) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionHistorical) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LockedVault != nil {
		{
			size, err := m.LockedVault.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuctionHistorical != nil {
		{
			size, err := m.AuctionHistorical.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.AuctionId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Auction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Auction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Auction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CollateralTokenInitialPrice.Size()
		i -= size
		if _, err := m.CollateralTokenInitialPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	{
		size := m.BonusAmount.Size()
		i -= size
		if _, err := m.BonusAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.DebtAssetId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.DebtAssetId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CollateralAssetId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.CollateralAssetId))
		i--
		dAtA[i] = 0x78
	}
	if m.AuctionType {
		i--
		if m.AuctionType {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.AppId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AppId))
		i--
		dAtA[i] = 0x68
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.EndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EndTime):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintAuction(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x62
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.StartTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.StartTime):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintAuction(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x5a
	if m.LockedVaultId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.LockedVaultId))
		i--
		dAtA[i] = 0x50
	}
	{
		size := m.DebtTokenOraclePrice.Size()
		i -= size
		if _, err := m.DebtTokenOraclePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.CollateralTokenOraclePrice.Size()
		i -= size
		if _, err := m.CollateralTokenOraclePrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size := m.CollateralTokenAuctionPrice.Size()
		i -= size
		if _, err := m.CollateralTokenAuctionPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.BiddingIds) > 0 {
		for iNdEx := len(m.BiddingIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BiddingIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ActiveBiddingId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.ActiveBiddingId))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.DebtToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.CollateralToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.AuctionId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.AuctionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BidOwnerMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidOwnerMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BidOwnerMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BidOwner) > 0 {
		i -= len(m.BidOwner)
		copy(dAtA[i:], m.BidOwner)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.BidOwner)))
		i--
		dAtA[i] = 0x12
	}
	if m.BidId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.BidId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimitBidProtocolData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimitBidProtocolData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimitBidProtocolData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxDiscount.Size()
		i -= size
		if _, err := m.MaxDiscount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BidValue.Size()
		i -= size
		if _, err := m.BidValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.DebtAssetId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.DebtAssetId))
		i--
		dAtA[i] = 0x10
	}
	if m.CollateralAssetId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.CollateralAssetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimitBidProtocolDataForQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimitBidProtocolDataForQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimitBidProtocolDataForQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DebtAssetDenom) > 0 {
		i -= len(m.DebtAssetDenom)
		copy(dAtA[i:], m.DebtAssetDenom)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.DebtAssetDenom)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CollateralAssetDenom) > 0 {
		i -= len(m.CollateralAssetDenom)
		copy(dAtA[i:], m.CollateralAssetDenom)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.CollateralAssetDenom)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.MaxDiscount.Size()
		i -= size
		if _, err := m.MaxDiscount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BidValue.Size()
		i -= size
		if _, err := m.BidValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.DebtAssetId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.DebtAssetId))
		i--
		dAtA[i] = 0x10
	}
	if m.CollateralAssetId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.CollateralAssetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LimitBidProtocolDataWithUserForQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimitBidProtocolDataWithUserForQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LimitBidProtocolDataWithUserForQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.UserBidValue.Size()
		i -= size
		if _, err := m.UserBidValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.DebtAssetDenom) > 0 {
		i -= len(m.DebtAssetDenom)
		copy(dAtA[i:], m.DebtAssetDenom)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.DebtAssetDenom)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CollateralAssetDenom) > 0 {
		i -= len(m.CollateralAssetDenom)
		copy(dAtA[i:], m.CollateralAssetDenom)
		i = encodeVarintAuction(dAtA, i, uint64(len(m.CollateralAssetDenom)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.MaxDiscount.Size()
		i -= size
		if _, err := m.MaxDiscount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BidValue.Size()
		i -= size
		if _, err := m.BidValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuction(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.DebtAssetId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.DebtAssetId))
		i--
		dAtA[i] = 0x10
	}
	if m.CollateralAssetId != 0 {
		i = encodeVarintAuction(dAtA, i, uint64(m.CollateralAssetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuction(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuction(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AuctionHistorical) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	if m.AuctionHistorical != nil {
		l = m.AuctionHistorical.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	if m.LockedVault != nil {
		l = m.LockedVault.Size()
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *Auction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuctionId != 0 {
		n += 1 + sovAuction(uint64(m.AuctionId))
	}
	l = m.CollateralToken.Size()
	n += 1 + l + sovAuction(uint64(l))
	l = m.DebtToken.Size()
	n += 1 + l + sovAuction(uint64(l))
	if m.ActiveBiddingId != 0 {
		n += 1 + sovAuction(uint64(m.ActiveBiddingId))
	}
	if len(m.BiddingIds) > 0 {
		for _, e := range m.BiddingIds {
			l = e.Size()
			n += 1 + l + sovAuction(uint64(l))
		}
	}
	l = m.CollateralTokenAuctionPrice.Size()
	n += 1 + l + sovAuction(uint64(l))
	l = m.CollateralTokenOraclePrice.Size()
	n += 1 + l + sovAuction(uint64(l))
	l = m.DebtTokenOraclePrice.Size()
	n += 1 + l + sovAuction(uint64(l))
	if m.LockedVaultId != 0 {
		n += 1 + sovAuction(uint64(m.LockedVaultId))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.StartTime)
	n += 1 + l + sovAuction(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.EndTime)
	n += 1 + l + sovAuction(uint64(l))
	if m.AppId != 0 {
		n += 1 + sovAuction(uint64(m.AppId))
	}
	if m.AuctionType {
		n += 2
	}
	if m.CollateralAssetId != 0 {
		n += 1 + sovAuction(uint64(m.CollateralAssetId))
	}
	if m.DebtAssetId != 0 {
		n += 2 + sovAuction(uint64(m.DebtAssetId))
	}
	l = m.BonusAmount.Size()
	n += 2 + l + sovAuction(uint64(l))
	l = m.CollateralTokenInitialPrice.Size()
	n += 2 + l + sovAuction(uint64(l))
	return n
}

func (m *BidOwnerMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BidId != 0 {
		n += 1 + sovAuction(uint64(m.BidId))
	}
	l = len(m.BidOwner)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *LimitBidProtocolData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollateralAssetId != 0 {
		n += 1 + sovAuction(uint64(m.CollateralAssetId))
	}
	if m.DebtAssetId != 0 {
		n += 1 + sovAuction(uint64(m.DebtAssetId))
	}
	l = m.BidValue.Size()
	n += 1 + l + sovAuction(uint64(l))
	l = m.MaxDiscount.Size()
	n += 1 + l + sovAuction(uint64(l))
	return n
}

func (m *LimitBidProtocolDataForQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollateralAssetId != 0 {
		n += 1 + sovAuction(uint64(m.CollateralAssetId))
	}
	if m.DebtAssetId != 0 {
		n += 1 + sovAuction(uint64(m.DebtAssetId))
	}
	l = m.BidValue.Size()
	n += 1 + l + sovAuction(uint64(l))
	l = m.MaxDiscount.Size()
	n += 1 + l + sovAuction(uint64(l))
	l = len(m.CollateralAssetDenom)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	l = len(m.DebtAssetDenom)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	return n
}

func (m *LimitBidProtocolDataWithUserForQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CollateralAssetId != 0 {
		n += 1 + sovAuction(uint64(m.CollateralAssetId))
	}
	if m.DebtAssetId != 0 {
		n += 1 + sovAuction(uint64(m.DebtAssetId))
	}
	l = m.BidValue.Size()
	n += 1 + l + sovAuction(uint64(l))
	l = m.MaxDiscount.Size()
	n += 1 + l + sovAuction(uint64(l))
	l = len(m.CollateralAssetDenom)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	l = len(m.DebtAssetDenom)
	if l > 0 {
		n += 1 + l + sovAuction(uint64(l))
	}
	l = m.UserBidValue.Size()
	n += 1 + l + sovAuction(uint64(l))
	return n
}

func sovAuction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuction(x uint64) (n int) {
	return sovAuction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuctionHistorical) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionHistorical: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionHistorical: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionHistorical", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionHistorical == nil {
				m.AuctionHistorical = &Auction{}
			}
			if err := m.AuctionHistorical.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedVault", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockedVault == nil {
				m.LockedVault = &types.LockedVault{}
			}
			if err := m.LockedVault.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Auction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Auction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Auction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			m.AuctionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuctionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DebtToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveBiddingId", wireType)
			}
			m.ActiveBiddingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveBiddingId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiddingIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BiddingIds = append(m.BiddingIds, &BidOwnerMapping{})
			if err := m.BiddingIds[len(m.BiddingIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralTokenAuctionPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralTokenAuctionPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralTokenOraclePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralTokenOraclePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtTokenOraclePrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DebtTokenOraclePrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedVaultId", wireType)
			}
			m.LockedVaultId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockedVaultId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionType", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuctionType = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAssetId", wireType)
			}
			m.CollateralAssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollateralAssetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtAssetId", wireType)
			}
			m.DebtAssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebtAssetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BonusAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralTokenInitialPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CollateralTokenInitialPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidOwnerMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: bidOwnerMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: bidOwnerMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidId", wireType)
			}
			m.BidId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BidId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BidOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimitBidProtocolData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimitBidProtocolData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimitBidProtocolData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAssetId", wireType)
			}
			m.CollateralAssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollateralAssetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtAssetId", wireType)
			}
			m.DebtAssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebtAssetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BidValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDiscount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxDiscount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimitBidProtocolDataForQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimitBidProtocolDataForQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimitBidProtocolDataForQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAssetId", wireType)
			}
			m.CollateralAssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollateralAssetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtAssetId", wireType)
			}
			m.DebtAssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebtAssetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BidValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDiscount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxDiscount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAssetDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralAssetDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtAssetDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebtAssetDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimitBidProtocolDataWithUserForQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimitBidProtocolDataWithUserForQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimitBidProtocolDataWithUserForQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAssetId", wireType)
			}
			m.CollateralAssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollateralAssetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtAssetId", wireType)
			}
			m.DebtAssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebtAssetId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BidValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDiscount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxDiscount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralAssetDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralAssetDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebtAssetDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebtAssetDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserBidValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UserBidValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuction
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuction
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuction
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuction        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuction          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuction = fmt.Errorf("proto: unexpected end of group")
)
