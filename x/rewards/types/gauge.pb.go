// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: petri/rewards/v1beta1/gauge.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/duration"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LiquidtyGaugeMetaData struct {
	PoolId       uint64   `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	IsMasterPool bool     `protobuf:"varint,2,opt,name=is_master_pool,json=isMasterPool,proto3" json:"is_master_pool,omitempty"`
	ChildPoolIds []uint64 `protobuf:"varint,3,rep,packed,name=child_pool_ids,json=childPoolIds,proto3" json:"child_pool_ids,omitempty"`
}

func (m *LiquidtyGaugeMetaData) Reset()         { *m = LiquidtyGaugeMetaData{} }
func (m *LiquidtyGaugeMetaData) String() string { return proto.CompactTextString(m) }
func (*LiquidtyGaugeMetaData) ProtoMessage()    {}
func (*LiquidtyGaugeMetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f71b41b4b0f8e223, []int{0}
}
func (m *LiquidtyGaugeMetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidtyGaugeMetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidtyGaugeMetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidtyGaugeMetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidtyGaugeMetaData.Merge(m, src)
}
func (m *LiquidtyGaugeMetaData) XXX_Size() int {
	return m.Size()
}
func (m *LiquidtyGaugeMetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidtyGaugeMetaData.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidtyGaugeMetaData proto.InternalMessageInfo

func (m *LiquidtyGaugeMetaData) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *LiquidtyGaugeMetaData) GetIsMasterPool() bool {
	if m != nil {
		return m.IsMasterPool
	}
	return false
}

func (m *LiquidtyGaugeMetaData) GetChildPoolIds() []uint64 {
	if m != nil {
		return m.ChildPoolIds
	}
	return nil
}

type Gauge struct {
	Id                uint64                                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	From              string                                  `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
	CreatedAt         time.Time                               `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	StartTime         time.Time                               `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time" yaml:"start_time"`
	GaugeTypeId       uint64                                  `protobuf:"varint,5,opt,name=gauge_type_id,json=gaugeTypeId,proto3" json:"gauge_type_id,omitempty"`
	TriggerDuration   time.Duration                           `protobuf:"bytes,6,opt,name=trigger_duration,json=triggerDuration,proto3,stdduration" json:"trigger_duration,omitempty" yaml:"trigger_duration"`
	DepositAmount     github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,7,opt,name=deposit_amount,json=depositAmount,proto3,casttype=github.com/cosmos/cosmos-sdk/types.Coin" json:"deposit_amount"`
	TotalTriggers     uint64                                  `protobuf:"varint,8,opt,name=total_triggers,json=totalTriggers,proto3" json:"total_triggers,omitempty"`
	TriggeredCount    uint64                                  `protobuf:"varint,9,opt,name=triggered_count,json=triggeredCount,proto3" json:"triggered_count,omitempty"`
	DistributedAmount github_com_cosmos_cosmos_sdk_types.Coin `protobuf:"bytes,10,opt,name=distributed_amount,json=distributedAmount,proto3,casttype=github.com/cosmos/cosmos-sdk/types.Coin" json:"distributed_amount"`
	IsActive          bool                                    `protobuf:"varint,11,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	ForSwapFee        bool                                    `protobuf:"varint,12,opt,name=for_swap_fee,json=forSwapFee,proto3" json:"for_swap_fee,omitempty"`
	// Types that are valid to be assigned to Kind:
	//	*Gauge_LiquidityMetaData
	Kind  isGauge_Kind `protobuf_oneof:"kind"`
	AppId uint64       `protobuf:"varint,14,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
}

func (m *Gauge) Reset()         { *m = Gauge{} }
func (m *Gauge) String() string { return proto.CompactTextString(m) }
func (*Gauge) ProtoMessage()    {}
func (*Gauge) Descriptor() ([]byte, []int) {
	return fileDescriptor_f71b41b4b0f8e223, []int{1}
}
func (m *Gauge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Gauge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Gauge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Gauge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gauge.Merge(m, src)
}
func (m *Gauge) XXX_Size() int {
	return m.Size()
}
func (m *Gauge) XXX_DiscardUnknown() {
	xxx_messageInfo_Gauge.DiscardUnknown(m)
}

var xxx_messageInfo_Gauge proto.InternalMessageInfo

type isGauge_Kind interface {
	isGauge_Kind()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Gauge_LiquidityMetaData struct {
	LiquidityMetaData *LiquidtyGaugeMetaData `protobuf:"bytes,13,opt,name=liquidity_meta_data,json=liquidityMetaData,proto3,oneof" json:"liquidity_meta_data,omitempty"`
}

func (*Gauge_LiquidityMetaData) isGauge_Kind() {}

func (m *Gauge) GetKind() isGauge_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *Gauge) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Gauge) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Gauge) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *Gauge) GetStartTime() time.Time {
	if m != nil {
		return m.StartTime
	}
	return time.Time{}
}

func (m *Gauge) GetGaugeTypeId() uint64 {
	if m != nil {
		return m.GaugeTypeId
	}
	return 0
}

func (m *Gauge) GetTriggerDuration() time.Duration {
	if m != nil {
		return m.TriggerDuration
	}
	return 0
}

func (m *Gauge) GetDepositAmount() github_com_cosmos_cosmos_sdk_types.Coin {
	if m != nil {
		return m.DepositAmount
	}
	return github_com_cosmos_cosmos_sdk_types.Coin{}
}

func (m *Gauge) GetTotalTriggers() uint64 {
	if m != nil {
		return m.TotalTriggers
	}
	return 0
}

func (m *Gauge) GetTriggeredCount() uint64 {
	if m != nil {
		return m.TriggeredCount
	}
	return 0
}

func (m *Gauge) GetDistributedAmount() github_com_cosmos_cosmos_sdk_types.Coin {
	if m != nil {
		return m.DistributedAmount
	}
	return github_com_cosmos_cosmos_sdk_types.Coin{}
}

func (m *Gauge) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *Gauge) GetForSwapFee() bool {
	if m != nil {
		return m.ForSwapFee
	}
	return false
}

func (m *Gauge) GetLiquidityMetaData() *LiquidtyGaugeMetaData {
	if x, ok := m.GetKind().(*Gauge_LiquidityMetaData); ok {
		return x.LiquidityMetaData
	}
	return nil
}

func (m *Gauge) GetAppId() uint64 {
	if m != nil {
		return m.AppId
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Gauge) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Gauge_LiquidityMetaData)(nil),
	}
}

type GaugeByTriggerDuration struct {
	TriggerDuration time.Duration `protobuf:"bytes,1,opt,name=trigger_duration,json=triggerDuration,proto3,stdduration" json:"trigger_duration,omitempty" yaml:"trigger_duration"`
	GaugeIds        []uint64      `protobuf:"varint,2,rep,packed,name=gauge_ids,json=gaugeIds,proto3" json:"gauge_ids,omitempty"`
}

func (m *GaugeByTriggerDuration) Reset()         { *m = GaugeByTriggerDuration{} }
func (m *GaugeByTriggerDuration) String() string { return proto.CompactTextString(m) }
func (*GaugeByTriggerDuration) ProtoMessage()    {}
func (*GaugeByTriggerDuration) Descriptor() ([]byte, []int) {
	return fileDescriptor_f71b41b4b0f8e223, []int{2}
}
func (m *GaugeByTriggerDuration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GaugeByTriggerDuration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GaugeByTriggerDuration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GaugeByTriggerDuration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GaugeByTriggerDuration.Merge(m, src)
}
func (m *GaugeByTriggerDuration) XXX_Size() int {
	return m.Size()
}
func (m *GaugeByTriggerDuration) XXX_DiscardUnknown() {
	xxx_messageInfo_GaugeByTriggerDuration.DiscardUnknown(m)
}

var xxx_messageInfo_GaugeByTriggerDuration proto.InternalMessageInfo

func (m *GaugeByTriggerDuration) GetTriggerDuration() time.Duration {
	if m != nil {
		return m.TriggerDuration
	}
	return 0
}

func (m *GaugeByTriggerDuration) GetGaugeIds() []uint64 {
	if m != nil {
		return m.GaugeIds
	}
	return nil
}

func init() {
	proto.RegisterType((*LiquidtyGaugeMetaData)(nil), "petri.rewards.v1beta1.LiquidtyGaugeMetaData")
	proto.RegisterType((*Gauge)(nil), "petri.rewards.v1beta1.Gauge")
	proto.RegisterType((*GaugeByTriggerDuration)(nil), "petri.rewards.v1beta1.GaugeByTriggerDuration")
}

func init() {
	proto.RegisterFile("petri/rewards/v1beta1/gauge.proto", fileDescriptor_f71b41b4b0f8e223)
}

var fileDescriptor_f71b41b4b0f8e223 = []byte{
	// 747 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x54, 0xbf, 0x6f, 0xfb, 0x44,
	0x14, 0x8f, 0xd3, 0x34, 0x4d, 0x2e, 0x3f, 0xbe, 0xd4, 0xd0, 0xd6, 0xa4, 0x22, 0x8e, 0x0c, 0xa8,
	0x19, 0xa8, 0xad, 0xc2, 0xc6, 0x96, 0xb4, 0x02, 0x22, 0xa8, 0x54, 0x85, 0x0c, 0x88, 0xe5, 0x74,
	0xf1, 0x5d, 0xdc, 0x53, 0xed, 0x9c, 0xeb, 0xbb, 0xb4, 0x58, 0x62, 0x67, 0xed, 0x88, 0xc4, 0x1f,
	0xc3, 0xda, 0xb1, 0x23, 0x53, 0x40, 0xed, 0xc6, 0xd8, 0x91, 0x09, 0xdd, 0xf3, 0x25, 0x85, 0xd0,
	0x05, 0x09, 0x89, 0xc9, 0xbe, 0xcf, 0x7d, 0xee, 0xf3, 0x3e, 0xef, 0xdd, 0x7b, 0x87, 0xbc, 0x50,
	0x24, 0x94, 0x7d, 0x17, 0x64, 0xec, 0x96, 0x64, 0x54, 0x06, 0x37, 0x27, 0x53, 0xa6, 0xc8, 0x49,
	0x10, 0x91, 0x45, 0xc4, 0xfc, 0x34, 0x13, 0x4a, 0xd8, 0xfb, 0x05, 0xc7, 0x37, 0x1c, 0xdf, 0x70,
	0x3a, 0xef, 0x44, 0x22, 0x12, 0x40, 0x09, 0xf4, 0x5f, 0xc1, 0xee, 0xb8, 0x91, 0x10, 0x51, 0xcc,
	0x02, 0x58, 0x4d, 0x17, 0xb3, 0x40, 0xf1, 0x84, 0x49, 0x45, 0x92, 0xd4, 0x10, 0xba, 0x9b, 0x04,
	0xba, 0xc8, 0x88, 0xe2, 0x62, 0xbe, 0xda, 0x0f, 0x85, 0x4c, 0x84, 0x0c, 0xa6, 0x44, 0xb2, 0xb5,
	0x9f, 0x50, 0x70, 0xb3, 0xef, 0x7d, 0x8f, 0xf6, 0xbe, 0xe2, 0xd7, 0x0b, 0x4e, 0x55, 0xfe, 0xb9,
	0x76, 0x79, 0xce, 0x14, 0x39, 0x23, 0x8a, 0xd8, 0x07, 0x68, 0x27, 0x15, 0x22, 0xc6, 0x9c, 0x3a,
	0x56, 0xcf, 0xea, 0x57, 0xc6, 0x55, 0xbd, 0x1c, 0x51, 0xfb, 0x03, 0xd4, 0xe6, 0x12, 0x27, 0x44,
	0x2a, 0x96, 0x61, 0x8d, 0x39, 0xe5, 0x9e, 0xd5, 0xaf, 0x8d, 0x9b, 0x5c, 0x9e, 0x03, 0x78, 0x21,
	0x44, 0xac, 0x59, 0xe1, 0x25, 0x8f, 0x29, 0x36, 0x22, 0xd2, 0xd9, 0xea, 0x6d, 0xf5, 0x2b, 0xe3,
	0x26, 0xa0, 0x17, 0x20, 0x25, 0xbd, 0x9f, 0x76, 0xd0, 0x36, 0x84, 0xb5, 0xdb, 0xa8, 0xbc, 0x8e,
	0x54, 0xe6, 0xd4, 0x7e, 0x1f, 0x55, 0x66, 0x99, 0x48, 0x40, 0xbb, 0x3e, 0x7c, 0xf3, 0xbc, 0x74,
	0x1b, 0x39, 0x49, 0xe2, 0x4f, 0x3d, 0x8d, 0x7a, 0x63, 0xd8, 0xb4, 0xbf, 0x41, 0x28, 0xcc, 0x18,
	0x51, 0x8c, 0x62, 0xa2, 0x9c, 0xad, 0x9e, 0xd5, 0x6f, 0x7c, 0xdc, 0xf1, 0x8b, 0x8a, 0xf8, 0xab,
	0x8a, 0xf8, 0x93, 0x55, 0xc9, 0x86, 0xef, 0xdd, 0x2f, 0xdd, 0xd2, 0xf3, 0xd2, 0xdd, 0x2d, 0xa4,
	0x5e, 0xce, 0x7a, 0x77, 0xbf, 0xba, 0xd6, 0xb8, 0x6e, 0x80, 0x81, 0xd2, 0xca, 0x52, 0x91, 0x4c,
	0x61, 0x5d, 0x6f, 0xa7, 0xf2, 0x6f, 0x95, 0x5f, 0xce, 0x1a, 0x65, 0x00, 0x34, 0xdd, 0xf6, 0x50,
	0x0b, 0xda, 0x01, 0xab, 0x3c, 0x65, 0xba, 0xba, 0xdb, 0x90, 0x73, 0x03, 0xc0, 0x49, 0x9e, 0xb2,
	0x11, 0xb5, 0x7f, 0xb0, 0xd0, 0x5b, 0x2a, 0xe3, 0x51, 0xc4, 0x32, 0xbc, 0xba, 0x4f, 0xa7, 0x0a,
	0x26, 0xde, 0xfd, 0x87, 0x89, 0x33, 0x43, 0x18, 0x0e, 0xb4, 0x87, 0xdf, 0x97, 0x6e, 0x67, 0xf3,
	0xe8, 0x47, 0x22, 0xe1, 0x8a, 0x25, 0xa9, 0xca, 0x9f, 0x97, 0xee, 0x41, 0xe1, 0x70, 0x93, 0xe3,
	0xfd, 0xa8, 0x7d, 0xbe, 0x31, 0xf0, 0x4a, 0xd3, 0xbe, 0x46, 0x6d, 0xca, 0x52, 0x21, 0xb9, 0xc2,
	0x24, 0x11, 0x8b, 0xb9, 0x72, 0x76, 0x8c, 0x8d, 0xa2, 0xaf, 0x7c, 0xdd, 0x57, 0xab, 0x1e, 0xf6,
	0x4f, 0x05, 0x9f, 0x0f, 0x03, 0x6d, 0xe3, 0x8f, 0xa5, 0x7b, 0x14, 0x71, 0x75, 0xb9, 0x98, 0xfa,
	0xa1, 0x48, 0x02, 0xd3, 0x84, 0xc5, 0xe7, 0x58, 0xd2, 0xab, 0x40, 0x67, 0x2f, 0xe1, 0xc0, 0xb8,
	0x65, 0x22, 0x0c, 0x20, 0x80, 0xfd, 0x21, 0x6a, 0x2b, 0xa1, 0x48, 0x8c, 0x8d, 0x17, 0xe9, 0xd4,
	0xa0, 0x42, 0x2d, 0x40, 0x27, 0x06, 0xb4, 0x8f, 0xd0, 0xca, 0x2c, 0xa3, 0x38, 0x04, 0x6b, 0x75,
	0xe0, 0xb5, 0xd7, 0xf0, 0x29, 0xe8, 0xe5, 0xc8, 0xa6, 0x5c, 0xaa, 0x8c, 0x4f, 0x17, 0x70, 0xd9,
	0x45, 0x1a, 0xe8, 0x3f, 0x4f, 0x63, 0xf7, 0x2f, 0x51, 0x4c, 0x2a, 0x87, 0xa8, 0xce, 0x25, 0x26,
	0xa1, 0xe2, 0x37, 0xcc, 0x69, 0xc0, 0x94, 0xd4, 0xb8, 0x1c, 0xc0, 0xda, 0xee, 0xa1, 0xe6, 0x4c,
	0x64, 0x58, 0xde, 0x92, 0x14, 0xcf, 0x18, 0x73, 0x9a, 0xb0, 0x8f, 0x66, 0x22, 0xfb, 0xfa, 0x96,
	0xa4, 0x9f, 0x31, 0x66, 0x63, 0xf4, 0x76, 0x0c, 0xb3, 0xc9, 0x55, 0x8e, 0x13, 0xa6, 0x08, 0xa6,
	0x44, 0x11, 0xa7, 0x05, 0xd6, 0x8f, 0xfd, 0xd7, 0x1f, 0x12, 0xff, 0xd5, 0x71, 0xfe, 0xa2, 0x34,
	0xde, 0x5d, 0x6b, 0xad, 0x67, 0x7c, 0x0f, 0x55, 0x49, 0x9a, 0xea, 0x26, 0x6c, 0x43, 0xe9, 0xb6,
	0x49, 0x9a, 0x8e, 0xe8, 0xb0, 0x8a, 0x2a, 0x57, 0x7c, 0x4e, 0xbd, 0x9f, 0x2d, 0xb4, 0x0f, 0x2a,
	0xc3, 0x7c, 0xb2, 0xd1, 0x17, 0xaf, 0x76, 0xa8, 0xf5, 0x7f, 0x74, 0xe8, 0x21, 0xaa, 0x17, 0xf3,
	0xa4, 0xdf, 0x98, 0x32, 0xbc, 0x31, 0x35, 0x00, 0x46, 0x54, 0x0e, 0xbf, 0xbc, 0x7f, 0xec, 0x5a,
	0x0f, 0x8f, 0x5d, 0xeb, 0xb7, 0xc7, 0xae, 0x75, 0xf7, 0xd4, 0x2d, 0x3d, 0x3c, 0x75, 0x4b, 0xbf,
	0x3c, 0x75, 0x4b, 0xdf, 0x9e, 0xfc, 0xed, 0x5a, 0x75, 0x21, 0x8f, 0xc5, 0x6c, 0xc6, 0x43, 0x4e,
	0x62, 0xb3, 0x0e, 0x5e, 0xde, 0x71, 0xb8, 0xe5, 0x69, 0x15, 0x12, 0xfa, 0xe4, 0xcf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x67, 0xff, 0x30, 0x7e, 0xe6, 0x05, 0x00, 0x00,
}

func (m *LiquidtyGaugeMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidtyGaugeMetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidtyGaugeMetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChildPoolIds) > 0 {
		dAtA2 := make([]byte, len(m.ChildPoolIds)*10)
		var j1 int
		for _, num := range m.ChildPoolIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintGauge(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsMasterPool {
		i--
		if m.IsMasterPool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.PoolId != 0 {
		i = encodeVarintGauge(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Gauge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gauge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Gauge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AppId != 0 {
		i = encodeVarintGauge(dAtA, i, uint64(m.AppId))
		i--
		dAtA[i] = 0x70
	}
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ForSwapFee {
		i--
		if m.ForSwapFee {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	{
		size, err := m.DistributedAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGauge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.TriggeredCount != 0 {
		i = encodeVarintGauge(dAtA, i, uint64(m.TriggeredCount))
		i--
		dAtA[i] = 0x48
	}
	if m.TotalTriggers != 0 {
		i = encodeVarintGauge(dAtA, i, uint64(m.TotalTriggers))
		i--
		dAtA[i] = 0x40
	}
	{
		size, err := m.DepositAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGauge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	n5, err5 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TriggerDuration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.TriggerDuration):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintGauge(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x32
	if m.GaugeTypeId != 0 {
		i = encodeVarintGauge(dAtA, i, uint64(m.GaugeTypeId))
		i--
		dAtA[i] = 0x28
	}
	n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.StartTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.StartTime):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintGauge(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x22
	n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintGauge(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x1a
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintGauge(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintGauge(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Gauge_LiquidityMetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Gauge_LiquidityMetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LiquidityMetaData != nil {
		{
			size, err := m.LiquidityMetaData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGauge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *GaugeByTriggerDuration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GaugeByTriggerDuration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GaugeByTriggerDuration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GaugeIds) > 0 {
		dAtA10 := make([]byte, len(m.GaugeIds)*10)
		var j9 int
		for _, num := range m.GaugeIds {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintGauge(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x12
	}
	n11, err11 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TriggerDuration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.TriggerDuration):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintGauge(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintGauge(dAtA []byte, offset int, v uint64) int {
	offset -= sovGauge(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LiquidtyGaugeMetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovGauge(uint64(m.PoolId))
	}
	if m.IsMasterPool {
		n += 2
	}
	if len(m.ChildPoolIds) > 0 {
		l = 0
		for _, e := range m.ChildPoolIds {
			l += sovGauge(uint64(e))
		}
		n += 1 + sovGauge(uint64(l)) + l
	}
	return n
}

func (m *Gauge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGauge(uint64(m.Id))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovGauge(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovGauge(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.StartTime)
	n += 1 + l + sovGauge(uint64(l))
	if m.GaugeTypeId != 0 {
		n += 1 + sovGauge(uint64(m.GaugeTypeId))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TriggerDuration)
	n += 1 + l + sovGauge(uint64(l))
	l = m.DepositAmount.Size()
	n += 1 + l + sovGauge(uint64(l))
	if m.TotalTriggers != 0 {
		n += 1 + sovGauge(uint64(m.TotalTriggers))
	}
	if m.TriggeredCount != 0 {
		n += 1 + sovGauge(uint64(m.TriggeredCount))
	}
	l = m.DistributedAmount.Size()
	n += 1 + l + sovGauge(uint64(l))
	if m.IsActive {
		n += 2
	}
	if m.ForSwapFee {
		n += 2
	}
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	if m.AppId != 0 {
		n += 1 + sovGauge(uint64(m.AppId))
	}
	return n
}

func (m *Gauge_LiquidityMetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiquidityMetaData != nil {
		l = m.LiquidityMetaData.Size()
		n += 1 + l + sovGauge(uint64(l))
	}
	return n
}
func (m *GaugeByTriggerDuration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TriggerDuration)
	n += 1 + l + sovGauge(uint64(l))
	if len(m.GaugeIds) > 0 {
		l = 0
		for _, e := range m.GaugeIds {
			l += sovGauge(uint64(e))
		}
		n += 1 + sovGauge(uint64(l)) + l
	}
	return n
}

func sovGauge(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGauge(x uint64) (n int) {
	return sovGauge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LiquidtyGaugeMetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGauge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidtyGaugeMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidtyGaugeMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMasterPool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMasterPool = bool(v != 0)
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGauge
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChildPoolIds = append(m.ChildPoolIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGauge
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGauge
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGauge
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ChildPoolIds) == 0 {
					m.ChildPoolIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGauge
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChildPoolIds = append(m.ChildPoolIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildPoolIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGauge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGauge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gauge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGauge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gauge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gauge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGauge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGauge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGauge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGauge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGauge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGauge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GaugeTypeId", wireType)
			}
			m.GaugeTypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GaugeTypeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGauge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGauge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TriggerDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGauge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGauge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTriggers", wireType)
			}
			m.TotalTriggers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTriggers |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggeredCount", wireType)
			}
			m.TriggeredCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggeredCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGauge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGauge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DistributedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForSwapFee", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForSwapFee = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityMetaData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGauge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGauge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LiquidtyGaugeMetaData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Gauge_LiquidityMetaData{v}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGauge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGauge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GaugeByTriggerDuration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGauge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GaugeByTriggerDuration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GaugeByTriggerDuration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGauge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGauge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TriggerDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGauge
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GaugeIds = append(m.GaugeIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGauge
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGauge
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGauge
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GaugeIds) == 0 {
					m.GaugeIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGauge
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GaugeIds = append(m.GaugeIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GaugeIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGauge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGauge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGauge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGauge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGauge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGauge
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGauge
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGauge
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGauge        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGauge          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGauge = fmt.Errorf("proto: unexpected end of group")
)
