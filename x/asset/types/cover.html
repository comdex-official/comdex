
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>types: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/comdex-official/comdex/x/asset/types/asset.go (92.3%)</option>
				
				<option value="file1">github.com/comdex-official/comdex/x/asset/types/asset.pb.go (0.9%)</option>
				
				<option value="file2">github.com/comdex-official/comdex/x/asset/types/codec.go (0.0%)</option>
				
				<option value="file3">github.com/comdex-official/comdex/x/asset/types/events.pb.go (1.4%)</option>
				
				<option value="file4">github.com/comdex-official/comdex/x/asset/types/genesis.go (100.0%)</option>
				
				<option value="file5">github.com/comdex-official/comdex/x/asset/types/genesis.pb.go (0.7%)</option>
				
				<option value="file6">github.com/comdex-official/comdex/x/asset/types/gov.go (15.4%)</option>
				
				<option value="file7">github.com/comdex-official/comdex/x/asset/types/gov.pb.go (0.9%)</option>
				
				<option value="file8">github.com/comdex-official/comdex/x/asset/types/keys.go (100.0%)</option>
				
				<option value="file9">github.com/comdex-official/comdex/x/asset/types/msg.go (4.7%)</option>
				
				<option value="file10">github.com/comdex-official/comdex/x/asset/types/msg.pb.go (0.8%)</option>
				
				<option value="file11">github.com/comdex-official/comdex/x/asset/types/oracle.go (100.0%)</option>
				
				<option value="file12">github.com/comdex-official/comdex/x/asset/types/oracle.pb.go (0.9%)</option>
				
				<option value="file13">github.com/comdex-official/comdex/x/asset/types/pair.go (90.9%)</option>
				
				<option value="file14">github.com/comdex-official/comdex/x/asset/types/pair.pb.go (0.9%)</option>
				
				<option value="file15">github.com/comdex-official/comdex/x/asset/types/params.go (25.8%)</option>
				
				<option value="file16">github.com/comdex-official/comdex/x/asset/types/params.pb.go (0.8%)</option>
				
				<option value="file17">github.com/comdex-official/comdex/x/asset/types/querier.pb.go (0.9%)</option>
				
				<option value="file18">github.com/comdex-official/comdex/x/asset/types/querier.pb.gw.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package types

import (
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/errors"
)

const (
        MaxAssetNameLength = 16
)

func (m *Asset) Validate() error <span class="cov8" title="1">{
        if m.Id == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("id cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("name cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(m.Name) &gt; MaxAssetNameLength </span><span class="cov8" title="1">{
                return fmt.Errorf("name length cannot be greater than %d", MaxAssetNameLength)
        }</span>
        <span class="cov8" title="1">if m.Denom == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("denom cannot be empty")
        }</span>
        <span class="cov8" title="1">if err := sdk.ValidateDenom(m.Denom); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "invalid denom %s", m.Denom)
        }</span>
        <span class="cov8" title="1">if m.Decimals &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("decimals cannot be less than zero")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/asset.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Asset struct {
        Id       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" yaml:"name"`
        Denom    string `protobuf:"bytes,3,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
        Decimals int64  `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty" yaml:"decimals"`
}

func (m *Asset) Reset()         <span class="cov0" title="0">{ *m = Asset{} }</span>
func (m *Asset) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Asset) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Asset) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_67277aee9bd3eed4, []int{0}
}</span>
func (m *Asset) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Asset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Asset.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Asset) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Asset.Merge(m, src)
}</span>
func (m *Asset) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Asset) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Asset.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Asset proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Asset)(nil), "comdex.asset.v1beta1.Asset")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/asset.proto", fileDescriptor_67277aee9bd3eed4) }</span>

var fileDescriptor_67277aee9bd3eed4 = []byte{
        // 265 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x3c, 0xd0, 0x31, 0x4e, 0xc3, 0x30,
        0x18, 0x05, 0xe0, 0x38, 0x4d, 0x11, 0x18, 0x44, 0x91, 0xe9, 0x10, 0x31, 0x38, 0x91, 0x91, 0x50,
        0x16, 0x62, 0x55, 0x6c, 0x6c, 0xe4, 0x06, 0x64, 0x64, 0x73, 0x62, 0x37, 0x58, 0x8a, 0xeb, 0x8a,
        0x18, 0x44, 0x6f, 0xc1, 0xc2, 0x1d, 0x38, 0x4a, 0xc7, 0x8e, 0x4c, 0x11, 0x24, 0x37, 0xc8, 0x09,
        0x50, 0xec, 0x96, 0xcd, 0xff, 0x7b, 0xdf, 0xf2, 0x0c, 0xe3, 0x52, 0x2b, 0x2e, 0xde, 0x29, 0x6b,
        0x1a, 0x61, 0xe8, 0xdb, 0xa2, 0x10, 0x86, 0x2d, 0xdc, 0x95, 0xae, 0x5f, 0xb4, 0xd1, 0x68, 0xee,
        0x44, 0xea, 0xb2, 0xbd, 0xb8, 0x9a, 0x57, 0xba, 0xd2, 0x16, 0xd0, 0xf1, 0xe5, 0x2c, 0xf9, 0x04,
        0x70, 0xfa, 0x30, 0x3a, 0x74, 0x0e, 0x7d, 0xc9, 0x43, 0x10, 0x83, 0x24, 0xc8, 0x7d, 0xc9, 0xd1,
        0x35, 0x0c, 0x56, 0x4c, 0x89, 0xd0, 0x8f, 0x41, 0x72, 0x92, 0xcd, 0x86, 0x36, 0x3a, 0xdd, 0x30,
        0x55, 0xdf, 0x93, 0x31, 0x25, 0xb9, 0x2d, 0xd1, 0x0d, 0x9c, 0x72, 0xb1, 0xd2, 0x2a, 0x9c, 0x58,
        0x75, 0x31, 0xb4, 0xd1, 0x99, 0x53, 0x36, 0x26, 0xb9, 0xab, 0x11, 0x85, 0xc7, 0x5c, 0x94, 0x52,
        0xb1, 0xba, 0x09, 0x83, 0x18, 0x24, 0x93, 0xec, 0x72, 0x68, 0xa3, 0xd9, 0x81, 0xba, 0x86, 0xe4,
        0xff, 0x28, 0x7b, 0xdc, 0xfe, 0x62, 0xef, 0xab, 0xc3, 0xde, 0xb6, 0xc3, 0x60, 0xd7, 0x61, 0xf0,
        0xd3, 0x61, 0xf0, 0xd1, 0x63, 0x6f, 0xd7, 0x63, 0xef, 0xbb, 0xc7, 0xde, 0x13, 0xad, 0xa4, 0x79,
        0x7e, 0x2d, 0xd2, 0x52, 0x2b, 0xea, 0x06, 0xdf, 0xea, 0xe5, 0x52, 0x96, 0x92, 0xd5, 0xfb, 0x9b,
        0x1e, 0x3e, 0xc9, 0x6c, 0xd6, 0xa2, 0x29, 0x8e, 0xec, 0xe2, 0xbb, 0xbf, 0x00, 0x00, 0x00, 0xff,
        0xff, 0x7b, 0x4e, 0x23, 0x3e, 0x41, 0x01, 0x00, 0x00,
}

func (m *Asset) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Asset) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Asset) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Decimals != 0 </span><span class="cov0" title="0">{
                i = encodeVarintAsset(dAtA, i, uint64(m.Decimals))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if len(m.Denom) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Denom)
                copy(dAtA[i:], m.Denom)
                i = encodeVarintAsset(dAtA, i, uint64(len(m.Denom)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Name) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintAsset(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintAsset(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintAsset(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovAsset(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Asset) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovAsset(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = len(m.Name)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAsset(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Denom)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovAsset(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Decimals != 0 </span><span class="cov0" title="0">{
                n += 1 + sovAsset(uint64(m.Decimals))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovAsset(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozAsset(x uint64) (n int) <span class="cov0" title="0">{
        return sovAsset(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Asset) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowAsset
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Asset: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Asset: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Denom = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Decimals = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Decimals |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipAsset(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipAsset(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowAsset
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowAsset
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthAsset
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupAsset
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthAsset
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthAsset        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowAsset          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupAsset = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package types

import (
        "github.com/cosmos/cosmos-sdk/codec/types"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
)

func RegisterInterfaces(registry types.InterfaceRegistry) <span class="cov0" title="0">{
        registry.RegisterImplementations(
                (*govtypes.Content)(nil),
                &amp;UpdateAdminProposal{},
        )
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/events.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EventAddPair struct {
        Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *EventAddPair) Reset()         <span class="cov0" title="0">{ *m = EventAddPair{} }</span>
func (m *EventAddPair) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*EventAddPair) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*EventAddPair) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_8698e7aadaab4005, []int{0}
}</span>
func (m *EventAddPair) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *EventAddPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_EventAddPair.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *EventAddPair) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_EventAddPair.Merge(m, src)
}</span>
func (m *EventAddPair) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *EventAddPair) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_EventAddPair.DiscardUnknown(m)
}</span>

var xxx_messageInfo_EventAddPair proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*EventAddPair)(nil), "comdex.asset.v1beta1.EventAddPair")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/events.proto", fileDescriptor_8698e7aadaab4005) }</span>

var fileDescriptor_8698e7aadaab4005 = []byte{
        // 187 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0x4c, 0xce, 0xcf, 0x4d,
        0x49, 0xad, 0xd0, 0x4f, 0x2c, 0x2e, 0x4e, 0x2d, 0xd1, 0x2f, 0x33, 0x4c, 0x4a, 0x2d, 0x49, 0x34,
        0xd4, 0x4f, 0x2d, 0x4b, 0xcd, 0x2b, 0x29, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x81,
        0x28, 0xd1, 0x03, 0x2b, 0xd1, 0x83, 0x2a, 0x91, 0x12, 0x49, 0xcf, 0x4f, 0xcf, 0x07, 0x2b, 0xd0,
        0x07, 0xb1, 0x20, 0x6a, 0x95, 0xe4, 0xb8, 0x78, 0x5c, 0x41, 0x7a, 0x1d, 0x53, 0x52, 0x02, 0x12,
        0x33, 0x8b, 0x84, 0xf8, 0xb8, 0x98, 0x32, 0x53, 0x24, 0x18, 0x15, 0x18, 0x35, 0x58, 0x82, 0x98,
        0x32, 0x53, 0x9c, 0x02, 0x4f, 0x3c, 0x94, 0x63, 0x58, 0xf1, 0x48, 0x8e, 0xe1, 0xc4, 0x23, 0x39,
        0xc6, 0x0b, 0x8f, 0xe4, 0x18, 0x1f, 0x3c, 0x92, 0x63, 0x9c, 0xf0, 0x58, 0x8e, 0xe1, 0xc2, 0x63,
        0x39, 0x86, 0x1b, 0x8f, 0xe5, 0x18, 0xa2, 0xf4, 0xd3, 0x33, 0x4b, 0x32, 0x4a, 0x93, 0xf4, 0x92,
        0xf3, 0x73, 0xf5, 0x21, 0x16, 0xeb, 0xe6, 0xa7, 0xa5, 0x65, 0x26, 0x67, 0x26, 0xe6, 0x40, 0xf9,
        0xfa, 0x30, 0xd7, 0x96, 0x54, 0x16, 0xa4, 0x16, 0x27, 0xb1, 0x81, 0x6d, 0x36, 0x06, 0x04, 0x00,
        0x00, 0xff, 0xff, 0x2e, 0xc4, 0xd5, 0x73, 0xca, 0x00, 0x00, 0x00,
}

func (m *EventAddPair) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *EventAddPair) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *EventAddPair) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintEvents(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovEvents(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *EventAddPair) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovEvents(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovEvents(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozEvents(x uint64) (n int) <span class="cov0" title="0">{
        return sovEvents(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *EventAddPair) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventAddPair: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventAddPair: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipEvents(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipEvents(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupEvents
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthEvents
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file4" style="display: none">package types

func NewGenesisState(assets []Asset, markets []Market, pairs []Pair, params Params) *GenesisState <span class="cov8" title="1">{
        return &amp;GenesisState{
                Assets:  assets,
                Markets: markets,
                Pairs:   pairs,
                Params:  params,
        }
}</span>

func DefaultGenesisState() *GenesisState <span class="cov8" title="1">{
        return NewGenesisState(
                nil,
                nil,
                nil,
                DefaultParams(),
        )
}</span>

func ValidateGenesis(_ *GenesisState) error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/genesis.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GenesisState struct {
        Assets          []Asset  `protobuf:"bytes,1,rep,name=assets,proto3" json:"assets" yaml:"assets"`
        Markets         []Market `protobuf:"bytes,2,rep,name=markets,proto3" json:"markets" yaml:"markets"`
        Pairs           []Pair   `protobuf:"bytes,3,rep,name=pairs,proto3" json:"pairs" yaml:"pairs"`
        Params          Params   `protobuf:"bytes,4,opt,name=params,proto3" json:"params" yaml:"params"`
        ValidateGenesis interface{}
}

func (m *GenesisState) Reset()         <span class="cov0" title="0">{ *m = GenesisState{} }</span>
func (m *GenesisState) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GenesisState) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GenesisState) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_13a69a7476a1f579, []int{0}
}</span>
func (m *GenesisState) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GenesisState) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.Merge(m, src)
}</span>
func (m *GenesisState) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GenesisState) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*GenesisState)(nil), "comdex.asset.v1beta1.GenesisState")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("comdex/asset/v1beta1/genesis.proto", fileDescriptor_13a69a7476a1f579)
}</span>

var fileDescriptor_13a69a7476a1f579 = []byte{
        // 335 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0x31, 0x4e, 0xc3, 0x30,
        0x14, 0x86, 0x93, 0x16, 0x8a, 0x14, 0x0a, 0x43, 0x54, 0x50, 0x55, 0x90, 0x5b, 0x3c, 0xb1, 0x10,
        0xab, 0xb0, 0xb1, 0x91, 0x01, 0x24, 0x10, 0xa8, 0x84, 0x8d, 0xcd, 0x2d, 0x6e, 0xb0, 0x68, 0x70,
        0x64, 0x1b, 0x44, 0x6f, 0xc1, 0x31, 0xb8, 0x05, 0x6b, 0xc7, 0x8e, 0x4c, 0x15, 0x24, 0x37, 0xe0,
        0x04, 0x28, 0x7e, 0xee, 0x82, 0x0c, 0x5b, 0x2c, 0x7d, 0xff, 0xf7, 0xde, 0x9f, 0x17, 0xe0, 0x91,
        0xc8, 0xee, 0xd8, 0x0b, 0xa1, 0x4a, 0x31, 0x4d, 0x9e, 0xfb, 0x43, 0xa6, 0x69, 0x9f, 0xa4, 0xec,
        0x91, 0x29, 0xae, 0xa2, 0x5c, 0x0a, 0x2d, 0xc2, 0x16, 0x30, 0x91, 0x61, 0x22, 0xcb, 0x74, 0x5a,
        0xa9, 0x48, 0x85, 0x01, 0x48, 0xf5, 0x05, 0x6c, 0xa7, 0xe7, 0xf4, 0x41, 0x12, 0x88, 0x3d, 0x27,
        0x21, 0x24, 0x1d, 0x4d, 0x98, 0x45, 0xba, 0x4e, 0x24, 0xa7, 0x5c, 0xfe, 0xeb, 0xc8, 0xa9, 0xa4,
        0x99, 0x5d, 0x1a, 0xbf, 0xd7, 0x82, 0xe6, 0x19, 0xd4, 0xb8, 0xd1, 0x54, 0xb3, 0xf0, 0x3c, 0x68,
        0x18, 0x5c, 0xb5, 0xfd, 0x5e, 0x7d, 0x7f, 0xfd, 0x70, 0x27, 0x72, 0xd5, 0x8a, 0x4e, 0xaa, 0x57,
        0xbc, 0x35, 0x5b, 0x74, 0xbd, 0xef, 0x45, 0x77, 0x63, 0x4a, 0xb3, 0xc9, 0x31, 0x86, 0x20, 0x4e,
        0xac, 0x21, 0xbc, 0x0a, 0xd6, 0x32, 0x2a, 0x1f, 0x2a, 0x59, 0xcd, 0xc8, 0x76, 0xdd, 0xb2, 0x4b,
        0x03, 0xc5, 0xdb, 0xd6, 0xb6, 0x09, 0x36, 0x1b, 0xc5, 0xc9, 0x52, 0x12, 0x9e, 0x06, 0xab, 0x55,
        0x3b, 0xd5, 0xae, 0x1b, 0x5b, 0xc7, 0x6d, 0x1b, 0x50, 0x2e, 0xe3, 0x96, 0x75, 0x35, 0xc1, 0x65,
        0x62, 0x38, 0x81, 0x78, 0x78, 0x11, 0x34, 0xe0, 0x27, 0xb4, 0x57, 0x7a, 0xfe, 0xdf, 0x6b, 0x0d,
        0x0c, 0xf3, 0xbb, 0x24, 0x24, 0x71, 0x62, 0x15, 0xf1, 0xf5, 0xec, 0x0b, 0x79, 0x6f, 0x05, 0xf2,
        0x66, 0x05, 0xf2, 0xe7, 0x05, 0xf2, 0x3f, 0x0b, 0xe4, 0xbf, 0x96, 0xc8, 0x9b, 0x97, 0xc8, 0xfb,
        0x28, 0x91, 0x77, 0x4b, 0x52, 0xae, 0xef, 0x9f, 0x86, 0xd5, 0x10, 0x02, 0x83, 0x0e, 0xc4, 0x78,
        0xcc, 0x47, 0x9c, 0x4e, 0xec, 0x9b, 0x2c, 0x6f, 0xa4, 0xa7, 0x39, 0x53, 0xc3, 0x86, 0xb9, 0xcd,
        0xd1, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc6, 0xb3, 0x95, 0xa4, 0x76, 0x02, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if len(m.Pairs) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Pairs) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Pairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x1a</span>
                }
        }
        <span class="cov0" title="0">if len(m.Markets) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Markets) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Markets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x12</span>
                }
        }
        <span class="cov0" title="0">if len(m.Assets) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Assets) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGenesis(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *GenesisState) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Assets) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Assets </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovGenesis(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if len(m.Markets) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Markets </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovGenesis(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if len(m.Pairs) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Pairs </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovGenesis(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">l = m.Params.Size()
        n += 1 + l + sovGenesis(uint64(l))
        return n</span>
}

func sovGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return sovGenesis(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *GenesisState) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Assets = append(m.Assets, Asset{})
                        if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Markets", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Markets = append(m.Markets, Market{})
                        if err := m.Markets[len(m.Markets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Pairs = append(m.Pairs, Pair{})
                        if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGenesis(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGenesis
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGenesis
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file6" style="display: none">package types

import (
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/errors"
        govtypes "github.com/cosmos/cosmos-sdk/x/gov/types"
)

const (
        ProposalTypeUpdateAdmin = "UpdateAdmin"
)

func init() <span class="cov8" title="1">{
        govtypes.RegisterProposalType(ProposalTypeUpdateAdmin)
        govtypes.RegisterProposalTypeCodec(&amp;UpdateAdminProposal{}, fmt.Sprintf("comdex/asset/%s", ProposalTypeUpdateAdmin))
}</span>

var (
        _ govtypes.Content = (*UpdateAdminProposal)(nil)
)

func (m *UpdateAdminProposal) GetTitle() string       <span class="cov0" title="0">{ return m.Title }</span>
func (m *UpdateAdminProposal) GetDescription() string <span class="cov0" title="0">{ return m.Description }</span>
func (m *UpdateAdminProposal) ProposalRoute() string  <span class="cov0" title="0">{ return RouterKey }</span>
func (m *UpdateAdminProposal) ProposalType() string   <span class="cov0" title="0">{ return ProposalTypeUpdateAdmin }</span>

func (m *UpdateAdminProposal) ValidateBasic() error <span class="cov0" title="0">{
        if err := govtypes.ValidateAbstract(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if m.Address == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("address cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.Address); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "invalid address %s", m.Address)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/gov.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type UpdateAdminProposal struct {
        Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
        Address     string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty" yaml:"address"`
}

func (m *UpdateAdminProposal) Reset()         <span class="cov0" title="0">{ *m = UpdateAdminProposal{} }</span>
func (m *UpdateAdminProposal) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateAdminProposal) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdateAdminProposal) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_31c5aab0360b917f, []int{0}
}</span>
func (m *UpdateAdminProposal) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *UpdateAdminProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_UpdateAdminProposal.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *UpdateAdminProposal) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdateAdminProposal.Merge(m, src)
}</span>
func (m *UpdateAdminProposal) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *UpdateAdminProposal) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdateAdminProposal.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdateAdminProposal proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*UpdateAdminProposal)(nil), "comdex.asset.v1beta1.UpdateAdminProposal")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/gov.proto", fileDescriptor_31c5aab0360b917f) }</span>

var fileDescriptor_31c5aab0360b917f = []byte{
        // 271 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x90, 0xb1, 0x4a, 0xc4, 0x30,
        0x1c, 0x87, 0x1b, 0x45, 0xc5, 0x2a, 0x22, 0xf1, 0x90, 0xe2, 0x90, 0x4a, 0x06, 0x71, 0xd0, 0x86,
        0xc3, 0x45, 0xdc, 0xbc, 0x27, 0xd0, 0x82, 0x8b, 0x5b, 0xda, 0xe4, 0x6a, 0xa0, 0xbd, 0x7f, 0x68,
        0xe2, 0xe1, 0xbd, 0x85, 0x2f, 0x21, 0xf8, 0x28, 0x37, 0xde, 0xe8, 0x54, 0xb4, 0x7d, 0x83, 0x3e,
        0x81, 0x5c, 0xd2, 0x83, 0xdb, 0x92, 0xff, 0xf7, 0xfd, 0x96, 0x2f, 0x24, 0x39, 0x54, 0x42, 0x7e,
        0x30, 0x6e, 0x8c, 0xb4, 0x6c, 0x3e, 0xce, 0xa4, 0xe5, 0x63, 0x56, 0xc0, 0x3c, 0xd1, 0x35, 0x58,
        0xc0, 0x23, 0xcf, 0x13, 0xc7, 0x93, 0x81, 0x5f, 0x8c, 0x0a, 0x28, 0xc0, 0x09, 0x6c, 0xfd, 0xf2,
        0x2e, 0xfd, 0x42, 0xe1, 0xd9, 0x8b, 0x16, 0xdc, 0xca, 0x47, 0x51, 0xa9, 0xd9, 0x53, 0x0d, 0x1a,
        0x0c, 0x2f, 0xf1, 0x55, 0xb8, 0x67, 0x95, 0x2d, 0x65, 0x84, 0x2e, 0xd1, 0xf5, 0xe1, 0xe4, 0xb4,
        0x6f, 0xe2, 0xe3, 0x05, 0xaf, 0xca, 0x07, 0xea, 0xce, 0x34, 0xf5, 0x18, 0xdf, 0x87, 0x47, 0x42,
        0x9a, 0xbc, 0x56, 0xda, 0x2a, 0x98, 0x45, 0x3b, 0xce, 0x3e, 0xef, 0x9b, 0x18, 0x7b, 0x7b, 0x0b,
        0xd2, 0x74, 0x5b, 0xc5, 0x37, 0xe1, 0x01, 0x17, 0xa2, 0x96, 0xc6, 0x44, 0xbb, 0x6e, 0x85, 0xfb,
        0x26, 0x3e, 0xf1, 0xab, 0x01, 0xd0, 0x74, 0xa3, 0x4c, 0x9e, 0x97, 0x7f, 0x24, 0xf8, 0x6e, 0x49,
        0xb0, 0x6c, 0x09, 0x5a, 0xb5, 0x04, 0xfd, 0xb6, 0x04, 0x7d, 0x76, 0x24, 0x58, 0x75, 0x24, 0xf8,
        0xe9, 0x48, 0xf0, 0xca, 0x0a, 0x65, 0xdf, 0xde, 0xb3, 0x24, 0x87, 0x8a, 0xf9, 0x00, 0xb7, 0x30,
        0x9d, 0xaa, 0x5c, 0xf1, 0x72, 0xf8, 0xb3, 0x4d, 0x32, 0xbb, 0xd0, 0xd2, 0x64, 0xfb, 0xae, 0xc0,
        0xdd, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd3, 0x49, 0x03, 0x4a, 0x4f, 0x01, 0x00, 0x00,
}

func (m *UpdateAdminProposal) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *UpdateAdminProposal) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *UpdateAdminProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Address) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Address)
                copy(dAtA[i:], m.Address)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Address)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Description) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Description)
                copy(dAtA[i:], m.Description)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Description)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Title) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Title)
                copy(dAtA[i:], m.Title)
                i = encodeVarintGov(dAtA, i, uint64(len(m.Title)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintGov(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGov(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *UpdateAdminProposal) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Title)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Description)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Address)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovGov(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovGov(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGov(x uint64) (n int) <span class="cov0" title="0">{
        return sovGov(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *UpdateAdminProposal) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGov
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UpdateAdminProposal: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: UpdateAdminProposal: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Title = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Description = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Address = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGov(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGov(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGov
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGov
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGov
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGov
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGov
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGov        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGov          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGov = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file8" style="display: none">package types

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
)

const (
        ModuleName     = "asset"
        ParamsSubspace = ModuleName
        QuerierRoute   = ModuleName
        RouterKey      = ModuleName
        StoreKey       = ModuleName
)

var (
        AssetIDKey    = []byte{0x01}
        CalldataIDKey = []byte{0x02}
        PairIDKey     = []byte{0x03}

        AssetKeyPrefix    = []byte{0x11}
        CalldataKeyPrefix = []byte{0x12}
        MarketKeyPrefix   = []byte{0x13}
        PairKeyPrefix     = []byte{0x14}

        AssetForDenomKeyPrefix  = []byte{0x21}
        MarketForAssetKeyPrefix = []byte{0x22}
        PriceForMarketKeyPrefix = []byte{0x23}
)

func AssetKey(id uint64) []byte <span class="cov8" title="1">{
        return append(AssetKeyPrefix, sdk.Uint64ToBigEndian(id)...)
}</span>

func CalldataKey(id uint64) []byte <span class="cov8" title="1">{
        return append(CalldataKeyPrefix, sdk.Uint64ToBigEndian(id)...)
}</span>

func MarketKey(symbol string) []byte <span class="cov8" title="1">{
        return append(MarketKeyPrefix, []byte(symbol)...)
}</span>

func AssetForDenomKey(denom string) []byte <span class="cov8" title="1">{
        return append(AssetForDenomKeyPrefix, []byte(denom)...)
}</span>

func MarketForAssetKey(id uint64) []byte <span class="cov8" title="1">{
        return append(MarketForAssetKeyPrefix, sdk.Uint64ToBigEndian(id)...)
}</span>

func PairKey(id uint64) []byte <span class="cov8" title="1">{
        return append(PairKeyPrefix, sdk.Uint64ToBigEndian(id)...)
}</span>

func PriceForMarketKey(symbol string) []byte <span class="cov8" title="1">{
        return append(PriceForMarketKeyPrefix, []byte(symbol)...)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package types

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/errors"
        ibcclienttypes "github.com/cosmos/ibc-go/modules/core/02-client/types"
        ibchost "github.com/cosmos/ibc-go/modules/core/24-host"
)

var (
        _ sdk.Msg = (*MsgAddMarketRequest)(nil)
        _ sdk.Msg = (*MsgUpdateMarketRequest)(nil)
        _ sdk.Msg = (*MsgAddAssetRequest)(nil)
        _ sdk.Msg = (*MsgUpdateAssetRequest)(nil)
        _ sdk.Msg = (*MsgAddMarketForAssetRequest)(nil)
        _ sdk.Msg = (*MsgRemoveMarketForAssetRequest)(nil)
        _ sdk.Msg = (*MsgAddPairRequest)(nil)
        _ sdk.Msg = (*MsgUpdatePairRequest)(nil)
        _ sdk.Msg = (*MsgFetchPriceRequest)(nil)
)

func NewMsgAddMarketRequest(from sdk.AccAddress, symbol string, scriptID uint64) *MsgAddMarketRequest <span class="cov8" title="1">{
        return &amp;MsgAddMarketRequest{
                From:     from.String(),
                Symbol:   symbol,
                ScriptID: scriptID,
        }
}</span>

func (m *MsgAddMarketRequest) ValidateBasic() error <span class="cov8" title="1">{
        if m.From == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov8" title="1">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov8" title="1">if m.Symbol == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidSymbol, "symbol cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(m.Symbol) &gt; MaxMarketSymbolLength </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidSymbol, "symbol length cannot be greater than %d", MaxMarketSymbolLength)
        }</span>
        <span class="cov8" title="1">if m.ScriptID == 0 </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidScriptID, "script_id cannot be zero")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *MsgAddMarketRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

func NewMsgUpdateMarketRequest(from sdk.AccAddress, symbol string, scriptID uint64) *MsgUpdateMarketRequest <span class="cov0" title="0">{
        return &amp;MsgUpdateMarketRequest{
                From:     from.String(),
                Symbol:   symbol,
                ScriptID: scriptID,
        }
}</span>

func (m *MsgUpdateMarketRequest) ValidateBasic() error <span class="cov0" title="0">{
        if m.From == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov0" title="0">if m.Symbol != "" </span><span class="cov0" title="0">{
                if len(m.Symbol) &gt; MaxMarketSymbolLength </span><span class="cov0" title="0">{
                        return errors.Wrapf(ErrorInvalidSymbol, "symbol length cannot be greater than %d", MaxMarketSymbolLength)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (m *MsgUpdateMarketRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

func NewMsgAddAssetRequest(from sdk.AccAddress, name, denom string, decimals int64) *MsgAddAssetRequest <span class="cov0" title="0">{
        return &amp;MsgAddAssetRequest{
                From:     from.String(),
                Name:     name,
                Denom:    denom,
                Decimals: decimals,
        }
}</span>

func (m *MsgAddAssetRequest) ValidateBasic() error <span class="cov0" title="0">{
        if m.From == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov0" title="0">if m.Name == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidName, "name cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(m.Name) &gt; MaxAssetNameLength </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidName, "name length cannot be greater than %d", MaxAssetNameLength)
        }</span>
        <span class="cov0" title="0">if m.Denom == "" </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidDenom, "denom cannot be empty")
        }</span>
        <span class="cov0" title="0">if err := sdk.ValidateDenom(m.Denom); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidDenom, "%s", err)
        }</span>
        <span class="cov0" title="0">if m.Decimals &lt; 0 </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidDecimals, "decimals cannot be less than zero")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *MsgAddAssetRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

func NewMsgUpdateAssetRequest(from sdk.AccAddress, id uint64, name, denom string, decimals int64) *MsgUpdateAssetRequest <span class="cov0" title="0">{
        return &amp;MsgUpdateAssetRequest{
                From:     from.String(),
                Id:       id,
                Name:     name,
                Denom:    denom,
                Decimals: decimals,
        }
}</span>

func (m *MsgUpdateAssetRequest) ValidateBasic() error <span class="cov0" title="0">{
        if m.From == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov0" title="0">if m.Name != "" </span><span class="cov0" title="0">{
                if len(m.Name) &gt; MaxAssetNameLength </span><span class="cov0" title="0">{
                        return errors.Wrapf(ErrorInvalidName, "name length cannot be greater than %d", MaxAssetNameLength)
                }</span>
        }
        <span class="cov0" title="0">if m.Denom != "" </span><span class="cov0" title="0">{
                if err := sdk.ValidateDenom(m.Denom); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(ErrorInvalidDenom, "%s", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (m *MsgUpdateAssetRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

func NewMsgAddMarketForAssetRequest(from sdk.AccAddress, id uint64, symbol string) *MsgAddMarketForAssetRequest <span class="cov0" title="0">{
        return &amp;MsgAddMarketForAssetRequest{
                From:   from.String(),
                Id:     id,
                Symbol: symbol,
        }
}</span>

func (m *MsgAddMarketForAssetRequest) ValidateBasic() error <span class="cov0" title="0">{
        if m.From == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov0" title="0">if m.Id == 0 </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidID, "id cannot be zero")
        }</span>
        <span class="cov0" title="0">if m.Symbol == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidSymbol, "symbol cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(m.Symbol) &gt; MaxMarketSymbolLength </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidSymbol, "symbol length cannot be greater than %d", MaxMarketSymbolLength)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *MsgAddMarketForAssetRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

func NewMsgRemoveMarketForAssetRequest(from sdk.AccAddress, id uint64, symbol string) *MsgRemoveMarketForAssetRequest <span class="cov0" title="0">{
        return &amp;MsgRemoveMarketForAssetRequest{
                From:   from.String(),
                Id:     id,
                Symbol: symbol,
        }
}</span>

func (m *MsgRemoveMarketForAssetRequest) ValidateBasic() error <span class="cov0" title="0">{
        if m.From == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov0" title="0">if m.Id == 0 </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidID, "id cannot be zero")
        }</span>
        <span class="cov0" title="0">if m.Symbol == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidSymbol, "symbol cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(m.Symbol) &gt; MaxMarketSymbolLength </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidSymbol, "symbol length cannot be greater than %d", MaxMarketSymbolLength)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *MsgRemoveMarketForAssetRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

func NewMsgAddPairRequest(from sdk.AccAddress, assetIn, assetOut uint64, liquidationRatio sdk.Dec) *MsgAddPairRequest <span class="cov0" title="0">{
        return &amp;MsgAddPairRequest{
                From:             from.String(),
                AssetIn:          assetIn,
                AssetOut:         assetOut,
                LiquidationRatio: liquidationRatio,
        }
}</span>

func (m *MsgAddPairRequest) ValidateBasic() error <span class="cov0" title="0">{
        if m.From == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov0" title="0">if m.AssetIn == 0 </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidID, "asset_in cannot be zero")
        }</span>
        <span class="cov0" title="0">if m.AssetOut == 0 </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidID, "asset_out cannot be zero")
        }</span>
        <span class="cov0" title="0">if m.LiquidationRatio.IsNil() </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidLiquidationRatio, "liquidation_ratio cannot be nil")
        }</span>
        <span class="cov0" title="0">if m.LiquidationRatio.IsNegative() </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidLiquidationRatio, "liquidation_ratio cannot be negative")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *MsgAddPairRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

func NewMsgUpdatePairRequest(from sdk.AccAddress, id uint64, liquidationRatio sdk.Dec) *MsgUpdatePairRequest <span class="cov0" title="0">{
        return &amp;MsgUpdatePairRequest{
                From:             from.String(),
                Id:               id,
                LiquidationRatio: liquidationRatio,
        }
}</span>

func (m *MsgUpdatePairRequest) ValidateBasic() error <span class="cov0" title="0">{
        if m.From == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov0" title="0">if !m.LiquidationRatio.IsNil() </span><span class="cov0" title="0">{
                if m.LiquidationRatio.IsNegative() </span><span class="cov0" title="0">{
                        return errors.Wrap(ErrorInvalidLiquidationRatio, "liquidation_ratio cannot be negative")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (m *MsgUpdatePairRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

func NewMsgFetchPriceRequest(
        from sdk.AccAddress,
        sourcePort, sourceChannel string,
        timeoutHeight ibcclienttypes.Height,
        timeoutTimestamp uint64,
        symbols []string,
        scriptID uint64,
        feeLimit sdk.Coins,
        prepareGas, executeGas uint64,
) *MsgFetchPriceRequest <span class="cov0" title="0">{
        return &amp;MsgFetchPriceRequest{
                From:             from.String(),
                SourcePort:       sourcePort,
                SourceChannel:    sourceChannel,
                TimeoutHeight:    timeoutHeight,
                TimeoutTimestamp: timeoutTimestamp,
                Symbols:          symbols,
                ScriptID:         scriptID,
                FeeLimit:         feeLimit,
                PrepareGas:       prepareGas,
                ExecuteGas:       executeGas,
        }
}</span>

func (m *MsgFetchPriceRequest) ValidateBasic() error <span class="cov0" title="0">{
        if m.From == "" </span><span class="cov0" title="0">{
                return errors.Wrap(ErrorInvalidFrom, "from cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.From); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidFrom, "%s", err)
        }</span>
        <span class="cov0" title="0">if err := ibchost.PortIdentifierValidator(m.SourcePort); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidSourcePort, "%s", err)
        }</span>
        <span class="cov0" title="0">if err := ibchost.ChannelIdentifierValidator(m.SourceChannel); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidSourceChannel, "%s", err)
        }</span>
        <span class="cov0" title="0">if m.Symbols == nil </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidSymbols, "symbols cannot be nil")
        }</span>
        <span class="cov0" title="0">if len(m.Symbols) == 0 </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidSymbols, "symbols cannot be empty")
        }</span>
        <span class="cov0" title="0">if m.ScriptID == 0 </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidScriptID, "script_id cannot be zero")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *MsgFetchPriceRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(m.From)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/msg.proto

package types

import (
        context "context"
        fmt "fmt"
        github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
        types1 "github.com/cosmos/cosmos-sdk/types"
        types "github.com/cosmos/ibc-go/modules/core/02-client/types"
        _ "github.com/gogo/protobuf/gogoproto"
        grpc1 "github.com/gogo/protobuf/grpc"
        proto "github.com/gogo/protobuf/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgAddMarketRequest struct {
        From     string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        Symbol   string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty" yaml:"symbol"`
        ScriptID uint64 `protobuf:"varint,3,opt,name=script_id,json=scriptId,proto3" json:"script_id,omitempty" yaml:"script_id"`
}

func (m *MsgAddMarketRequest) Error() string <span class="cov0" title="0">{
        panic("implement me")</span>
}

func (m *MsgAddMarketRequest) Reset()         <span class="cov0" title="0">{ *m = MsgAddMarketRequest{} }</span>
func (m *MsgAddMarketRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddMarketRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddMarketRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{0}
}</span>
func (m *MsgAddMarketRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddMarketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddMarketRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddMarketRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddMarketRequest.Merge(m, src)
}</span>
func (m *MsgAddMarketRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddMarketRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddMarketRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddMarketRequest proto.InternalMessageInfo

type MsgAddMarketResponse struct {
}

func (m *MsgAddMarketResponse) Reset()         <span class="cov0" title="0">{ *m = MsgAddMarketResponse{} }</span>
func (m *MsgAddMarketResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddMarketResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddMarketResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{1}
}</span>
func (m *MsgAddMarketResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddMarketResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddMarketResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddMarketResponse.Merge(m, src)
}</span>
func (m *MsgAddMarketResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddMarketResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddMarketResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddMarketResponse proto.InternalMessageInfo

type MsgUpdateMarketRequest struct {
        From     string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        Symbol   string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty" yaml:"symbol"`
        ScriptID uint64 `protobuf:"varint,3,opt,name=script_id,json=scriptId,proto3" json:"script_id,omitempty" yaml:"script_id"`
}

func (m *MsgUpdateMarketRequest) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateMarketRequest{} }</span>
func (m *MsgUpdateMarketRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateMarketRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateMarketRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{2}
}</span>
func (m *MsgUpdateMarketRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateMarketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateMarketRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateMarketRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateMarketRequest.Merge(m, src)
}</span>
func (m *MsgUpdateMarketRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateMarketRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateMarketRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateMarketRequest proto.InternalMessageInfo

type MsgUpdateMarketResponse struct {
}

func (m *MsgUpdateMarketResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateMarketResponse{} }</span>
func (m *MsgUpdateMarketResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateMarketResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateMarketResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{3}
}</span>
func (m *MsgUpdateMarketResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateMarketResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateMarketResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateMarketResponse.Merge(m, src)
}</span>
func (m *MsgUpdateMarketResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateMarketResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateMarketResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateMarketResponse proto.InternalMessageInfo

type MsgAddAssetRequest struct {
        From     string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        Name     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" yaml:"name"`
        Denom    string `protobuf:"bytes,3,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
        Decimals int64  `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty" yaml:"decimals"`
}

func (m *MsgAddAssetRequest) Reset()         <span class="cov0" title="0">{ *m = MsgAddAssetRequest{} }</span>
func (m *MsgAddAssetRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddAssetRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddAssetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{4}
}</span>
func (m *MsgAddAssetRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddAssetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddAssetRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddAssetRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddAssetRequest.Merge(m, src)
}</span>
func (m *MsgAddAssetRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddAssetRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddAssetRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddAssetRequest proto.InternalMessageInfo

type MsgAddAssetResponse struct {
}

func (m *MsgAddAssetResponse) Reset()         <span class="cov0" title="0">{ *m = MsgAddAssetResponse{} }</span>
func (m *MsgAddAssetResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddAssetResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddAssetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{5}
}</span>
func (m *MsgAddAssetResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddAssetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddAssetResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddAssetResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddAssetResponse.Merge(m, src)
}</span>
func (m *MsgAddAssetResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddAssetResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddAssetResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddAssetResponse proto.InternalMessageInfo

type MsgUpdateAssetRequest struct {
        From     string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        Id       uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
        Name     string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" yaml:"name"`
        Denom    string `protobuf:"bytes,4,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
        Decimals int64  `protobuf:"varint,5,opt,name=decimals,proto3" json:"decimals,omitempty" yaml:"decimals"`
}

func (m *MsgUpdateAssetRequest) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateAssetRequest{} }</span>
func (m *MsgUpdateAssetRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateAssetRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateAssetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{6}
}</span>
func (m *MsgUpdateAssetRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateAssetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateAssetRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateAssetRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateAssetRequest.Merge(m, src)
}</span>
func (m *MsgUpdateAssetRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateAssetRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateAssetRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateAssetRequest proto.InternalMessageInfo

type MsgUpdateAssetResponse struct {
}

func (m *MsgUpdateAssetResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUpdateAssetResponse{} }</span>
func (m *MsgUpdateAssetResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdateAssetResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdateAssetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{7}
}</span>
func (m *MsgUpdateAssetResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdateAssetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdateAssetResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdateAssetResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateAssetResponse.Merge(m, src)
}</span>
func (m *MsgUpdateAssetResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdateAssetResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdateAssetResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdateAssetResponse proto.InternalMessageInfo

type MsgAddMarketForAssetRequest struct {
        From   string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        Id     uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
        Symbol string `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty" yaml:"symbol"`
}

func (m *MsgAddMarketForAssetRequest) Reset()         <span class="cov0" title="0">{ *m = MsgAddMarketForAssetRequest{} }</span>
func (m *MsgAddMarketForAssetRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddMarketForAssetRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddMarketForAssetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{8}
}</span>
func (m *MsgAddMarketForAssetRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddMarketForAssetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddMarketForAssetRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddMarketForAssetRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddMarketForAssetRequest.Merge(m, src)
}</span>
func (m *MsgAddMarketForAssetRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddMarketForAssetRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddMarketForAssetRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddMarketForAssetRequest proto.InternalMessageInfo

type MsgAddMarketForAssetResponse struct {
}

func (m *MsgAddMarketForAssetResponse) Reset()         <span class="cov0" title="0">{ *m = MsgAddMarketForAssetResponse{} }</span>
func (m *MsgAddMarketForAssetResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddMarketForAssetResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddMarketForAssetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{9}
}</span>
func (m *MsgAddMarketForAssetResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddMarketForAssetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddMarketForAssetResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddMarketForAssetResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddMarketForAssetResponse.Merge(m, src)
}</span>
func (m *MsgAddMarketForAssetResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddMarketForAssetResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddMarketForAssetResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddMarketForAssetResponse proto.InternalMessageInfo

type MsgRemoveMarketForAssetRequest struct {
        From   string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        Id     uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
        Symbol string `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty" yaml:"symbol"`
}

func (m *MsgRemoveMarketForAssetRequest) Reset()         <span class="cov0" title="0">{ *m = MsgRemoveMarketForAssetRequest{} }</span>
func (m *MsgRemoveMarketForAssetRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRemoveMarketForAssetRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRemoveMarketForAssetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{10}
}</span>
func (m *MsgRemoveMarketForAssetRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRemoveMarketForAssetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRemoveMarketForAssetRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRemoveMarketForAssetRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRemoveMarketForAssetRequest.Merge(m, src)
}</span>
func (m *MsgRemoveMarketForAssetRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRemoveMarketForAssetRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRemoveMarketForAssetRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRemoveMarketForAssetRequest proto.InternalMessageInfo

type MsgRemoveMarketForAssetResponse struct {
}

func (m *MsgRemoveMarketForAssetResponse) Reset()         <span class="cov0" title="0">{ *m = MsgRemoveMarketForAssetResponse{} }</span>
func (m *MsgRemoveMarketForAssetResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRemoveMarketForAssetResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRemoveMarketForAssetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{11}
}</span>
func (m *MsgRemoveMarketForAssetResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRemoveMarketForAssetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRemoveMarketForAssetResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRemoveMarketForAssetResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRemoveMarketForAssetResponse.Merge(m, src)
}</span>
func (m *MsgRemoveMarketForAssetResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRemoveMarketForAssetResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRemoveMarketForAssetResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRemoveMarketForAssetResponse proto.InternalMessageInfo

type MsgAddPairRequest struct {
        From             string                                 `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        AssetIn          uint64                                 `protobuf:"varint,2,opt,name=asset_in,json=assetIn,proto3" json:"asset_in,omitempty" yaml:"asset_in"`
        AssetOut         uint64                                 `protobuf:"varint,3,opt,name=asset_out,json=assetOut,proto3" json:"asset_out,omitempty" yaml:"asset_out"`
        LiquidationRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=liquidation_ratio,json=liquidationRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_ratio" yaml:"liquidation_ratio"`
}

func (m *MsgAddPairRequest) Reset()         <span class="cov0" title="0">{ *m = MsgAddPairRequest{} }</span>
func (m *MsgAddPairRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddPairRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddPairRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{12}
}</span>
func (m *MsgAddPairRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddPairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddPairRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddPairRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddPairRequest.Merge(m, src)
}</span>
func (m *MsgAddPairRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddPairRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddPairRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddPairRequest proto.InternalMessageInfo

type MsgAddPairResponse struct {
}

func (m *MsgAddPairResponse) Reset()         <span class="cov0" title="0">{ *m = MsgAddPairResponse{} }</span>
func (m *MsgAddPairResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgAddPairResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgAddPairResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{13}
}</span>
func (m *MsgAddPairResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgAddPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgAddPairResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgAddPairResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddPairResponse.Merge(m, src)
}</span>
func (m *MsgAddPairResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgAddPairResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgAddPairResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgAddPairResponse proto.InternalMessageInfo

type MsgUpdatePairRequest struct {
        From             string                                 `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        Id               uint64                                 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
        LiquidationRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=liquidation_ratio,json=liquidationRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_ratio" yaml:"liquidation_ratio"`
}

func (m *MsgUpdatePairRequest) Reset()         <span class="cov0" title="0">{ *m = MsgUpdatePairRequest{} }</span>
func (m *MsgUpdatePairRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdatePairRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdatePairRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{14}
}</span>
func (m *MsgUpdatePairRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdatePairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdatePairRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdatePairRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdatePairRequest.Merge(m, src)
}</span>
func (m *MsgUpdatePairRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdatePairRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdatePairRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdatePairRequest proto.InternalMessageInfo

type MsgUpdatePairResponse struct {
}

func (m *MsgUpdatePairResponse) Reset()         <span class="cov0" title="0">{ *m = MsgUpdatePairResponse{} }</span>
func (m *MsgUpdatePairResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgUpdatePairResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgUpdatePairResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{15}
}</span>
func (m *MsgUpdatePairResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgUpdatePairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgUpdatePairResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgUpdatePairResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdatePairResponse.Merge(m, src)
}</span>
func (m *MsgUpdatePairResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgUpdatePairResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgUpdatePairResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgUpdatePairResponse proto.InternalMessageInfo

type MsgFetchPriceRequest struct {
        From             string                                   `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty" yaml:"from"`
        SourcePort       string                                   `protobuf:"bytes,2,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty" yaml:"source_port"`
        SourceChannel    string                                   `protobuf:"bytes,3,opt,name=source_channel,json=sourceChannel,proto3" json:"source_channel,omitempty" yaml:"source_channel"`
        TimeoutHeight    types.Height                             `protobuf:"bytes,4,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height" yaml:"timeout_height"`
        TimeoutTimestamp uint64                                   `protobuf:"varint,5,opt,name=timeout_timestamp,json=timeoutTimestamp,proto3" json:"timeout_timestamp,omitempty" yaml:"timeout_timestamp"`
        Symbols          []string                                 `protobuf:"bytes,6,rep,name=symbols,proto3" json:"symbols,omitempty" yaml:"symbols"`
        ScriptID         uint64                                   `protobuf:"varint,7,opt,name=script_id,json=scriptId,proto3" json:"script_id,omitempty" yaml:"script_id"`
        FeeLimit         github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,8,rep,name=fee_limit,json=feeLimit,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee_limit" yaml:"fee_limit"`
        PrepareGas       uint64                                   `protobuf:"varint,9,opt,name=prepare_gas,json=prepareGas,proto3" json:"prepare_gas,omitempty" yaml:"prepare_gas"`
        ExecuteGas       uint64                                   `protobuf:"varint,10,opt,name=execute_gas,json=executeGas,proto3" json:"execute_gas,omitempty" yaml:"execute_gas"`
}

func (m *MsgFetchPriceRequest) Reset()         <span class="cov0" title="0">{ *m = MsgFetchPriceRequest{} }</span>
func (m *MsgFetchPriceRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgFetchPriceRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgFetchPriceRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{16}
}</span>
func (m *MsgFetchPriceRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgFetchPriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgFetchPriceRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgFetchPriceRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgFetchPriceRequest.Merge(m, src)
}</span>
func (m *MsgFetchPriceRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgFetchPriceRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgFetchPriceRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgFetchPriceRequest proto.InternalMessageInfo

type MsgFetchPriceResponse struct {
}

func (m *MsgFetchPriceResponse) Reset()         <span class="cov0" title="0">{ *m = MsgFetchPriceResponse{} }</span>
func (m *MsgFetchPriceResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgFetchPriceResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgFetchPriceResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_71dc8806a9f74763, []int{17}
}</span>
func (m *MsgFetchPriceResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgFetchPriceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgFetchPriceResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgFetchPriceResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgFetchPriceResponse.Merge(m, src)
}</span>
func (m *MsgFetchPriceResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgFetchPriceResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgFetchPriceResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgFetchPriceResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MsgAddMarketRequest)(nil), "comdex.asset.v1beta1.MsgAddMarketRequest")
        proto.RegisterType((*MsgAddMarketResponse)(nil), "comdex.asset.v1beta1.MsgAddMarketResponse")
        proto.RegisterType((*MsgUpdateMarketRequest)(nil), "comdex.asset.v1beta1.MsgUpdateMarketRequest")
        proto.RegisterType((*MsgUpdateMarketResponse)(nil), "comdex.asset.v1beta1.MsgUpdateMarketResponse")
        proto.RegisterType((*MsgAddAssetRequest)(nil), "comdex.asset.v1beta1.MsgAddAssetRequest")
        proto.RegisterType((*MsgAddAssetResponse)(nil), "comdex.asset.v1beta1.MsgAddAssetResponse")
        proto.RegisterType((*MsgUpdateAssetRequest)(nil), "comdex.asset.v1beta1.MsgUpdateAssetRequest")
        proto.RegisterType((*MsgUpdateAssetResponse)(nil), "comdex.asset.v1beta1.MsgUpdateAssetResponse")
        proto.RegisterType((*MsgAddMarketForAssetRequest)(nil), "comdex.asset.v1beta1.MsgAddMarketForAssetRequest")
        proto.RegisterType((*MsgAddMarketForAssetResponse)(nil), "comdex.asset.v1beta1.MsgAddMarketForAssetResponse")
        proto.RegisterType((*MsgRemoveMarketForAssetRequest)(nil), "comdex.asset.v1beta1.MsgRemoveMarketForAssetRequest")
        proto.RegisterType((*MsgRemoveMarketForAssetResponse)(nil), "comdex.asset.v1beta1.MsgRemoveMarketForAssetResponse")
        proto.RegisterType((*MsgAddPairRequest)(nil), "comdex.asset.v1beta1.MsgAddPairRequest")
        proto.RegisterType((*MsgAddPairResponse)(nil), "comdex.asset.v1beta1.MsgAddPairResponse")
        proto.RegisterType((*MsgUpdatePairRequest)(nil), "comdex.asset.v1beta1.MsgUpdatePairRequest")
        proto.RegisterType((*MsgUpdatePairResponse)(nil), "comdex.asset.v1beta1.MsgUpdatePairResponse")
        proto.RegisterType((*MsgFetchPriceRequest)(nil), "comdex.asset.v1beta1.MsgFetchPriceRequest")
        proto.RegisterType((*MsgFetchPriceResponse)(nil), "comdex.asset.v1beta1.MsgFetchPriceResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/msg.proto", fileDescriptor_71dc8806a9f74763) }</span>

var fileDescriptor_71dc8806a9f74763 = []byte{
        // 1139 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcf, 0x6f, 0xe3, 0xc4,
        0x17, 0x8f, 0x9b, 0x6c, 0x9b, 0x4c, 0xb7, 0xbf, 0x66, 0xdb, 0x6e, 0x9a, 0xef, 0x7e, 0xed, 0x30,
        0x2b, 0x2d, 0xe9, 0x6e, 0x6b, 0xab, 0x05, 0x84, 0x84, 0x84, 0xc4, 0x66, 0xab, 0x5d, 0x8a, 0xa8,
        0x28, 0x5e, 0xb8, 0x70, 0x09, 0x8e, 0x3d, 0x4d, 0x46, 0x8d, 0x3d, 0x59, 0xcf, 0xa4, 0x6c, 0x25,
        0x56, 0xe2, 0xc4, 0x99, 0x03, 0x7f, 0x02, 0x12, 0x88, 0x7f, 0x80, 0x2b, 0x07, 0x0e, 0x15, 0xa7,
        0x3d, 0x22, 0x0e, 0x06, 0xda, 0xbf, 0x80, 0xfc, 0x05, 0xc8, 0x33, 0xe3, 0xc4, 0x6e, 0xd3, 0x36,
        0x11, 0x12, 0x70, 0xf2, 0xcc, 0x7b, 0x9f, 0x37, 0xef, 0x7d, 0x66, 0xde, 0xbc, 0x37, 0x06, 0xba,
        0x4b, 0x7d, 0x0f, 0x3f, 0xb7, 0x1c, 0xc6, 0x30, 0xb7, 0x8e, 0xb6, 0x9a, 0x98, 0x3b, 0x5b, 0x96,
        0xcf, 0x5a, 0x66, 0x37, 0xa4, 0x9c, 0xc2, 0x65, 0xa9, 0x37, 0x85, 0xde, 0x54, 0xfa, 0x8a, 0xee,
        0x52, 0xe6, 0x53, 0x66, 0x35, 0x1d, 0x86, 0x07, 0x46, 0x2e, 0x25, 0x81, 0xb4, 0xaa, 0x2c, 0xb7,
        0x68, 0x8b, 0x8a, 0xa1, 0x15, 0x8f, 0x94, 0xd4, 0x20, 0x4d, 0xd7, 0x72, 0x69, 0x88, 0x2d, 0xb7,
        0x43, 0x70, 0x10, 0xbb, 0x53, 0x23, 0x09, 0x40, 0xdf, 0x68, 0xe0, 0xd6, 0x1e, 0x6b, 0x3d, 0xf4,
        0xbc, 0x3d, 0x27, 0x3c, 0xc4, 0xdc, 0xc6, 0xcf, 0x7a, 0x98, 0x71, 0x78, 0x17, 0x14, 0x0e, 0x42,
        0xea, 0x97, 0xb5, 0xaa, 0x56, 0x2b, 0xd5, 0x17, 0xfa, 0x91, 0x31, 0x7b, 0xec, 0xf8, 0x9d, 0xb7,
        0x50, 0x2c, 0x45, 0xb6, 0x50, 0xc2, 0x75, 0x30, 0xcd, 0x8e, 0xfd, 0x26, 0xed, 0x94, 0xa7, 0x04,
        0x6c, 0xa9, 0x1f, 0x19, 0x73, 0x12, 0x26, 0xe5, 0xc8, 0x56, 0x00, 0xf8, 0x36, 0x28, 0x31, 0x37,
        0x24, 0x5d, 0xde, 0x20, 0x5e, 0x39, 0x5f, 0xd5, 0x6a, 0x85, 0x7a, 0xf5, 0x34, 0x32, 0x8a, 0x4f,
        0x85, 0x70, 0x77, 0xa7, 0x1f, 0x19, 0x8b, 0xca, 0x32, 0x81, 0x21, 0xbb, 0x28, 0xc7, 0xbb, 0x1e,
        0x5a, 0x05, 0xcb, 0xd9, 0x28, 0x59, 0x97, 0x06, 0x0c, 0xa3, 0x6f, 0x35, 0xb0, 0xba, 0xc7, 0x5a,
        0x1f, 0x77, 0x3d, 0x87, 0xe3, 0xff, 0x34, 0x83, 0x35, 0x70, 0xfb, 0x42, 0xa0, 0x8a, 0xc4, 0x0f,
        0x1a, 0x80, 0x92, 0xdd, 0xc3, 0xf8, 0xc8, 0x27, 0x22, 0x70, 0x17, 0x14, 0x02, 0xc7, 0xc7, 0x2a,
        0xfc, 0x14, 0x28, 0x96, 0x22, 0x5b, 0x28, 0xe1, 0x3d, 0x70, 0xc3, 0xc3, 0x01, 0xf5, 0x45, 0xd8,
        0xa5, 0xfa, 0x62, 0x3f, 0x32, 0x6e, 0x4a, 0x94, 0x10, 0x23, 0x5b, 0xaa, 0xa1, 0x05, 0x8a, 0x1e,
        0x76, 0x89, 0xef, 0x74, 0x58, 0xb9, 0x50, 0xd5, 0x6a, 0xf9, 0xfa, 0xad, 0x7e, 0x64, 0x2c, 0x24,
        0x50, 0xa9, 0x41, 0xf6, 0x00, 0x84, 0x56, 0x92, 0xe4, 0x51, 0x81, 0x2b, 0x42, 0x3f, 0x6b, 0x60,
        0x65, 0x40, 0x76, 0x72, 0x4e, 0xf3, 0x60, 0x8a, 0x78, 0x82, 0x51, 0xc1, 0x9e, 0x22, 0xde, 0x80,
        0x63, 0x7e, 0x2c, 0x8e, 0x85, 0xf1, 0x39, 0xde, 0x18, 0x87, 0x63, 0x39, 0x95, 0x61, 0x59, 0x9a,
        0x2f, 0xc0, 0xff, 0xd2, 0x49, 0xf9, 0x98, 0x86, 0x7f, 0x9f, 0xeb, 0x30, 0x21, 0xf3, 0xd7, 0x24,
        0x24, 0xd2, 0xc1, 0x9d, 0xd1, 0xee, 0x55, 0x78, 0x5f, 0x68, 0x40, 0xdf, 0x63, 0x2d, 0x1b, 0xfb,
        0xf4, 0x08, 0xff, 0x3b, 0x21, 0xbe, 0x02, 0x8c, 0x4b, 0x23, 0x50, 0x51, 0x7e, 0x3d, 0x05, 0x96,
        0x24, 0x8d, 0x7d, 0x87, 0x84, 0x13, 0x05, 0x66, 0x82, 0xa2, 0xa8, 0x91, 0x0d, 0x12, 0xc8, 0xf0,
        0xd2, 0x47, 0x99, 0x68, 0x90, 0x3d, 0x23, 0x86, 0xbb, 0x01, 0xdc, 0x02, 0x25, 0x29, 0xa5, 0x3d,
        0xae, 0x6e, 0xf0, 0xf2, 0xf0, 0xd6, 0x0e, 0x54, 0xc8, 0x96, 0xcb, 0x7e, 0xd0, 0xe3, 0xf0, 0x33,
        0xb0, 0xd4, 0x21, 0xcf, 0x7a, 0xc4, 0x73, 0x38, 0xa1, 0x41, 0x23, 0x8c, 0x3f, 0x2a, 0xc3, 0xde,
        0x3b, 0x89, 0x8c, 0xdc, 0xaf, 0x91, 0x71, 0xaf, 0x45, 0x78, 0xbb, 0xd7, 0x34, 0x5d, 0xea, 0x5b,
        0xaa, 0x46, 0xcb, 0xcf, 0x26, 0xf3, 0x0e, 0x2d, 0x7e, 0xdc, 0xc5, 0xcc, 0xdc, 0xc1, 0x6e, 0x3f,
        0x32, 0xca, 0xd2, 0xd1, 0x85, 0x05, 0x91, 0xbd, 0x98, 0x92, 0xd9, 0x42, 0xb4, 0x9c, 0x94, 0x04,
        0xb9, 0x2b, 0x6a, 0xb3, 0x7e, 0xd2, 0x44, 0x1d, 0x94, 0xc9, 0x38, 0xf1, 0x7e, 0x9d, 0x3f, 0xc8,
        0x91, 0xe4, 0xf2, 0xff, 0x00, 0xb9, 0xdb, 0xa9, 0xf2, 0x90, 0xe1, 0xf7, 0xe3, 0x0d, 0xc1, 0xef,
        0x31, 0xe6, 0x6e, 0x7b, 0x3f, 0x24, 0x2e, 0x9e, 0x88, 0xdf, 0x9b, 0x60, 0x96, 0xd1, 0x5e, 0xe8,
        0xe2, 0x46, 0x97, 0x86, 0x5c, 0x95, 0xc4, 0xd5, 0x7e, 0x64, 0x40, 0x95, 0x9d, 0x43, 0x25, 0xb2,
        0x81, 0x9c, 0xed, 0xd3, 0x90, 0xc3, 0x77, 0xc0, 0xbc, 0xd2, 0xb9, 0x6d, 0x27, 0x08, 0x70, 0x92,
        0xd9, 0x6b, 0xfd, 0xc8, 0x58, 0xc9, 0xd8, 0x2a, 0x3d, 0xb2, 0xe7, 0xa4, 0xe0, 0x91, 0x9c, 0xc3,
        0x4f, 0xc1, 0x3c, 0x27, 0x3e, 0xa6, 0x3d, 0xde, 0x68, 0x63, 0xd2, 0x6a, 0x73, 0x91, 0x24, 0xb3,
        0xdb, 0x15, 0x93, 0x34, 0x5d, 0x33, 0x6e, 0xc0, 0xa6, 0x6a, 0xbb, 0x47, 0x5b, 0xe6, 0xbb, 0x02,
        0x51, 0xff, 0x7f, 0xbc, 0xc7, 0x43, 0x0f, 0x59, 0x7b, 0x64, 0xcf, 0x29, 0x81, 0x44, 0xc3, 0x5d,
        0xb0, 0x94, 0x20, 0xe2, 0x2f, 0xe3, 0x8e, 0xdf, 0x15, 0x05, 0xac, 0x50, 0xbf, 0x33, 0xdc, 0xfe,
        0x0b, 0x10, 0x64, 0x2f, 0x2a, 0xd9, 0x47, 0x89, 0x08, 0x6e, 0x80, 0x19, 0x79, 0x3f, 0x59, 0x79,
        0xba, 0x9a, 0xaf, 0x95, 0xea, 0xb0, 0x1f, 0x19, 0xf3, 0xe9, 0x1b, 0xcc, 0x90, 0x9d, 0x40, 0xb2,
        0x7d, 0x6f, 0x66, 0xd2, 0xbe, 0x07, 0x3f, 0x07, 0xa5, 0x03, 0x8c, 0x1b, 0x1d, 0xe2, 0x13, 0x5e,
        0x2e, 0x56, 0xf3, 0xb5, 0xd9, 0xed, 0x35, 0x53, 0xe6, 0x90, 0x19, 0xbf, 0x65, 0x92, 0x07, 0x8e,
        0xf9, 0x88, 0x92, 0xa0, 0xbe, 0xa3, 0xf6, 0x44, 0xad, 0x38, 0xb0, 0x44, 0xdf, 0xff, 0x66, 0xd4,
        0xc6, 0xc8, 0xc5, 0x78, 0x11, 0x66, 0x17, 0x0f, 0x30, 0x7e, 0x3f, 0x36, 0x8b, 0x53, 0xa2, 0x1b,
        0xe2, 0xae, 0x13, 0xe2, 0x46, 0xcb, 0x61, 0xe5, 0x92, 0x08, 0x3f, 0x95, 0x12, 0x29, 0x25, 0xb2,
        0x81, 0x9a, 0x3d, 0x71, 0x58, 0x6c, 0x88, 0x9f, 0x63, 0xb7, 0xc7, 0xa5, 0x21, 0x38, 0x6f, 0x98,
        0x52, 0x22, 0x1b, 0xa8, 0xd9, 0x13, 0x87, 0xa9, 0xdc, 0x4e, 0x67, 0xb0, 0xcc, 0xed, 0xed, 0x3f,
        0x67, 0x00, 0xd8, 0x63, 0xad, 0xa7, 0x38, 0x3c, 0x22, 0x2e, 0x86, 0x18, 0xdc, 0x4c, 0x57, 0x6f,
        0xb8, 0x6e, 0x8e, 0x7a, 0xf6, 0x99, 0x23, 0xde, 0x66, 0x95, 0xfb, 0xe3, 0x40, 0xa5, 0x57, 0x18,
        0x80, 0x85, 0x73, 0xcf, 0x0e, 0xb8, 0x71, 0xa9, 0xf9, 0x88, 0x67, 0x54, 0x65, 0x73, 0x4c, 0xb4,
        0xf2, 0xd7, 0x04, 0xb3, 0xa9, 0x17, 0x01, 0xac, 0x5d, 0x15, 0x6a, 0xba, 0x15, 0x55, 0xd6, 0xc7,
        0x40, 0x2a, 0x1f, 0x87, 0x60, 0x3e, 0xdb, 0x91, 0xe1, 0x83, 0x6b, 0x82, 0xcc, 0x78, 0xda, 0x18,
        0x0f, 0xac, 0x9c, 0xbd, 0xc8, 0xbe, 0x3c, 0x93, 0xfe, 0x05, 0xb7, 0xae, 0x3f, 0x84, 0x73, 0xdd,
        0xb6, 0xb2, 0x3d, 0x89, 0x89, 0x72, 0xff, 0xa5, 0x26, 0xde, 0x8d, 0xa3, 0x5a, 0x28, 0x7c, 0xfd,
        0xd2, 0xf5, 0xae, 0xe8, 0xf9, 0x95, 0x37, 0x26, 0xb4, 0x52, 0x81, 0x34, 0x44, 0xf6, 0xaa, 0x86,
        0x04, 0x5f, 0xbd, 0x8a, 0x4a, 0xaa, 0x31, 0x55, 0x6a, 0xd7, 0x03, 0x95, 0x83, 0x36, 0x98, 0xcb,
        0x34, 0x05, 0x78, 0xff, 0x9a, 0x73, 0x4a, 0xbb, 0x79, 0x30, 0x16, 0x36, 0xe3, 0x69, 0x78, 0x45,
        0xaf, 0xf0, 0x74, 0xa1, 0x13, 0x5d, 0xe1, 0xe9, 0xe2, 0x9d, 0xaf, 0x7f, 0x78, 0xf2, 0x87, 0x9e,
        0xfb, 0xee, 0x54, 0xcf, 0x9d, 0x9c, 0xea, 0xda, 0xcb, 0x53, 0x5d, 0xfb, 0xfd, 0x54, 0xd7, 0xbe,
        0x3a, 0xd3, 0x73, 0x2f, 0xcf, 0xf4, 0xdc, 0x2f, 0x67, 0x7a, 0xee, 0x13, 0x2b, 0x53, 0xd4, 0xe2,
        0x85, 0x37, 0xe9, 0xc1, 0x01, 0x71, 0x89, 0xd3, 0x51, 0x73, 0x2b, 0xf9, 0x53, 0x14, 0x15, 0xae,
        0x39, 0x2d, 0xfe, 0xdb, 0x5e, 0xfb, 0x2b, 0x00, 0x00, 0xff, 0xff, 0xb4, 0xdd, 0x18, 0x39, 0x46,
        0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgServiceClient is the client API for MsgService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgServiceClient interface {
        MsgAddMarket(ctx context.Context, in *MsgAddMarketRequest, opts ...grpc.CallOption) (*MsgAddMarketResponse, error)
        MsgUpdateMarket(ctx context.Context, in *MsgUpdateMarketRequest, opts ...grpc.CallOption) (*MsgUpdateMarketResponse, error)
        MsgAddAsset(ctx context.Context, in *MsgAddAssetRequest, opts ...grpc.CallOption) (*MsgAddAssetResponse, error)
        MsgUpdateAsset(ctx context.Context, in *MsgUpdateAssetRequest, opts ...grpc.CallOption) (*MsgUpdateAssetResponse, error)
        MsgAddMarketForAsset(ctx context.Context, in *MsgAddMarketForAssetRequest, opts ...grpc.CallOption) (*MsgAddMarketForAssetResponse, error)
        MsgRemoveMarketForAsset(ctx context.Context, in *MsgRemoveMarketForAssetRequest, opts ...grpc.CallOption) (*MsgRemoveMarketForAssetResponse, error)
        MsgAddPair(ctx context.Context, in *MsgAddPairRequest, opts ...grpc.CallOption) (*MsgAddPairResponse, error)
        MsgUpdatePair(ctx context.Context, in *MsgUpdatePairRequest, opts ...grpc.CallOption) (*MsgUpdatePairResponse, error)
        MsgFetchPrice(ctx context.Context, in *MsgFetchPriceRequest, opts ...grpc.CallOption) (*MsgFetchPriceResponse, error)
}

type msgServiceClient struct {
        cc grpc1.ClientConn
}

func NewMsgServiceClient(cc grpc1.ClientConn) MsgServiceClient <span class="cov0" title="0">{
        return &amp;msgServiceClient{cc}
}</span>

func (c *msgServiceClient) MsgAddMarket(ctx context.Context, in *MsgAddMarketRequest, opts ...grpc.CallOption) (*MsgAddMarketResponse, error) <span class="cov0" title="0">{
        out := new(MsgAddMarketResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgAddMarket", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgUpdateMarket(ctx context.Context, in *MsgUpdateMarketRequest, opts ...grpc.CallOption) (*MsgUpdateMarketResponse, error) <span class="cov0" title="0">{
        out := new(MsgUpdateMarketResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgUpdateMarket", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgAddAsset(ctx context.Context, in *MsgAddAssetRequest, opts ...grpc.CallOption) (*MsgAddAssetResponse, error) <span class="cov0" title="0">{
        out := new(MsgAddAssetResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgAddAsset", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgUpdateAsset(ctx context.Context, in *MsgUpdateAssetRequest, opts ...grpc.CallOption) (*MsgUpdateAssetResponse, error) <span class="cov0" title="0">{
        out := new(MsgUpdateAssetResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgUpdateAsset", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgAddMarketForAsset(ctx context.Context, in *MsgAddMarketForAssetRequest, opts ...grpc.CallOption) (*MsgAddMarketForAssetResponse, error) <span class="cov0" title="0">{
        out := new(MsgAddMarketForAssetResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgAddMarketForAsset", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgRemoveMarketForAsset(ctx context.Context, in *MsgRemoveMarketForAssetRequest, opts ...grpc.CallOption) (*MsgRemoveMarketForAssetResponse, error) <span class="cov0" title="0">{
        out := new(MsgRemoveMarketForAssetResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgRemoveMarketForAsset", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgAddPair(ctx context.Context, in *MsgAddPairRequest, opts ...grpc.CallOption) (*MsgAddPairResponse, error) <span class="cov0" title="0">{
        out := new(MsgAddPairResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgAddPair", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgUpdatePair(ctx context.Context, in *MsgUpdatePairRequest, opts ...grpc.CallOption) (*MsgUpdatePairResponse, error) <span class="cov0" title="0">{
        out := new(MsgUpdatePairResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgUpdatePair", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgFetchPrice(ctx context.Context, in *MsgFetchPriceRequest, opts ...grpc.CallOption) (*MsgFetchPriceResponse, error) <span class="cov0" title="0">{
        out := new(MsgFetchPriceResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.MsgService/MsgFetchPrice", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MsgServiceServer is the server API for MsgService service.
type MsgServiceServer interface {
        MsgAddMarket(context.Context, *MsgAddMarketRequest) (*MsgAddMarketResponse, error)
        MsgUpdateMarket(context.Context, *MsgUpdateMarketRequest) (*MsgUpdateMarketResponse, error)
        MsgAddAsset(context.Context, *MsgAddAssetRequest) (*MsgAddAssetResponse, error)
        MsgUpdateAsset(context.Context, *MsgUpdateAssetRequest) (*MsgUpdateAssetResponse, error)
        MsgAddMarketForAsset(context.Context, *MsgAddMarketForAssetRequest) (*MsgAddMarketForAssetResponse, error)
        MsgRemoveMarketForAsset(context.Context, *MsgRemoveMarketForAssetRequest) (*MsgRemoveMarketForAssetResponse, error)
        MsgAddPair(context.Context, *MsgAddPairRequest) (*MsgAddPairResponse, error)
        MsgUpdatePair(context.Context, *MsgUpdatePairRequest) (*MsgUpdatePairResponse, error)
        MsgFetchPrice(context.Context, *MsgFetchPriceRequest) (*MsgFetchPriceResponse, error)
}

// UnimplementedMsgServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServiceServer struct {
}

func (*UnimplementedMsgServiceServer) MsgAddMarket(ctx context.Context, req *MsgAddMarketRequest) (*MsgAddMarketResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgAddMarket not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgUpdateMarket(ctx context.Context, req *MsgUpdateMarketRequest) (*MsgUpdateMarketResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgUpdateMarket not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgAddAsset(ctx context.Context, req *MsgAddAssetRequest) (*MsgAddAssetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgAddAsset not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgUpdateAsset(ctx context.Context, req *MsgUpdateAssetRequest) (*MsgUpdateAssetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgUpdateAsset not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgAddMarketForAsset(ctx context.Context, req *MsgAddMarketForAssetRequest) (*MsgAddMarketForAssetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgAddMarketForAsset not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgRemoveMarketForAsset(ctx context.Context, req *MsgRemoveMarketForAssetRequest) (*MsgRemoveMarketForAssetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgRemoveMarketForAsset not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgAddPair(ctx context.Context, req *MsgAddPairRequest) (*MsgAddPairResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgAddPair not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgUpdatePair(ctx context.Context, req *MsgUpdatePairRequest) (*MsgUpdatePairResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgUpdatePair not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgFetchPrice(ctx context.Context, req *MsgFetchPriceRequest) (*MsgFetchPriceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgFetchPrice not implemented")
}</span>

func RegisterMsgServiceServer(s grpc1.Server, srv MsgServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_MsgService_serviceDesc, srv)
}</span>

func _MsgService_MsgAddMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgAddMarketRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddMarket(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgAddMarket",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddMarket(ctx, req.(*MsgAddMarketRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgUpdateMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUpdateMarketRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgUpdateMarket(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgUpdateMarket",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgUpdateMarket(ctx, req.(*MsgUpdateMarketRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgAddAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgAddAssetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddAsset(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgAddAsset",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddAsset(ctx, req.(*MsgAddAssetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgUpdateAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUpdateAssetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgUpdateAsset(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgUpdateAsset",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgUpdateAsset(ctx, req.(*MsgUpdateAssetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgAddMarketForAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgAddMarketForAssetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddMarketForAsset(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgAddMarketForAsset",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddMarketForAsset(ctx, req.(*MsgAddMarketForAssetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgRemoveMarketForAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgRemoveMarketForAssetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgRemoveMarketForAsset(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgRemoveMarketForAsset",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgRemoveMarketForAsset(ctx, req.(*MsgRemoveMarketForAssetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgAddPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgAddPairRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddPair(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgAddPair",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgAddPair(ctx, req.(*MsgAddPairRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgUpdatePair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgUpdatePairRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgUpdatePair(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgUpdatePair",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgUpdatePair(ctx, req.(*MsgUpdatePairRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgFetchPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgFetchPriceRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgFetchPrice(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.MsgService/MsgFetchPrice",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgFetchPrice(ctx, req.(*MsgFetchPriceRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _MsgService_serviceDesc = grpc.ServiceDesc{
        ServiceName: "comdex.asset.v1beta1.MsgService",
        HandlerType: (*MsgServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "MsgAddMarket",
                        Handler:    _MsgService_MsgAddMarket_Handler,
                },
                {
                        MethodName: "MsgUpdateMarket",
                        Handler:    _MsgService_MsgUpdateMarket_Handler,
                },
                {
                        MethodName: "MsgAddAsset",
                        Handler:    _MsgService_MsgAddAsset_Handler,
                },
                {
                        MethodName: "MsgUpdateAsset",
                        Handler:    _MsgService_MsgUpdateAsset_Handler,
                },
                {
                        MethodName: "MsgAddMarketForAsset",
                        Handler:    _MsgService_MsgAddMarketForAsset_Handler,
                },
                {
                        MethodName: "MsgRemoveMarketForAsset",
                        Handler:    _MsgService_MsgRemoveMarketForAsset_Handler,
                },
                {
                        MethodName: "MsgAddPair",
                        Handler:    _MsgService_MsgAddPair_Handler,
                },
                {
                        MethodName: "MsgUpdatePair",
                        Handler:    _MsgService_MsgUpdatePair_Handler,
                },
                {
                        MethodName: "MsgFetchPrice",
                        Handler:    _MsgService_MsgFetchPrice_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "comdex/asset/v1beta1/msg.proto",
}

func (m *MsgAddMarketRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddMarketRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddMarketRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.ScriptID != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.ScriptID))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if len(m.Symbol) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Symbol)
                copy(dAtA[i:], m.Symbol)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Symbol)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgAddMarketResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddMarketResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgUpdateMarketRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateMarketRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateMarketRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.ScriptID != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.ScriptID))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if len(m.Symbol) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Symbol)
                copy(dAtA[i:], m.Symbol)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Symbol)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdateMarketResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateMarketResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgAddAssetRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddAssetRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddAssetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Decimals != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.Decimals))
                i--
                dAtA[i] = 0x20
        }</span>
        <span class="cov0" title="0">if len(m.Denom) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Denom)
                copy(dAtA[i:], m.Denom)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Denom)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Name) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgAddAssetResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddAssetResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddAssetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgUpdateAssetRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateAssetRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateAssetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Decimals != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.Decimals))
                i--
                dAtA[i] = 0x28
        }</span>
        <span class="cov0" title="0">if len(m.Denom) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Denom)
                copy(dAtA[i:], m.Denom)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Denom)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">if len(m.Name) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Name)
                copy(dAtA[i:], m.Name)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdateAssetResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdateAssetResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdateAssetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgAddMarketForAssetRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddMarketForAssetRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddMarketForAssetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Symbol) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Symbol)
                copy(dAtA[i:], m.Symbol)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Symbol)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgAddMarketForAssetResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddMarketForAssetResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddMarketForAssetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgRemoveMarketForAssetRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRemoveMarketForAssetRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRemoveMarketForAssetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Symbol) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Symbol)
                copy(dAtA[i:], m.Symbol)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Symbol)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgRemoveMarketForAssetResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRemoveMarketForAssetResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRemoveMarketForAssetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgAddPairRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddPairRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddPairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.LiquidationRatio.Size()
                i -= size
                if _, err := m.LiquidationRatio.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if m.AssetOut != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.AssetOut))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if m.AssetIn != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.AssetIn))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgAddPairResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgAddPairResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgAddPairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgUpdatePairRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdatePairRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdatePairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.LiquidationRatio.Size()
                i -= size
                if _, err := m.LiquidationRatio.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgUpdatePairResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgUpdatePairResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgUpdatePairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgFetchPriceRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgFetchPriceRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgFetchPriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.ExecuteGas != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.ExecuteGas))
                i--
                dAtA[i] = 0x50
        }</span>
        <span class="cov0" title="0">if m.PrepareGas != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.PrepareGas))
                i--
                dAtA[i] = 0x48
        }</span>
        <span class="cov0" title="0">if len(m.FeeLimit) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.FeeLimit) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.FeeLimit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintMsg(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x42</span>
                }
        }
        <span class="cov0" title="0">if m.ScriptID != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.ScriptID))
                i--
                dAtA[i] = 0x38
        }</span>
        <span class="cov0" title="0">if len(m.Symbols) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Symbols) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.Symbols[iNdEx])
                        copy(dAtA[i:], m.Symbols[iNdEx])
                        i = encodeVarintMsg(dAtA, i, uint64(len(m.Symbols[iNdEx])))
                        i--
                        dAtA[i] = 0x32
                }</span>
        }
        <span class="cov0" title="0">if m.TimeoutTimestamp != 0 </span><span class="cov0" title="0">{
                i = encodeVarintMsg(dAtA, i, uint64(m.TimeoutTimestamp))
                i--
                dAtA[i] = 0x28
        }</span>
        <span class="cov0" title="0">{
                size, err := m.TimeoutHeight.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if len(m.SourceChannel) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.SourceChannel)
                copy(dAtA[i:], m.SourceChannel)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.SourceChannel)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.SourcePort) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.SourcePort)
                copy(dAtA[i:], m.SourcePort)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.SourcePort)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.From) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.From)
                copy(dAtA[i:], m.From)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.From)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgFetchPriceResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgFetchPriceResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgFetchPriceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintMsg(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovMsg(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MsgAddMarketRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Symbol)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.ScriptID != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.ScriptID))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgAddMarketResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgUpdateMarketRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Symbol)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.ScriptID != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.ScriptID))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgUpdateMarketResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgAddAssetRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Name)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Denom)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Decimals != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.Decimals))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgAddAssetResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgUpdateAssetRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = len(m.Name)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Denom)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Decimals != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.Decimals))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgUpdateAssetResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgAddMarketForAssetRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = len(m.Symbol)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgAddMarketForAssetResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgRemoveMarketForAssetRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = len(m.Symbol)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgRemoveMarketForAssetResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgAddPairRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.AssetIn != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.AssetIn))
        }</span>
        <span class="cov0" title="0">if m.AssetOut != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.AssetOut))
        }</span>
        <span class="cov0" title="0">l = m.LiquidationRatio.Size()
        n += 1 + l + sovMsg(uint64(l))
        return n</span>
}

func (m *MsgAddPairResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgUpdatePairRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = m.LiquidationRatio.Size()
        n += 1 + l + sovMsg(uint64(l))
        return n</span>
}

func (m *MsgUpdatePairResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgFetchPriceRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.From)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.SourcePort)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.SourceChannel)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.TimeoutHeight.Size()
        n += 1 + l + sovMsg(uint64(l))
        if m.TimeoutTimestamp != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.TimeoutTimestamp))
        }</span>
        <span class="cov0" title="0">if len(m.Symbols) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.Symbols </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovMsg(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.ScriptID != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.ScriptID))
        }</span>
        <span class="cov0" title="0">if len(m.FeeLimit) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.FeeLimit </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovMsg(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.PrepareGas != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.PrepareGas))
        }</span>
        <span class="cov0" title="0">if m.ExecuteGas != 0 </span><span class="cov0" title="0">{
                n += 1 + sovMsg(uint64(m.ExecuteGas))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgFetchPriceResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovMsg(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozMsg(x uint64) (n int) <span class="cov0" title="0">{
        return sovMsg(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MsgAddMarketRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddMarketRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddMarketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Symbol = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ScriptID", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ScriptID = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ScriptID |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddMarketResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddMarketResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateMarketRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateMarketRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateMarketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Symbol = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ScriptID", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ScriptID = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ScriptID |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateMarketResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateMarketResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddAssetRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddAssetRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddAssetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Denom = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Decimals = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Decimals |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddAssetResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddAssetResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddAssetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateAssetRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateAssetRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateAssetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Name = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Denom = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Decimals = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Decimals |= int64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdateAssetResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateAssetResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdateAssetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddMarketForAssetRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddMarketForAssetRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddMarketForAssetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Symbol = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddMarketForAssetResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddMarketForAssetResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddMarketForAssetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgRemoveMarketForAssetRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRemoveMarketForAssetRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRemoveMarketForAssetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Symbol = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgRemoveMarketForAssetResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRemoveMarketForAssetResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRemoveMarketForAssetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddPairRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddPairRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddPairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AssetIn", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AssetIn = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AssetIn |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AssetOut", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AssetOut = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AssetOut |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field LiquidationRatio", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.LiquidationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgAddPairResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddPairResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgAddPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdatePairRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdatePairRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdatePairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field LiquidationRatio", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.LiquidationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgUpdatePairResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdatePairResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgUpdatePairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgFetchPriceRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgFetchPriceRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgFetchPriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.From = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SourcePort", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.SourcePort = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field SourceChannel", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.SourceChannel = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TimeoutHeight", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.TimeoutHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field TimeoutTimestamp", wireType)
                        }</span>
                        <span class="cov0" title="0">m.TimeoutTimestamp = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.TimeoutTimestamp |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 6:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Symbols", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Symbols = append(m.Symbols, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                case 7:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ScriptID", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ScriptID = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ScriptID |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 8:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field FeeLimit", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.FeeLimit = append(m.FeeLimit, types1.Coin{})
                        if err := m.FeeLimit[len(m.FeeLimit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 9:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field PrepareGas", wireType)
                        }</span>
                        <span class="cov0" title="0">m.PrepareGas = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.PrepareGas |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 10:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ExecuteGas", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ExecuteGas = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ExecuteGas |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgFetchPriceResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgFetchPriceResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgFetchPriceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipMsg(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupMsg
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthMsg
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthMsg        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowMsg          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupMsg = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file11" style="display: none">package types

import (
        "fmt"
)

const (
        MaxMarketSymbolLength = 8
)

func (m *Market) Validate() error <span class="cov8" title="1">{
        if m.Symbol == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("symbol cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(m.Symbol) &gt; MaxMarketSymbolLength </span><span class="cov8" title="1">{
                return fmt.Errorf("symbol length cannot be greater than %d", MaxMarketSymbolLength)
        }</span>
        <span class="cov8" title="1">if m.ScriptID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("script_id cannot be zero")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/oracle.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Market struct {
        Symbol   string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty" yaml:"symbol"`
        ScriptID uint64 `protobuf:"varint,2,opt,name=script_id,json=scriptId,proto3" json:"script_id,omitempty" yaml:"script_id"`
}

func (m *Market) Reset()         <span class="cov0" title="0">{ *m = Market{} }</span>
func (m *Market) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Market) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Market) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a32f85c7c13393b9, []int{0}
}</span>
func (m *Market) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Market) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Market.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Market) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Market.Merge(m, src)
}</span>
func (m *Market) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Market) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Market.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Market proto.InternalMessageInfo

type Calldata struct {
        Symbols    []string `protobuf:"bytes,1,rep,name=symbols,proto3" json:"symbols,omitempty" yaml:"symbols"`
        Multiplier uint64   `protobuf:"varint,2,opt,name=multiplier,proto3" json:"multiplier,omitempty" yaml:"multiplier"`
}

func (m *Calldata) Reset()         <span class="cov0" title="0">{ *m = Calldata{} }</span>
func (m *Calldata) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Calldata) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Calldata) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a32f85c7c13393b9, []int{1}
}</span>
func (m *Calldata) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Calldata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Calldata.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Calldata) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Calldata.Merge(m, src)
}</span>
func (m *Calldata) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Calldata) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Calldata.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Calldata proto.InternalMessageInfo

type Result struct {
        Rates []uint64 `protobuf:"varint,1,rep,packed,name=rates,proto3" json:"rates,omitempty" yaml:"rates"`
}

func (m *Result) Reset()         <span class="cov0" title="0">{ *m = Result{} }</span>
func (m *Result) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Result) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Result) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_a32f85c7c13393b9, []int{2}
}</span>
func (m *Result) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Result.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Result) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Result.Merge(m, src)
}</span>
func (m *Result) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Result) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Result.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Result proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Market)(nil), "comdex.asset.v1beta1.Market")
        proto.RegisterType((*Calldata)(nil), "comdex.asset.v1beta1.Calldata")
        proto.RegisterType((*Result)(nil), "comdex.asset.v1beta1.Result")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/oracle.proto", fileDescriptor_a32f85c7c13393b9) }</span>

var fileDescriptor_a32f85c7c13393b9 = []byte{
        // 338 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x91, 0x31, 0x4e, 0xc3, 0x30,
        0x18, 0x85, 0x13, 0x28, 0xa1, 0xb5, 0x00, 0xb5, 0x51, 0x91, 0x2a, 0x06, 0x27, 0x78, 0x40, 0x45,
        0x82, 0x98, 0x0a, 0xb1, 0x20, 0xb1, 0x04, 0x96, 0x0e, 0x0c, 0x84, 0x8d, 0x05, 0x39, 0x89, 0x5b,
        0x2c, 0x1c, 0x39, 0xb2, 0x5d, 0x44, 0x6f, 0xc1, 0x31, 0x38, 0x4a, 0xc7, 0x8e, 0x4c, 0x11, 0xa4,
        0x37, 0xc8, 0x09, 0x10, 0x71, 0x2a, 0xba, 0xfd, 0x7e, 0xff, 0xf7, 0xfc, 0xa4, 0xf7, 0x83, 0xe3,
        0x44, 0x64, 0x29, 0x7d, 0xc7, 0x44, 0x29, 0xaa, 0xf1, 0xdb, 0x28, 0xa6, 0x9a, 0x8c, 0xb0, 0x90,
        0x24, 0xe1, 0x34, 0xc8, 0xa5, 0xd0, 0xc2, 0xed, 0x1b, 0x24, 0xa8, 0x91, 0xa0, 0x41, 0x8e, 0xfa,
        0x53, 0x31, 0x15, 0x35, 0x80, 0xff, 0x26, 0xc3, 0x22, 0x09, 0x9c, 0x7b, 0x22, 0x5f, 0xa9, 0x76,
        0x4f, 0x81, 0xa3, 0xe6, 0x59, 0x2c, 0xf8, 0xc0, 0xf6, 0xed, 0x61, 0x27, 0xec, 0x55, 0x85, 0xb7,
        0x3f, 0x27, 0x19, 0xbf, 0x46, 0x46, 0x47, 0x51, 0x03, 0xb8, 0x37, 0xa0, 0xa3, 0x12, 0xc9, 0x72,
        0xfd, 0xcc, 0xd2, 0xc1, 0x96, 0x6f, 0x0f, 0x5b, 0xa1, 0x5f, 0x16, 0x5e, 0xfb, 0xb1, 0x16, 0xc7,
        0x77, 0x55, 0xe1, 0x75, 0x1b, 0xe7, 0x1a, 0x43, 0x51, 0xdb, 0xcc, 0xe3, 0x14, 0x09, 0xd0, 0xbe,
        0x25, 0x9c, 0xa7, 0x44, 0x13, 0xf7, 0x0c, 0xec, 0x9a, 0x4f, 0xd5, 0xc0, 0xf6, 0xb7, 0x87, 0x9d,
        0xd0, 0xad, 0x0a, 0xef, 0x60, 0x33, 0x56, 0xa1, 0x68, 0x8d, 0xb8, 0x57, 0x00, 0x64, 0x33, 0xae,
        0x59, 0xce, 0x19, 0x95, 0x4d, 0xf2, 0x61, 0x55, 0x78, 0x3d, 0x63, 0xf8, 0xdf, 0xa1, 0x68, 0x03,
        0x44, 0x17, 0xc0, 0x89, 0xa8, 0x9a, 0x71, 0xed, 0x9e, 0x80, 0x1d, 0x49, 0x34, 0x35, 0x61, 0xad,
        0xb0, 0x5b, 0x15, 0xde, 0x9e, 0xf1, 0xd6, 0x32, 0x8a, 0xcc, 0x3a, 0x7c, 0x58, 0xfc, 0x40, 0xeb,
        0xb3, 0x84, 0xd6, 0xa2, 0x84, 0xf6, 0xb2, 0x84, 0xf6, 0x77, 0x09, 0xed, 0x8f, 0x15, 0xb4, 0x96,
        0x2b, 0x68, 0x7d, 0xad, 0xa0, 0xf5, 0x84, 0xa7, 0x4c, 0xbf, 0xcc, 0xe2, 0x20, 0x11, 0x19, 0x36,
        0x7d, 0x9f, 0x8b, 0xc9, 0x84, 0x25, 0x8c, 0xf0, 0xe6, 0x8d, 0xd7, 0x47, 0xd2, 0xf3, 0x9c, 0xaa,
        0xd8, 0xa9, 0x0b, 0xbf, 0xfc, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x06, 0x4d, 0x7b, 0x79, 0xc1, 0x01,
        0x00, 0x00,
}

func (m *Market) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Market) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Market) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.ScriptID != 0 </span><span class="cov0" title="0">{
                i = encodeVarintOracle(dAtA, i, uint64(m.ScriptID))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.Symbol) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Symbol)
                copy(dAtA[i:], m.Symbol)
                i = encodeVarintOracle(dAtA, i, uint64(len(m.Symbol)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *Calldata) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Calldata) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Calldata) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Multiplier != 0 </span><span class="cov0" title="0">{
                i = encodeVarintOracle(dAtA, i, uint64(m.Multiplier))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if len(m.Symbols) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Symbols) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        i -= len(m.Symbols[iNdEx])
                        copy(dAtA[i:], m.Symbols[iNdEx])
                        i = encodeVarintOracle(dAtA, i, uint64(len(m.Symbols[iNdEx])))
                        i--
                        dAtA[i] = 0xa
                }</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *Result) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Rates) &gt; 0 </span><span class="cov0" title="0">{
                dAtA2 := make([]byte, len(m.Rates)*10)
                var j1 int
                for _, num := range m.Rates </span><span class="cov0" title="0">{
                        for num &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                                dAtA2[j1] = uint8(uint64(num)&amp;0x7f | 0x80)
                                num &gt;&gt;= 7
                                j1++
                        }</span>
                        <span class="cov0" title="0">dAtA2[j1] = uint8(num)
                        j1++</span>
                }
                <span class="cov0" title="0">i -= j1
                copy(dAtA[i:], dAtA2[:j1])
                i = encodeVarintOracle(dAtA, i, uint64(j1))
                i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintOracle(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovOracle(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Market) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Symbol)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovOracle(uint64(l))
        }</span>
        <span class="cov0" title="0">if m.ScriptID != 0 </span><span class="cov0" title="0">{
                n += 1 + sovOracle(uint64(m.ScriptID))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *Calldata) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Symbols) &gt; 0 </span><span class="cov0" title="0">{
                for _, s := range m.Symbols </span><span class="cov0" title="0">{
                        l = len(s)
                        n += 1 + l + sovOracle(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Multiplier != 0 </span><span class="cov0" title="0">{
                n += 1 + sovOracle(uint64(m.Multiplier))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *Result) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Rates) &gt; 0 </span><span class="cov0" title="0">{
                l = 0
                for _, e := range m.Rates </span><span class="cov0" title="0">{
                        l += sovOracle(uint64(e))
                }</span>
                <span class="cov0" title="0">n += 1 + sovOracle(uint64(l)) + l</span>
        }
        <span class="cov0" title="0">return n</span>
}

func sovOracle(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozOracle(x uint64) (n int) <span class="cov0" title="0">{
        return sovOracle(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Market) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowOracle
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Market: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Market: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowOracle
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracle
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracle
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Symbol = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field ScriptID", wireType)
                        }</span>
                        <span class="cov0" title="0">m.ScriptID = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowOracle
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.ScriptID |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipOracle(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracle
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *Calldata) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowOracle
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Calldata: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Calldata: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Symbols", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowOracle
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracle
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracle
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Symbols = append(m.Symbols, string(dAtA[iNdEx:postIndex]))
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Multiplier = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowOracle
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Multiplier |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipOracle(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracle
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *Result) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowOracle
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Result: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType == 0 </span><span class="cov0" title="0">{
                                var v uint64
                                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                return ErrIntOverflowOracle
                                        }</span>
                                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                return io.ErrUnexpectedEOF
                                        }</span>
                                        <span class="cov0" title="0">b := dAtA[iNdEx]
                                        iNdEx++
                                        v |= uint64(b&amp;0x7F) &lt;&lt; shift
                                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">m.Rates = append(m.Rates, v)</span>
                        } else<span class="cov0" title="0"> if wireType == 2 </span><span class="cov0" title="0">{
                                var packedLen int
                                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                return ErrIntOverflowOracle
                                        }</span>
                                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                return io.ErrUnexpectedEOF
                                        }</span>
                                        <span class="cov0" title="0">b := dAtA[iNdEx]
                                        iNdEx++
                                        packedLen |= int(b&amp;0x7F) &lt;&lt; shift
                                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if packedLen &lt; 0 </span><span class="cov0" title="0">{
                                        return ErrInvalidLengthOracle
                                }</span>
                                <span class="cov0" title="0">postIndex := iNdEx + packedLen
                                if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                        return ErrInvalidLengthOracle
                                }</span>
                                <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">var elementCount int
                                var count int
                                for _, integer := range dAtA[iNdEx:postIndex] </span><span class="cov0" title="0">{
                                        if integer &lt; 128 </span><span class="cov0" title="0">{
                                                count++
                                        }</span>
                                }
                                <span class="cov0" title="0">elementCount = count
                                if elementCount != 0 &amp;&amp; len(m.Rates) == 0 </span><span class="cov0" title="0">{
                                        m.Rates = make([]uint64, 0, elementCount)
                                }</span>
                                <span class="cov0" title="0">for iNdEx &lt; postIndex </span><span class="cov0" title="0">{
                                        var v uint64
                                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                                        return ErrIntOverflowOracle
                                                }</span>
                                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                                        return io.ErrUnexpectedEOF
                                                }</span>
                                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                                iNdEx++
                                                v |= uint64(b&amp;0x7F) &lt;&lt; shift
                                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">m.Rates = append(m.Rates, v)</span>
                                }
                        } else<span class="cov0" title="0"> {
                                return fmt.Errorf("proto: wrong wireType = %d for field Rates", wireType)
                        }</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipOracle(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthOracle
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipOracle(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowOracle
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowOracle
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowOracle
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthOracle
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupOracle
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthOracle
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthOracle        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowOracle          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupOracle = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file13" style="display: none">package types

import (
        "fmt"
)

func (m *Pair) Validate() error <span class="cov8" title="1">{
        if m.Id == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("id cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.AssetIn == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("asset_in cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.AssetOut == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("asset_out cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.LiquidationRatio.IsNil() </span><span class="cov0" title="0">{
                return fmt.Errorf("liquidation_ratio cannot be nil")
        }</span>
        <span class="cov8" title="1">if m.LiquidationRatio.IsNegative() </span><span class="cov8" title="1">{
                return fmt.Errorf("liquidation_ratio cannot be negative")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/pair.proto

package types

import (
        fmt "fmt"
        github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Pair struct {
        Id               uint64                                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        AssetIn          uint64                                 `protobuf:"varint,2,opt,name=asset_in,json=assetIn,proto3" json:"asset_in,omitempty" yaml:"asset_in"`
        AssetOut         uint64                                 `protobuf:"varint,3,opt,name=asset_out,json=assetOut,proto3" json:"asset_out,omitempty" yaml:"asset_out"`
        LiquidationRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=liquidation_ratio,json=liquidationRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_ratio" yaml:"liquidation_ratio"`
}

func (m *Pair) Reset()         <span class="cov0" title="0">{ *m = Pair{} }</span>
func (m *Pair) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Pair) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Pair) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_65bd24918e5ac160, []int{0}
}</span>
func (m *Pair) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Pair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Pair.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Pair) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Pair.Merge(m, src)
}</span>
func (m *Pair) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Pair) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Pair.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Pair proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Pair)(nil), "comdex.asset.v1beta1.Pair")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/pair.proto", fileDescriptor_65bd24918e5ac160) }</span>

var fileDescriptor_65bd24918e5ac160 = []byte{
        // 316 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x91, 0xb1, 0x4e, 0xc3, 0x30,
        0x10, 0x86, 0xed, 0x52, 0x01, 0xf5, 0x00, 0x25, 0x74, 0x88, 0x18, 0xec, 0x2a, 0x03, 0xea, 0x52,
        0x5b, 0x15, 0x1b, 0x63, 0xc5, 0x02, 0x0b, 0x90, 0x91, 0xa5, 0x72, 0x93, 0xb4, 0x58, 0x34, 0xbd,
        0x12, 0x3b, 0x40, 0xdf, 0x82, 0xc7, 0xe0, 0x51, 0x3a, 0x76, 0x44, 0x0c, 0x11, 0xa4, 0x6f, 0x90,
        0x27, 0x40, 0x71, 0x52, 0xa9, 0x88, 0xc5, 0x77, 0xfe, 0xfd, 0xfd, 0x77, 0xd6, 0x1d, 0x61, 0x01,
        0xc4, 0x61, 0xf4, 0x26, 0xa4, 0xd6, 0x91, 0x11, 0x2f, 0x83, 0x71, 0x64, 0xe4, 0x40, 0x2c, 0xa4,
        0x4a, 0xf8, 0x22, 0x01, 0x03, 0x4e, 0xa7, 0x02, 0xb8, 0x05, 0x78, 0x0d, 0x9c, 0x75, 0xa6, 0x30,
        0x05, 0x0b, 0x88, 0x32, 0xab, 0x58, 0xaf, 0xc0, 0xa4, 0x79, 0x27, 0x55, 0xe2, 0x1c, 0x91, 0x86,
        0x0a, 0x5d, 0xdc, 0xc5, 0xbd, 0xa6, 0xdf, 0x50, 0xa1, 0xc3, 0xc9, 0xa1, 0xf5, 0x8f, 0xd4, 0xdc,
        0x6d, 0x94, 0xea, 0xf0, 0xb4, 0xc8, 0xd8, 0xf1, 0x52, 0xc6, 0xb3, 0x4b, 0x6f, 0xfb, 0xe2, 0xf9,
        0x07, 0x36, 0xbd, 0x9e, 0x3b, 0x03, 0xd2, 0xaa, 0x54, 0x48, 0x8d, 0xbb, 0x67, 0x0d, 0x9d, 0x22,
        0x63, 0xed, 0x5d, 0x03, 0xa4, 0xc6, 0xf3, 0xab, 0xb2, 0xb7, 0xa9, 0x71, 0x5e, 0xc9, 0xc9, 0x4c,
        0x3d, 0xa7, 0x2a, 0x94, 0x46, 0xc1, 0x7c, 0x94, 0x94, 0xc1, 0x6d, 0x76, 0x71, 0xaf, 0x35, 0xbc,
        0x59, 0x65, 0x0c, 0x7d, 0x65, 0xec, 0x7c, 0xaa, 0xcc, 0x63, 0x3a, 0xe6, 0x01, 0xc4, 0x22, 0x00,
        0x1d, 0x83, 0xae, 0x43, 0x5f, 0x87, 0x4f, 0xc2, 0x2c, 0x17, 0x91, 0xe6, 0x57, 0x51, 0x50, 0x64,
        0xcc, 0xad, 0x1a, 0xfd, 0x2b, 0xe8, 0xf9, 0xed, 0x1d, 0xcd, 0x2f, 0xcf, 0xe1, 0xfd, 0xea, 0x87,
        0xa2, 0x8f, 0x9c, 0xa2, 0x55, 0x4e, 0xf1, 0x3a, 0xa7, 0xf8, 0x3b, 0xa7, 0xf8, 0x7d, 0x43, 0xd1,
        0x7a, 0x43, 0xd1, 0xe7, 0x86, 0xa2, 0x07, 0xf1, 0xa7, 0x6f, 0x39, 0xcd, 0x3e, 0x4c, 0x26, 0x2a,
        0x50, 0x72, 0x56, 0xdf, 0xc5, 0x76, 0x01, 0xf6, 0x13, 0xe3, 0x7d, 0x3b, 0xce, 0x8b, 0xdf, 0x00,
        0x00, 0x00, 0xff, 0xff, 0x20, 0x23, 0xdb, 0x1a, 0x9d, 0x01, 0x00, 0x00,
}

func (m *Pair) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Pair) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Pair) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.LiquidationRatio.Size()
                i -= size
                if _, err := m.LiquidationRatio.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintPair(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if m.AssetOut != 0 </span><span class="cov0" title="0">{
                i = encodeVarintPair(dAtA, i, uint64(m.AssetOut))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if m.AssetIn != 0 </span><span class="cov0" title="0">{
                i = encodeVarintPair(dAtA, i, uint64(m.AssetIn))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintPair(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintPair(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovPair(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Pair) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovPair(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">if m.AssetIn != 0 </span><span class="cov0" title="0">{
                n += 1 + sovPair(uint64(m.AssetIn))
        }</span>
        <span class="cov0" title="0">if m.AssetOut != 0 </span><span class="cov0" title="0">{
                n += 1 + sovPair(uint64(m.AssetOut))
        }</span>
        <span class="cov0" title="0">l = m.LiquidationRatio.Size()
        n += 1 + l + sovPair(uint64(l))
        return n</span>
}

func sovPair(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozPair(x uint64) (n int) <span class="cov0" title="0">{
        return sovPair(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Pair) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowPair
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Pair: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Pair: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AssetIn", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AssetIn = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AssetIn |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AssetOut", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AssetOut = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AssetOut |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field LiquidationRatio", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthPair
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthPair
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.LiquidationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipPair(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthPair
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipPair(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowPair
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowPair
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthPair
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupPair
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthPair
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthPair        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowPair          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupPair = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file15" style="display: none">package types

import (
        "fmt"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/errors"
        paramstypes "github.com/cosmos/cosmos-sdk/x/params/types"
)

const (
        DefaultAdmin            = ""
        DefaultIBCPort          = "asset"
        DefaultIBCVersion       = "comdex-ics-01"
        DefaultOracleAskCount   = 1
        DefaultOracleMinCount   = 1
        DefaultOracleMultiplier = 9
)

var (
        KeyAdmin            = []byte("Admin")
        KeyIBCPort          = []byte("IBCPort")
        KeyIBCVersion       = []byte("IBCVersion")
        KeyOracleAskCount   = []byte("OracleAskCount")
        KeyOracleMinCount   = []byte("OracleMinCount")
        KeyOracleMultiplier = []byte("OracleMultiplier")
)

var (
        _ paramstypes.ParamSet = (*Params)(nil)
)

func NewIBCParams(port, version string) IBCParams <span class="cov8" title="1">{
        return IBCParams{
                Port:    port,
                Version: version,
        }
}</span>

func DefaultIBCParams() IBCParams <span class="cov8" title="1">{
        return NewIBCParams(
                DefaultIBCPort,
                DefaultIBCVersion,
        )
}</span>

func (m *IBCParams) Validate() error <span class="cov8" title="1">{
        if m.Port == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("port cannot be empty")
        }</span>
        <span class="cov8" title="1">if m.Version == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("version cannot be empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func NewOracleParams(askCount, minCount, multiplier uint64) OracleParams <span class="cov8" title="1">{
        return OracleParams{
                AskCount:   askCount,
                MinCount:   minCount,
                Multiplier: multiplier,
        }
}</span>

func DefaultOracleParams() OracleParams <span class="cov8" title="1">{
        return NewOracleParams(
                DefaultOracleAskCount,
                DefaultOracleMinCount,
                DefaultOracleMultiplier,
        )
}</span>

func (m *OracleParams) Validate() error <span class="cov8" title="1">{
        if m.AskCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("ask_count cannot be zero")
        }</span>
        <span class="cov8" title="1">if m.MinCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("min_count cannot be zero")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func NewParams(admin string, ibc IBCParams, oracle OracleParams) Params <span class="cov8" title="1">{
        return Params{
                Admin:  admin,
                IBC:    ibc,
                Oracle: oracle,
        }
}</span>

func DefaultParams() Params <span class="cov8" title="1">{
        return NewParams(
                DefaultAdmin,
                DefaultIBCParams(),
                DefaultOracleParams(),
        )
}</span>

func (m *Params) ParamSetPairs() paramstypes.ParamSetPairs <span class="cov0" title="0">{
        return paramstypes.ParamSetPairs{
                paramstypes.NewParamSetPair(
                        KeyAdmin,
                        m.Admin,
                        func(v interface{}) error </span><span class="cov0" title="0">{
                                value, ok := v.(string)
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid parameter type %T", v)
                                }</span>

                                <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                                        return fmt.Errorf("admin cannot be empty")
                                }</span>
                                <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(value); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrapf(err, "invalid admin %s", value)
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        },
                ),
                paramstypes.NewParamSetPair(
                        KeyIBCPort,
                        m.IBC.Port,
                        func(v interface{}) error <span class="cov0" title="0">{
                                value, ok := v.(string)
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid parameter type %T", v)
                                }</span>

                                <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                                        return fmt.Errorf("ibc.port cannot be empty")
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        },
                ),
                paramstypes.NewParamSetPair(
                        KeyIBCVersion,
                        m.IBC.Version,
                        func(v interface{}) error <span class="cov0" title="0">{
                                value, ok := v.(string)
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid parameter type %T", v)
                                }</span>

                                <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                                        return fmt.Errorf("ibc.version cannot be empty")
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        },
                ),
                paramstypes.NewParamSetPair(
                        KeyOracleAskCount,
                        m.Oracle.AskCount,
                        func(v interface{}) error <span class="cov0" title="0">{
                                value, ok := v.(uint64)
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid parameter type %T", v)
                                }</span>

                                <span class="cov0" title="0">if value == 0 </span><span class="cov0" title="0">{
                                        return fmt.Errorf("oracle.ask_count cannot be zero")
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        },
                ),
                paramstypes.NewParamSetPair(
                        KeyOracleMinCount,
                        m.Oracle.MinCount,
                        func(v interface{}) error <span class="cov0" title="0">{
                                value, ok := v.(uint64)
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid parameter type %T", v)
                                }</span>

                                <span class="cov0" title="0">if value == 0 </span><span class="cov0" title="0">{
                                        return fmt.Errorf("oracle.min_count cannot be zero")
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        },
                ),
                paramstypes.NewParamSetPair(
                        KeyOracleMultiplier,
                        m.Oracle.Multiplier,
                        func(v interface{}) error <span class="cov0" title="0">{
                                _, ok := v.(uint64)
                                if !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("invalid parameter type %T", v)
                                }</span>

                                <span class="cov0" title="0">return nil</span>
                        },
                ),
        }
}

func (m *Params) Validate() error <span class="cov0" title="0">{
        if m.Admin == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("admin cannot be empty")
        }</span>
        <span class="cov0" title="0">if _, err := sdk.AccAddressFromBech32(m.Admin); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "invalid admin %s", m.Admin)
        }</span>
        <span class="cov0" title="0">if err := m.IBC.Validate(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "invalid ibc params")
        }</span>
        <span class="cov0" title="0">if err := m.Oracle.Validate(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "invalid oracle params")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/params.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type IBCParams struct {
        Port    string `protobuf:"bytes,1,opt,name=port,proto3" json:"port,omitempty" yaml:"port"`
        Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty" yaml:"version"`
}

func (m *IBCParams) Reset()         <span class="cov0" title="0">{ *m = IBCParams{} }</span>
func (m *IBCParams) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*IBCParams) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*IBCParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6cd5d1c7ef4e1c40, []int{0}
}</span>
func (m *IBCParams) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *IBCParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_IBCParams.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *IBCParams) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_IBCParams.Merge(m, src)
}</span>
func (m *IBCParams) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *IBCParams) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_IBCParams.DiscardUnknown(m)
}</span>

var xxx_messageInfo_IBCParams proto.InternalMessageInfo

type OracleParams struct {
        AskCount   uint64 `protobuf:"varint,1,opt,name=ask_count,json=askCount,proto3" json:"ask_count,omitempty" yaml:"ask_count"`
        MinCount   uint64 `protobuf:"varint,2,opt,name=min_count,json=minCount,proto3" json:"min_count,omitempty" yaml:"min_count"`
        Multiplier uint64 `protobuf:"varint,3,opt,name=multiplier,proto3" json:"multiplier,omitempty" yaml:"multiplier"`
}

func (m *OracleParams) Reset()         <span class="cov0" title="0">{ *m = OracleParams{} }</span>
func (m *OracleParams) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*OracleParams) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*OracleParams) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6cd5d1c7ef4e1c40, []int{1}
}</span>
func (m *OracleParams) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *OracleParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_OracleParams.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *OracleParams) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_OracleParams.Merge(m, src)
}</span>
func (m *OracleParams) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *OracleParams) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_OracleParams.DiscardUnknown(m)
}</span>

var xxx_messageInfo_OracleParams proto.InternalMessageInfo

type Params struct {
        Admin  string       `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty" yaml:"admin"`
        IBC    IBCParams    `protobuf:"bytes,2,opt,name=ibc,proto3" json:"ibc" yaml:"ibc"`
        Oracle OracleParams `protobuf:"bytes,3,opt,name=oracle,proto3" json:"oracle" yaml:"oracle"`
}

func (m *Params) Reset()         <span class="cov0" title="0">{ *m = Params{} }</span>
func (m *Params) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Params) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Params) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_6cd5d1c7ef4e1c40, []int{2}
}</span>
func (m *Params) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Params.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Params) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Params.Merge(m, src)
}</span>
func (m *Params) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Params) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Params.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Params proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*IBCParams)(nil), "comdex.asset.v1beta1.IBCParams")
        proto.RegisterType((*OracleParams)(nil), "comdex.asset.v1beta1.OracleParams")
        proto.RegisterType((*Params)(nil), "comdex.asset.v1beta1.Params")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/asset/v1beta1/params.proto", fileDescriptor_6cd5d1c7ef4e1c40) }</span>

var fileDescriptor_6cd5d1c7ef4e1c40 = []byte{
        // 415 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0xcf, 0xae, 0xd2, 0x40,
        0x18, 0xc5, 0xdb, 0xcb, 0x15, 0x61, 0x40, 0xc5, 0x06, 0x12, 0x74, 0x31, 0xa3, 0x63, 0x62, 0x5c,
        0x68, 0x1b, 0x30, 0x6e, 0x5c, 0x96, 0x15, 0x89, 0x89, 0x32, 0x4b, 0x17, 0x9a, 0x69, 0x29, 0x38,
        0xa1, 0xed, 0x34, 0x6d, 0x21, 0xf2, 0x16, 0x3e, 0x86, 0x89, 0x2f, 0xc2, 0x12, 0x77, 0xae, 0x26,
        0x5a, 0xde, 0xa0, 0x4f, 0x60, 0xe6, 0x0f, 0x0d, 0xb9, 0x61, 0x37, 0x33, 0xe7, 0x77, 0xce, 0xf7,
        0xe5, 0x64, 0xc0, 0xf3, 0x90, 0x27, 0xcb, 0xe8, 0xbb, 0x47, 0x8b, 0x22, 0x2a, 0xbd, 0xdd, 0x24,
        0x88, 0x4a, 0x3a, 0xf1, 0x32, 0x9a, 0xd3, 0xa4, 0x70, 0xb3, 0x9c, 0x97, 0xdc, 0x19, 0x6a, 0xc4,
        0x55, 0x88, 0x6b, 0x90, 0xa7, 0xc3, 0x35, 0x5f, 0x73, 0x05, 0x78, 0xf2, 0xa4, 0x59, 0xfc, 0x05,
        0x74, 0xe7, 0xfe, 0xec, 0x93, 0xb2, 0x3b, 0x2f, 0xc0, 0x6d, 0xc6, 0xf3, 0x72, 0x6c, 0x3f, 0xb3,
        0x5f, 0x75, 0xfd, 0x47, 0xb5, 0x40, 0xbd, 0x3d, 0x4d, 0xe2, 0xf7, 0x58, 0xbe, 0x62, 0xa2, 0x44,
        0xe7, 0x35, 0xb8, 0xbf, 0x8b, 0xf2, 0x82, 0xf1, 0x74, 0x7c, 0xa3, 0x38, 0xa7, 0x16, 0xe8, 0xa1,
        0xe6, 0x8c, 0x80, 0xc9, 0x19, 0xc1, 0xbf, 0x6c, 0xd0, 0xff, 0x98, 0xd3, 0x30, 0x8e, 0xcc, 0x8c,
        0x09, 0xe8, 0xd2, 0x62, 0xf3, 0x35, 0xe4, 0xdb, 0x54, 0x0f, 0xba, 0xf5, 0x87, 0xb5, 0x40, 0x03,
        0x1d, 0xd0, 0x48, 0x98, 0x74, 0x68, 0xb1, 0x99, 0xc9, 0xa3, 0xb4, 0x24, 0x2c, 0x35, 0x96, 0x9b,
        0xbb, 0x96, 0x46, 0xc2, 0xa4, 0x93, 0xb0, 0x54, 0x5b, 0xde, 0x01, 0x90, 0x6c, 0xe3, 0x92, 0x65,
        0x31, 0x8b, 0xf2, 0x71, 0x4b, 0x79, 0x46, 0xb5, 0x40, 0x8f, 0x8d, 0xa7, 0xd1, 0x30, 0xb9, 0x00,
        0xf1, 0x6f, 0x1b, 0xb4, 0xcd, 0x9e, 0x2f, 0xc1, 0x3d, 0xba, 0x4c, 0x58, 0x6a, 0xca, 0x18, 0xd4,
        0x02, 0xf5, 0xcd, 0x8e, 0xf2, 0x19, 0x13, 0x2d, 0x3b, 0x1f, 0x40, 0x8b, 0x05, 0xa1, 0x5a, 0xab,
        0x37, 0x45, 0xee, 0xb5, 0xea, 0xdd, 0xa6, 0x61, 0xff, 0xc9, 0x41, 0x20, 0xab, 0x12, 0xa8, 0x35,
        0xf7, 0x67, 0xb5, 0x40, 0x40, 0x27, 0xb2, 0x20, 0xc4, 0x44, 0xc6, 0x38, 0x0b, 0xd0, 0xe6, 0xaa,
        0x2d, 0xb5, 0x73, 0x6f, 0x8a, 0xaf, 0x07, 0x5e, 0x36, 0xea, 0x8f, 0x64, 0x66, 0x2d, 0xd0, 0x03,
        0x1d, 0xa6, 0xfd, 0x98, 0x98, 0x20, 0x7f, 0x71, 0xf8, 0x07, 0xad, 0x9f, 0x15, 0xb4, 0x0e, 0x15,
        0xb4, 0x8f, 0x15, 0xb4, 0xff, 0x56, 0xd0, 0xfe, 0x71, 0x82, 0xd6, 0xf1, 0x04, 0xad, 0x3f, 0x27,
        0x68, 0x7d, 0xf6, 0xd6, 0xac, 0xfc, 0xb6, 0x0d, 0xe4, 0x28, 0x4f, 0x8f, 0x7b, 0xc3, 0x57, 0x2b,
        0x16, 0x32, 0x1a, 0x9b, 0xbb, 0x77, 0xfe, 0x6f, 0xe5, 0x3e, 0x8b, 0x8a, 0xa0, 0xad, 0xfe, 0xce,
        0xdb, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd8, 0x5a, 0x97, 0xc6, 0x8c, 0x02, 0x00, 0x00,
}

func (m *IBCParams) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *IBCParams) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *IBCParams) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Version) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Version)
                copy(dAtA[i:], m.Version)
                i = encodeVarintParams(dAtA, i, uint64(len(m.Version)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Port) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Port)
                copy(dAtA[i:], m.Port)
                i = encodeVarintParams(dAtA, i, uint64(len(m.Port)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *OracleParams) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *OracleParams) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *OracleParams) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Multiplier != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.Multiplier))
                i--
                dAtA[i] = 0x18
        }</span>
        <span class="cov0" title="0">if m.MinCount != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.MinCount))
                i--
                dAtA[i] = 0x10
        }</span>
        <span class="cov0" title="0">if m.AskCount != 0 </span><span class="cov0" title="0">{
                i = encodeVarintParams(dAtA, i, uint64(m.AskCount))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *Params) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Oracle.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintParams(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        </span><span class="cov0" title="0">{
                size, err := m.IBC.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintParams(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.Admin) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Admin)
                copy(dAtA[i:], m.Admin)
                i = encodeVarintParams(dAtA, i, uint64(len(m.Admin)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovParams(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *IBCParams) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Port)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovParams(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Version)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovParams(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *OracleParams) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.AskCount != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.AskCount))
        }</span>
        <span class="cov0" title="0">if m.MinCount != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.MinCount))
        }</span>
        <span class="cov0" title="0">if m.Multiplier != 0 </span><span class="cov0" title="0">{
                n += 1 + sovParams(uint64(m.Multiplier))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *Params) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Admin)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovParams(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.IBC.Size()
        n += 1 + l + sovParams(uint64(l))
        l = m.Oracle.Size()
        n += 1 + l + sovParams(uint64(l))
        return n</span>
}

func sovParams(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozParams(x uint64) (n int) <span class="cov0" title="0">{
        return sovParams(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *IBCParams) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: IBCParams: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: IBCParams: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Port = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Version = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *OracleParams) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: OracleParams: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: OracleParams: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field AskCount", wireType)
                        }</span>
                        <span class="cov0" title="0">m.AskCount = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.AskCount |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field MinCount", wireType)
                        }</span>
                        <span class="cov0" title="0">m.MinCount = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.MinCount |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Multiplier = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Multiplier |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *Params) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Admin = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field IBC", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.IBC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Oracle", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Oracle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipParams(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupParams
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthParams
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/asset/v1beta1/querier.proto

package types

import (
        context "context"
        fmt "fmt"
        query "github.com/cosmos/cosmos-sdk/types/query"
        _ "github.com/gogo/protobuf/gogoproto"
        grpc1 "github.com/gogo/protobuf/grpc"
        proto "github.com/gogo/protobuf/proto"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type QueryAssetsRequest struct {
        Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryAssetsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryAssetsRequest{} }</span>
func (m *QueryAssetsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryAssetsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryAssetsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{0}
}</span>
func (m *QueryAssetsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryAssetsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryAssetsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryAssetsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetsRequest.Merge(m, src)
}</span>
func (m *QueryAssetsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryAssetsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryAssetsRequest proto.InternalMessageInfo

type QueryAssetsResponse struct {
        Assets     []Asset             `protobuf:"bytes,1,rep,name=assets,proto3" json:"assets" yaml:"assets"`
        Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryAssetsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryAssetsResponse{} }</span>
func (m *QueryAssetsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryAssetsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryAssetsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{1}
}</span>
func (m *QueryAssetsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryAssetsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryAssetsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryAssetsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetsResponse.Merge(m, src)
}</span>
func (m *QueryAssetsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryAssetsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryAssetsResponse proto.InternalMessageInfo

type QueryAssetRequest struct {
        Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *QueryAssetRequest) Reset()         <span class="cov0" title="0">{ *m = QueryAssetRequest{} }</span>
func (m *QueryAssetRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryAssetRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryAssetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{2}
}</span>
func (m *QueryAssetRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryAssetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryAssetRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryAssetRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetRequest.Merge(m, src)
}</span>
func (m *QueryAssetRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryAssetRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryAssetRequest proto.InternalMessageInfo

type QueryAssetResponse struct {
        Asset Asset `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset" yaml:"asset"`
}

func (m *QueryAssetResponse) Reset()         <span class="cov0" title="0">{ *m = QueryAssetResponse{} }</span>
func (m *QueryAssetResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryAssetResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryAssetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{3}
}</span>
func (m *QueryAssetResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryAssetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryAssetResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryAssetResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetResponse.Merge(m, src)
}</span>
func (m *QueryAssetResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryAssetResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryAssetResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryAssetResponse proto.InternalMessageInfo

type QueryMarketsRequest struct {
        Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryMarketsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryMarketsRequest{} }</span>
func (m *QueryMarketsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryMarketsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryMarketsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{4}
}</span>
func (m *QueryMarketsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryMarketsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryMarketsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryMarketsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryMarketsRequest.Merge(m, src)
}</span>
func (m *QueryMarketsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryMarketsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryMarketsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryMarketsRequest proto.InternalMessageInfo

type QueryMarketsResponse struct {
        Markets    []Market            `protobuf:"bytes,1,rep,name=markets,proto3" json:"markets" yaml:"markets"`
        Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryMarketsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryMarketsResponse{} }</span>
func (m *QueryMarketsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryMarketsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryMarketsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{5}
}</span>
func (m *QueryMarketsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryMarketsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryMarketsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryMarketsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryMarketsResponse.Merge(m, src)
}</span>
func (m *QueryMarketsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryMarketsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryMarketsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryMarketsResponse proto.InternalMessageInfo

type QueryMarketRequest struct {
        Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty" yaml:"symbol"`
}

func (m *QueryMarketRequest) Reset()         <span class="cov0" title="0">{ *m = QueryMarketRequest{} }</span>
func (m *QueryMarketRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryMarketRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryMarketRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{6}
}</span>
func (m *QueryMarketRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryMarketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryMarketRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryMarketRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryMarketRequest.Merge(m, src)
}</span>
func (m *QueryMarketRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryMarketRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryMarketRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryMarketRequest proto.InternalMessageInfo

type QueryMarketResponse struct {
        Market Market `protobuf:"bytes,1,opt,name=market,proto3" json:"market" yaml:"market"`
}

func (m *QueryMarketResponse) Reset()         <span class="cov0" title="0">{ *m = QueryMarketResponse{} }</span>
func (m *QueryMarketResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryMarketResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryMarketResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{7}
}</span>
func (m *QueryMarketResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryMarketResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryMarketResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryMarketResponse.Merge(m, src)
}</span>
func (m *QueryMarketResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryMarketResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryMarketResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryMarketResponse proto.InternalMessageInfo

type QueryPairsRequest struct {
        Pagination *query.PageRequest `protobuf:"bytes,1,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryPairsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryPairsRequest{} }</span>
func (m *QueryPairsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryPairsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryPairsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{8}
}</span>
func (m *QueryPairsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryPairsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryPairsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryPairsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairsRequest.Merge(m, src)
}</span>
func (m *QueryPairsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryPairsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryPairsRequest proto.InternalMessageInfo

type QueryPairsResponse struct {
        Pairs      []Pair              `protobuf:"bytes,1,rep,name=pairs,proto3" json:"pairs" yaml:"pairs"`
        Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryPairsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryPairsResponse{} }</span>
func (m *QueryPairsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryPairsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryPairsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{9}
}</span>
func (m *QueryPairsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryPairsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryPairsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryPairsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairsResponse.Merge(m, src)
}</span>
func (m *QueryPairsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryPairsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryPairsResponse proto.InternalMessageInfo

type QueryPairRequest struct {
        Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *QueryPairRequest) Reset()         <span class="cov0" title="0">{ *m = QueryPairRequest{} }</span>
func (m *QueryPairRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryPairRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryPairRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{10}
}</span>
func (m *QueryPairRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryPairRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryPairRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryPairRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairRequest.Merge(m, src)
}</span>
func (m *QueryPairRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryPairRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryPairRequest proto.InternalMessageInfo

type QueryPairResponse struct {
        Pair Pair `protobuf:"bytes,1,opt,name=pair,proto3" json:"pair" yaml:"pair"`
}

func (m *QueryPairResponse) Reset()         <span class="cov0" title="0">{ *m = QueryPairResponse{} }</span>
func (m *QueryPairResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryPairResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryPairResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{11}
}</span>
func (m *QueryPairResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryPairResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryPairResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryPairResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairResponse.Merge(m, src)
}</span>
func (m *QueryPairResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryPairResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryPairResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryPairResponse proto.InternalMessageInfo

type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryParamsRequest{} }</span>
func (m *QueryParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{12}
}</span>
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}</span>
func (m *QueryParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

type QueryParamsResponse struct {
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params" yaml:"params"`
}

func (m *QueryParamsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryParamsResponse{} }</span>
func (m *QueryParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_00878c412a69d054, []int{13}
}</span>
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}</span>
func (m *QueryParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryAssetsRequest)(nil), "comdex.asset.v1beta1.QueryAssetsRequest")
        proto.RegisterType((*QueryAssetsResponse)(nil), "comdex.asset.v1beta1.QueryAssetsResponse")
        proto.RegisterType((*QueryAssetRequest)(nil), "comdex.asset.v1beta1.QueryAssetRequest")
        proto.RegisterType((*QueryAssetResponse)(nil), "comdex.asset.v1beta1.QueryAssetResponse")
        proto.RegisterType((*QueryMarketsRequest)(nil), "comdex.asset.v1beta1.QueryMarketsRequest")
        proto.RegisterType((*QueryMarketsResponse)(nil), "comdex.asset.v1beta1.QueryMarketsResponse")
        proto.RegisterType((*QueryMarketRequest)(nil), "comdex.asset.v1beta1.QueryMarketRequest")
        proto.RegisterType((*QueryMarketResponse)(nil), "comdex.asset.v1beta1.QueryMarketResponse")
        proto.RegisterType((*QueryPairsRequest)(nil), "comdex.asset.v1beta1.QueryPairsRequest")
        proto.RegisterType((*QueryPairsResponse)(nil), "comdex.asset.v1beta1.QueryPairsResponse")
        proto.RegisterType((*QueryPairRequest)(nil), "comdex.asset.v1beta1.QueryPairRequest")
        proto.RegisterType((*QueryPairResponse)(nil), "comdex.asset.v1beta1.QueryPairResponse")
        proto.RegisterType((*QueryParamsRequest)(nil), "comdex.asset.v1beta1.QueryParamsRequest")
        proto.RegisterType((*QueryParamsResponse)(nil), "comdex.asset.v1beta1.QueryParamsResponse")
}</span>

func init() <span class="cov8" title="1">{
        proto.RegisterFile("comdex/asset/v1beta1/querier.proto", fileDescriptor_00878c412a69d054)
}</span>

var fileDescriptor_00878c412a69d054 = []byte{
        // 831 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x41, 0x4f, 0x13, 0x4d,
        0x18, 0xee, 0xf6, 0x83, 0x12, 0xa6, 0x7c, 0xe4, 0x63, 0x28, 0x5f, 0x48, 0x81, 0x6d, 0x19, 0x14,
        0x5a, 0x12, 0x77, 0x03, 0xde, 0xbc, 0x18, 0x6b, 0xa2, 0x89, 0x46, 0x03, 0xeb, 0xc5, 0x98, 0x60,
        0x32, 0x6d, 0x87, 0xba, 0xb1, 0xed, 0x94, 0x9d, 0x85, 0xd8, 0x10, 0x2e, 0xc6, 0x18, 0x63, 0x3c,
        0x18, 0xfd, 0x13, 0xfe, 0x08, 0x2f, 0x5e, 0x0c, 0x47, 0x12, 0x2f, 0x9e, 0x88, 0x16, 0xfd, 0x03,
        0xfc, 0x02, 0xb3, 0x33, 0xef, 0x6e, 0x77, 0x71, 0xd9, 0xf6, 0x02, 0xb7, 0xcd, 0xec, 0xfb, 0xbc,
        0xef, 0xf3, 0x3c, 0xef, 0x3b, 0xef, 0x2e, 0x22, 0x35, 0xde, 0xaa, 0xb3, 0x17, 0x26, 0x15, 0x82,
        0xb9, 0xe6, 0xde, 0x5a, 0x95, 0xb9, 0x74, 0xcd, 0xdc, 0xd9, 0x65, 0x8e, 0xcd, 0x1c, 0xa3, 0xe3,
        0x70, 0x97, 0xe3, 0x9c, 0x8a, 0x31, 0x64, 0x8c, 0x01, 0x31, 0xf9, 0xd5, 0x1a, 0x17, 0x2d, 0x2e,
        0xcc, 0x2a, 0x15, 0x4c, 0x02, 0xba, 0x01, 0xbc, 0x43, 0x1b, 0x76, 0x9b, 0xba, 0x36, 0x6f, 0xab,
        0x0c, 0xf9, 0x5c, 0x83, 0x37, 0xb8, 0x7c, 0x34, 0xbd, 0x27, 0x38, 0x9d, 0x6f, 0x70, 0xde, 0x68,
        0x32, 0x93, 0x76, 0x6c, 0x93, 0xb6, 0xdb, 0xdc, 0x95, 0x10, 0x01, 0x6f, 0x8b, 0xb1, 0xcc, 0x14,
        0x07, 0x15, 0xb1, 0x18, 0x1b, 0xc1, 0x1d, 0x5a, 0x6b, 0x32, 0x08, 0x29, 0xc4, 0x86, 0x74, 0xa8,
        0xed, 0x24, 0xe6, 0xe8, 0x50, 0x87, 0xb6, 0x80, 0x08, 0x11, 0x08, 0x6f, 0x7a, 0xf2, 0x6e, 0x79,
        0x21, 0xc2, 0x62, 0x3b, 0xbb, 0x4c, 0xb8, 0x78, 0x0b, 0xa1, 0xbe, 0xcc, 0x59, 0xad, 0xa8, 0x95,
        0xb2, 0xeb, 0xcb, 0x86, 0xf2, 0xc4, 0xf0, 0x3c, 0x31, 0xa4, 0x27, 0xbe, 0x5d, 0xc6, 0x06, 0x6d,
        0x30, 0xc0, 0x56, 0x66, 0x4e, 0x8f, 0x0b, 0x53, 0x5d, 0xda, 0x6a, 0xde, 0x20, 0xfd, 0x1c, 0xc4,
        0x0a, 0x25, 0x24, 0x5f, 0x34, 0x34, 0x1d, 0xa9, 0x2a, 0x3a, 0xbc, 0x2d, 0x18, 0xbe, 0x87, 0x32,
        0x92, 0xaa, 0x98, 0xd5, 0x8a, 0xff, 0x94, 0xb2, 0xeb, 0x73, 0x46, 0x5c, 0x73, 0x0c, 0x89, 0xaa,
        0xcc, 0x1c, 0x1e, 0x17, 0x52, 0xa7, 0xc7, 0x85, 0x7f, 0x55, 0x2d, 0x05, 0x24, 0x16, 0x64, 0xc0,
        0x4f, 0x23, 0x12, 0xd2, 0x52, 0xc2, 0xca, 0x40, 0x09, 0x8a, 0xc8, 0x30, 0x1a, 0x96, 0xd0, 0x54,
        0x5f, 0x82, 0xef, 0xdb, 0x24, 0x4a, 0xdb, 0x75, 0xe9, 0xd7, 0x88, 0x95, 0xb6, 0xeb, 0x64, 0x2b,
        0xec, 0x6e, 0x20, 0xf3, 0x2e, 0x1a, 0x95, 0x24, 0xc1, 0xd8, 0x44, 0x95, 0x39, 0x50, 0x39, 0x11,
        0x52, 0x49, 0x2c, 0x85, 0x27, 0x2e, 0xd8, 0xf8, 0x80, 0x3a, 0xcf, 0x2f, 0xaf, 0x7b, 0x5f, 0x35,
        0x94, 0x8b, 0x96, 0x05, 0x5d, 0x0f, 0xd1, 0x58, 0x4b, 0x1d, 0x41, 0xff, 0xe6, 0xe3, 0x95, 0x29,
        0x5c, 0xe5, 0x7f, 0x90, 0x36, 0xa9, 0xca, 0x01, 0x94, 0x58, 0x7e, 0x92, 0x0b, 0x6f, 0xe1, 0x4d,
        0xe8, 0x8e, 0xe2, 0xe3, 0xbb, 0x57, 0x46, 0x19, 0xd1, 0x6d, 0x55, 0x79, 0x53, 0x3a, 0x37, 0x5e,
        0x99, 0xea, 0xcf, 0x98, 0x3a, 0x27, 0x16, 0x04, 0x90, 0x6a, 0xc4, 0xff, 0xc0, 0x87, 0xfb, 0x28,
        0xa3, 0x24, 0x80, 0xf7, 0xc9, 0x36, 0x9c, 0x99, 0x63, 0x85, 0x24, 0x16, 0xa4, 0x20, 0x0e, 0xcc,
        0xd9, 0x06, 0xb5, 0x9d, 0xcb, 0xea, 0xf0, 0x67, 0x0d, 0x9c, 0x81, 0xa2, 0xa0, 0xeb, 0x0e, 0x1a,
        0xf5, 0x96, 0x8b, 0xdf, 0xdd, 0x7c, 0xbc, 0x2c, 0x0f, 0x73, 0x76, 0x6c, 0x25, 0x8c, 0x58, 0x0a,
        0x7e, 0xe1, 0x7d, 0x25, 0xe8, 0xbf, 0x80, 0xfd, 0x79, 0x37, 0xf3, 0x71, 0xc8, 0xd6, 0x40, 0xe0,
        0x6d, 0x34, 0xe2, 0x31, 0x04, 0x43, 0x93, 0xf4, 0x4d, 0x83, 0xbe, 0x6c, 0x5f, 0x1f, 0xb1, 0x24,
        0x98, 0xe4, 0x02, 0xef, 0xbc, 0x35, 0x0b, 0xf5, 0x83, 0x51, 0xf1, 0x4f, 0xfb, 0xa3, 0xa2, 0xd6,
        0x71, 0xf2, 0xa8, 0x28, 0xd4, 0xd9, 0x51, 0x51, 0x48, 0x62, 0x41, 0x8a, 0xf5, 0xdf, 0x63, 0x68,
        0x42, 0x16, 0x79, 0xc4, 0x9c, 0x3d, 0xbb, 0xc6, 0xf0, 0x1b, 0x0d, 0x65, 0x43, 0x7b, 0x16, 0x97,
        0xe2, 0xb3, 0xff, 0xfd, 0x01, 0xc8, 0x97, 0x87, 0x88, 0x54, 0x12, 0xc8, 0x95, 0x97, 0xdf, 0x7e,
        0x7d, 0x4c, 0xeb, 0x78, 0xde, 0x3c, 0xff, 0x9b, 0x26, 0xf0, 0x5b, 0x0d, 0xa1, 0x3e, 0x1a, 0xaf,
        0x0c, 0xca, 0xef, 0x13, 0x29, 0x0d, 0x0e, 0x04, 0x1e, 0x65, 0xc9, 0x63, 0x09, 0x2f, 0x26, 0xf1,
        0x30, 0xf7, 0xed, 0xfa, 0x01, 0x7e, 0xa7, 0x81, 0x51, 0xb0, 0xc1, 0x70, 0x92, 0xdc, 0xe8, 0x72,
        0xcd, 0xaf, 0x0e, 0x13, 0x0a, 0x94, 0xae, 0x4a, 0x4a, 0x05, 0xbc, 0x10, 0x4f, 0xc9, 0xdf, 0x73,
        0x1f, 0xfc, 0x36, 0x29, 0x7c, 0x62, 0x9b, 0x22, 0xbb, 0x2a, 0x5f, 0x1e, 0x22, 0x12, 0xb8, 0x18,
        0x92, 0x4b, 0x09, 0x2f, 0x27, 0x72, 0x31, 0xf7, 0xd5, 0x6a, 0x3b, 0xc0, 0xaf, 0xfc, 0x86, 0xc9,
        0x1d, 0x90, 0xd8, 0xb0, 0xf0, 0x6a, 0x4a, 0x6c, 0x58, 0x64, 0x9d, 0x90, 0x25, 0xc9, 0x68, 0x01,
        0xcf, 0x99, 0xe7, 0xfe, 0xc7, 0x08, 0xfc, 0x5a, 0x43, 0xe3, 0x01, 0x16, 0x2f, 0x0f, 0x48, 0xee,
        0x93, 0x58, 0x19, 0x18, 0x07, 0x1c, 0x4a, 0x92, 0x03, 0xc1, 0xc5, 0x04, 0x0e, 0x6a, 0x66, 0x82,
        0xbb, 0xa4, 0xee, 0x22, 0x4e, 0xd6, 0x19, 0xba, 0xfa, 0x89, 0x4d, 0x8a, 0xae, 0x83, 0x41, 0x77,
        0x49, 0xdd, 0xf3, 0xca, 0xe6, 0xe1, 0x4f, 0x3d, 0xf5, 0xa9, 0xa7, 0xa7, 0x0e, 0x7b, 0xba, 0x76,
        0xd4, 0xd3, 0xb5, 0x1f, 0x3d, 0x5d, 0x7b, 0x7f, 0xa2, 0xa7, 0x8e, 0x4e, 0xf4, 0xd4, 0xf7, 0x13,
        0x3d, 0xf5, 0xc4, 0x6c, 0xd8, 0xee, 0xb3, 0xdd, 0xaa, 0x57, 0x18, 0x32, 0x5d, 0xe3, 0xdb, 0xdb,
        0x76, 0xcd, 0xa6, 0x4d, 0x3f, 0xb3, 0x9f, 0xdb, 0xed, 0x76, 0x98, 0xa8, 0x66, 0xe4, 0xdf, 0xe0,
        0xf5, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x5f, 0x8f, 0x92, 0x7b, 0x32, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
        QueryAssets(ctx context.Context, in *QueryAssetsRequest, opts ...grpc.CallOption) (*QueryAssetsResponse, error)
        QueryAsset(ctx context.Context, in *QueryAssetRequest, opts ...grpc.CallOption) (*QueryAssetResponse, error)
        QueryMarkets(ctx context.Context, in *QueryMarketsRequest, opts ...grpc.CallOption) (*QueryMarketsResponse, error)
        QueryMarket(ctx context.Context, in *QueryMarketRequest, opts ...grpc.CallOption) (*QueryMarketResponse, error)
        QueryPairs(ctx context.Context, in *QueryPairsRequest, opts ...grpc.CallOption) (*QueryPairsResponse, error)
        QueryPair(ctx context.Context, in *QueryPairRequest, opts ...grpc.CallOption) (*QueryPairResponse, error)
        QueryParams(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
}

type queryServiceClient struct {
        cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient <span class="cov0" title="0">{
        return &amp;queryServiceClient{cc}
}</span>

func (c *queryServiceClient) QueryAssets(ctx context.Context, in *QueryAssetsRequest, opts ...grpc.CallOption) (*QueryAssetsResponse, error) <span class="cov0" title="0">{
        out := new(QueryAssetsResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryAssets", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryAsset(ctx context.Context, in *QueryAssetRequest, opts ...grpc.CallOption) (*QueryAssetResponse, error) <span class="cov0" title="0">{
        out := new(QueryAssetResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryAsset", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryMarkets(ctx context.Context, in *QueryMarketsRequest, opts ...grpc.CallOption) (*QueryMarketsResponse, error) <span class="cov0" title="0">{
        out := new(QueryMarketsResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryMarkets", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryMarket(ctx context.Context, in *QueryMarketRequest, opts ...grpc.CallOption) (*QueryMarketResponse, error) <span class="cov0" title="0">{
        out := new(QueryMarketResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryMarket", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryPairs(ctx context.Context, in *QueryPairsRequest, opts ...grpc.CallOption) (*QueryPairsResponse, error) <span class="cov0" title="0">{
        out := new(QueryPairsResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryPairs", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryPair(ctx context.Context, in *QueryPairRequest, opts ...grpc.CallOption) (*QueryPairResponse, error) <span class="cov0" title="0">{
        out := new(QueryPairResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryPair", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryParams(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryParamsResponse)
        err := c.cc.Invoke(ctx, "/comdex.asset.v1beta1.QueryService/QueryParams", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
        QueryAssets(context.Context, *QueryAssetsRequest) (*QueryAssetsResponse, error)
        QueryAsset(context.Context, *QueryAssetRequest) (*QueryAssetResponse, error)
        QueryMarkets(context.Context, *QueryMarketsRequest) (*QueryMarketsResponse, error)
        QueryMarket(context.Context, *QueryMarketRequest) (*QueryMarketResponse, error)
        QueryPairs(context.Context, *QueryPairsRequest) (*QueryPairsResponse, error)
        QueryPair(context.Context, *QueryPairRequest) (*QueryPairResponse, error)
        QueryParams(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) QueryAssets(ctx context.Context, req *QueryAssetsRequest) (*QueryAssetsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryAssets not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryAsset(ctx context.Context, req *QueryAssetRequest) (*QueryAssetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryAsset not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryMarkets(ctx context.Context, req *QueryMarketsRequest) (*QueryMarketsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryMarkets not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryMarket(ctx context.Context, req *QueryMarketRequest) (*QueryMarketResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryMarket not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryPairs(ctx context.Context, req *QueryPairsRequest) (*QueryPairsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryPairs not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryPair(ctx context.Context, req *QueryPairRequest) (*QueryPairResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryPair not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryParams(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryParams not implemented")
}</span>

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_QueryService_serviceDesc, srv)
}</span>

func _QueryService_QueryAssets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryAssetsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryAssets(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryAssets",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryAssets(ctx, req.(*QueryAssetsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryAssetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryAsset(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryAsset",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryAsset(ctx, req.(*QueryAssetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryMarkets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryMarketsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryMarkets(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryMarkets",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryMarkets(ctx, req.(*QueryMarketsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryMarketRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryMarket(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryMarket",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryMarket(ctx, req.(*QueryMarketRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryPairsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryPairs(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryPairs",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryPairs(ctx, req.(*QueryPairsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryPair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryPairRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryPair(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryPair",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryPair(ctx, req.(*QueryPairRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryParams(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.asset.v1beta1.QueryService/QueryParams",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryParams(ctx, req.(*QueryParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
        ServiceName: "comdex.asset.v1beta1.QueryService",
        HandlerType: (*QueryServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "QueryAssets",
                        Handler:    _QueryService_QueryAssets_Handler,
                },
                {
                        MethodName: "QueryAsset",
                        Handler:    _QueryService_QueryAsset_Handler,
                },
                {
                        MethodName: "QueryMarkets",
                        Handler:    _QueryService_QueryMarkets_Handler,
                },
                {
                        MethodName: "QueryMarket",
                        Handler:    _QueryService_QueryMarket_Handler,
                },
                {
                        MethodName: "QueryPairs",
                        Handler:    _QueryService_QueryPairs_Handler,
                },
                {
                        MethodName: "QueryPair",
                        Handler:    _QueryService_QueryPair_Handler,
                },
                {
                        MethodName: "QueryParams",
                        Handler:    _QueryService_QueryParams_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "comdex/asset/v1beta1/querier.proto",
}

func (m *QueryAssetsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryAssetsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryAssetsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryAssetsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryAssetsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryAssetsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.Assets) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Assets) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryAssetRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryAssetRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryAssetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuerier(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryAssetResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryAssetResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryAssetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Asset.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryMarketsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryMarketsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryMarketsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryMarketsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryMarketsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryMarketsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.Markets) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Markets) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Markets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryMarketRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryMarketRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryMarketRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Symbol) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Symbol)
                copy(dAtA[i:], m.Symbol)
                i = encodeVarintQuerier(dAtA, i, uint64(len(m.Symbol)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryMarketResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryMarketResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Market.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryPairsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryPairsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryPairsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0xa</span>
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryPairsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryPairsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryPairsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov0" title="0">i -= size
                        i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                }
                <span class="cov0" title="0">i--
                dAtA[i] = 0x12</span>
        }
        <span class="cov0" title="0">if len(m.Pairs) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Pairs) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Pairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryPairRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryPairRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryPairRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuerier(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryPairResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryPairResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryPairResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Pair.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuerier(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintQuerier(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQuerier(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryAssetsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryAssetsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Assets) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Assets </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuerier(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryAssetRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuerier(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryAssetResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Asset.Size()
        n += 1 + l + sovQuerier(uint64(l))
        return n</span>
}

func (m *QueryMarketsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryMarketsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Markets) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Markets </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuerier(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryMarketRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Symbol)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryMarketResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Market.Size()
        n += 1 + l + sovQuerier(uint64(l))
        return n</span>
}

func (m *QueryPairsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryPairsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Pairs) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Pairs </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuerier(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">if m.Pagination != nil </span><span class="cov0" title="0">{
                l = m.Pagination.Size()
                n += 1 + l + sovQuerier(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryPairRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuerier(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryPairResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Pair.Size()
        n += 1 + l + sovQuerier(uint64(l))
        return n</span>
}

func (m *QueryParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovQuerier(uint64(l))
        return n</span>
}

func sovQuerier(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQuerier(x uint64) (n int) <span class="cov0" title="0">{
        return sovQuerier(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryAssetsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageRequest{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryAssetsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Assets = append(m.Assets, Asset{})
                        if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageResponse{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryAssetRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryAssetResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryAssetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Asset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryMarketsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryMarketsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryMarketsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageRequest{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryMarketsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryMarketsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryMarketsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Markets", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Markets = append(m.Markets, Market{})
                        if err := m.Markets[len(m.Markets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageResponse{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryMarketRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryMarketRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryMarketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Symbol = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryMarketResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryMarketResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Market.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryPairsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageRequest{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryPairsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Pairs = append(m.Pairs, Pair{})
                        if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if m.Pagination == nil </span><span class="cov0" title="0">{
                                m.Pagination = &amp;query.PageResponse{}
                        }</span>
                        <span class="cov0" title="0">if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryPairRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryPairResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryPairResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Pair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuerier(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQuerier(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQuerier
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuerier
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQuerier
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQuerier
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQuerier
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQuerier        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQuerier          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQuerier = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: comdex/asset/v1beta1/querier.proto

/*
Package types is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package types

import (
        "context"
        "io"
        "net/http"

        "github.com/golang/protobuf/descriptor"
        "github.com/golang/protobuf/proto"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage
var _ = metadata.Join

var (
        filter_QueryService_QueryAssets_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

func request_QueryService_QueryAssets_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryAssetsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_QueryService_QueryAssets_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryAssets(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryAssets_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryAssetsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_QueryService_QueryAssets_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryAssets(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_QueryService_QueryAsset_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryAssetRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
        }</span>

        <span class="cov0" title="0">protoReq.Id, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryAsset(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryAsset_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryAssetRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
        }</span>

        <span class="cov0" title="0">protoReq.Id, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryAsset(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

var (
        filter_QueryService_QueryMarkets_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

func request_QueryService_QueryMarkets_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryMarketsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_QueryService_QueryMarkets_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryMarkets(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryMarkets_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryMarketsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_QueryService_QueryMarkets_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryMarkets(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_QueryService_QueryMarket_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryMarketRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["symbol"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "symbol")
        }</span>

        <span class="cov0" title="0">protoReq.Symbol, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "symbol", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryMarket(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryMarket_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryMarketRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["symbol"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "symbol")
        }</span>

        <span class="cov0" title="0">protoReq.Symbol, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "symbol", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryMarket(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

var (
        filter_QueryService_QueryPairs_0 = &amp;utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

func request_QueryService_QueryPairs_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryPairsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_QueryService_QueryPairs_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryPairs(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryPairs_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryPairsRequest
        var metadata runtime.ServerMetadata

        if err := req.ParseForm(); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>
        <span class="cov0" title="0">if err := runtime.PopulateQueryParameters(&amp;protoReq, req.Form, filter_QueryService_QueryPairs_0); err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryPairs(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_QueryService_QueryPair_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryPairRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
        }</span>

        <span class="cov0" title="0">protoReq.Id, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryPair(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryPair_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryPairRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
        }</span>

        <span class="cov0" title="0">protoReq.Id, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryPair(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_QueryService_QueryParams_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.QueryParams(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_QueryService_QueryParams_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.QueryParams(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

// RegisterQueryServiceHandlerServer registers the http handlers for service QueryService to "mux".
// UnaryRPC     :call QueryServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterQueryServiceHandlerFromEndpoint instead.
func RegisterQueryServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server QueryServiceServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_QueryService_QueryAssets_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryAssets_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryAssets_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryAsset_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryAsset_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryAsset_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryMarkets_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryMarkets_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryMarkets_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryMarket_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryMarket_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryMarket_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryPairs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryPairs_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryPairs_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryPair_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryPair_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryPair_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryParams_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryParams_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryParams_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterQueryServiceHandlerFromEndpoint is same as RegisterQueryServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterQueryServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterQueryServiceHandler(ctx, mux, conn)</span>
}

// RegisterQueryServiceHandler registers the http handlers for service QueryService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterQueryServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterQueryServiceHandlerClient(ctx, mux, NewQueryServiceClient(conn))
}</span>

// RegisterQueryServiceHandlerClient registers the http handlers for service QueryService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "QueryServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "QueryServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "QueryServiceClient" to call the correct interceptors.
func RegisterQueryServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client QueryServiceClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_QueryService_QueryAssets_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryAssets_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryAssets_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryAsset_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryAsset_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryAsset_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryMarkets_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryMarkets_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryMarkets_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryMarket_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryMarket_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryMarket_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryPairs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryPairs_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryPairs_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryPair_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryPair_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryPair_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryParams_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryParams_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryParams_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_QueryService_QueryAssets_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"comdex", "asset", "v1beta1", "assets"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryAsset_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"comdex", "asset", "v1beta1", "assets", "id"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryMarkets_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"comdex", "asset", "v1beta1", "markets"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryMarket_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"comdex", "asset", "v1beta1", "markets", "symbol"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryPairs_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"comdex", "asset", "v1beta1", "pairs"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryPair_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3, 1, 0, 4, 1, 5, 4}, []string{"comdex", "asset", "v1beta1", "pairs", "id"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryParams_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"comdex", "asset", "v1beta1", "params"}, "", runtime.AssumeColonVerbOpt(true)))
)

var (
        forward_QueryService_QueryAssets_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryAsset_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryMarkets_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryMarket_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryPairs_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryPair_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryParams_0 = runtime.ForwardResponseMessage
)
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
