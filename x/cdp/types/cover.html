
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>types: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/comdex-official/comdex/x/cdp/types/cdp.go (0.0%)</option>
				
				<option value="file1">github.com/comdex-official/comdex/x/cdp/types/cdp.pb.go (0.8%)</option>
				
				<option value="file2">github.com/comdex-official/comdex/x/cdp/types/codec.go (0.0%)</option>
				
				<option value="file3">github.com/comdex-official/comdex/x/cdp/types/events.pb.go (0.7%)</option>
				
				<option value="file4">github.com/comdex-official/comdex/x/cdp/types/genesis.go (100.0%)</option>
				
				<option value="file5">github.com/comdex-official/comdex/x/cdp/types/genesis.pb.go (1.0%)</option>
				
				<option value="file6">github.com/comdex-official/comdex/x/cdp/types/keys.go (66.7%)</option>
				
				<option value="file7">github.com/comdex-official/comdex/x/cdp/types/msg.go (26.7%)</option>
				
				<option value="file8">github.com/comdex-official/comdex/x/cdp/types/msg.pb.go (0.8%)</option>
				
				<option value="file9">github.com/comdex-official/comdex/x/cdp/types/params.go (66.7%)</option>
				
				<option value="file10">github.com/comdex-official/comdex/x/cdp/types/params.pb.go (0.8%)</option>
				
				<option value="file11">github.com/comdex-official/comdex/x/cdp/types/pricefeed.go (0.0%)</option>
				
				<option value="file12">github.com/comdex-official/comdex/x/cdp/types/query.pb.go (1.0%)</option>
				
				<option value="file13">github.com/comdex-official/comdex/x/cdp/types/query.pb.gw.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package types

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
)

func NewCDP(id uint64, owner sdk.AccAddress, collateral sdk.Coin, collateralType string, debt sdk.Coin) CDP <span class="cov0" title="0">{
        return CDP{
                Id:         id,
                Owner:      owner.String(),
                Type:       collateralType,
                Collateral: collateral,
                Debt:       debt,
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/cdp/v1alpha1/cdp.proto

package types

import (
        fmt "fmt"
        types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        _ "github.com/golang/protobuf/ptypes/timestamp"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CDP struct {
        Id         uint64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Owner      string     `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty" yaml:"owner"`
        Type       string     `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty" yaml:"type"`
        Collateral types.Coin `protobuf:"bytes,4,opt,name=collateral,proto3" json:"collateral" yaml:"collateral"`
        Debt       types.Coin `protobuf:"bytes,5,opt,name=debt,proto3" json:"debt" yaml:"debt"`
}

func (m *CDP) Reset()         <span class="cov0" title="0">{ *m = CDP{} }</span>
func (m *CDP) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CDP) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CDP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_79abe14dd4273326, []int{0}
}</span>
func (m *CDP) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CDP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CDP.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CDP) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CDP.Merge(m, src)
}</span>
func (m *CDP) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CDP) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CDP.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CDP proto.InternalMessageInfo

func (m *CDP) GetId() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CDP) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CDP) GetType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CDP) GetCollateral() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Collateral
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

func (m *CDP) GetDebt() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Debt
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

type OwnerCDPList struct {
        OwnedCDPs []OwnedCDP `protobuf:"bytes,1,rep,name=ownedCDPs,proto3" json:"ownedCDPs" yaml:"ownedCDP"`
}

func (m *OwnerCDPList) Reset()         <span class="cov0" title="0">{ *m = OwnerCDPList{} }</span>
func (m *OwnerCDPList) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*OwnerCDPList) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*OwnerCDPList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_79abe14dd4273326, []int{1}
}</span>
func (m *OwnerCDPList) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *OwnerCDPList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_OwnerCDPList.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *OwnerCDPList) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_OwnerCDPList.Merge(m, src)
}</span>
func (m *OwnerCDPList) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *OwnerCDPList) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_OwnerCDPList.DiscardUnknown(m)
}</span>

var xxx_messageInfo_OwnerCDPList proto.InternalMessageInfo

func (m *OwnerCDPList) GetOwnedCDPs() []OwnedCDP <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.OwnedCDPs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type OwnedCDP struct {
        Id             uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        CollateralType string `protobuf:"bytes,3,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty" yaml:"collateral_type"`
}

func (m *OwnedCDP) Reset()         <span class="cov0" title="0">{ *m = OwnedCDP{} }</span>
func (m *OwnedCDP) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*OwnedCDP) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*OwnedCDP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_79abe14dd4273326, []int{2}
}</span>
func (m *OwnedCDP) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *OwnedCDP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_OwnedCDP.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *OwnedCDP) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_OwnedCDP.Merge(m, src)
}</span>
func (m *OwnedCDP) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *OwnedCDP) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_OwnedCDP.DiscardUnknown(m)
}</span>

var xxx_messageInfo_OwnedCDP proto.InternalMessageInfo

func (m *OwnedCDP) GetId() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *OwnedCDP) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*CDP)(nil), "comdex.cdp.v1alpha1.CDP")
        proto.RegisterType((*OwnerCDPList)(nil), "comdex.cdp.v1alpha1.OwnerCDPList")
        proto.RegisterType((*OwnedCDP)(nil), "comdex.cdp.v1alpha1.OwnedCDP")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/cdp/v1alpha1/cdp.proto", fileDescriptor_79abe14dd4273326) }</span>

var fileDescriptor_79abe14dd4273326 = []byte{
        // 425 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x52, 0x41, 0x6b, 0xdb, 0x30,
        0x18, 0xb5, 0x12, 0x77, 0xac, 0x4a, 0x69, 0x36, 0x77, 0x6c, 0xae, 0xa1, 0xb6, 0xd1, 0x60, 0xf8,
        0x52, 0x89, 0x74, 0xb7, 0x1d, 0xed, 0xc0, 0x2e, 0x83, 0x06, 0x93, 0xd3, 0x2e, 0x41, 0xb6, 0x15,
        0x57, 0x60, 0x47, 0x26, 0x56, 0xbb, 0xe5, 0x5f, 0xec, 0x67, 0xf5, 0xd8, 0xe3, 0x4e, 0x66, 0x24,
        0xff, 0xc0, 0xe7, 0x1d, 0x86, 0x2c, 0x17, 0x97, 0x6d, 0xd0, 0x5b, 0xbe, 0xf7, 0xde, 0xf7, 0xf2,
        0xbd, 0x67, 0xc1, 0x8b, 0x54, 0x94, 0x19, 0xfb, 0x4e, 0xd2, 0xac, 0x22, 0x77, 0x33, 0x5a, 0x54,
        0x37, 0x74, 0xa6, 0x06, 0x5c, 0x6d, 0x85, 0x14, 0xd6, 0x99, 0xa6, 0xb1, 0x42, 0x1e, 0x69, 0xe7,
        0x4d, 0x2e, 0x72, 0xd1, 0xf1, 0x44, 0xfd, 0xd2, 0x52, 0xc7, 0xcb, 0x85, 0xc8, 0x0b, 0x46, 0xba,
        0x29, 0xb9, 0x5d, 0x13, 0xc9, 0x4b, 0x56, 0x4b, 0x5a, 0xf6, 0x5e, 0x8e, 0x9b, 0x8a, 0xba, 0x14,
        0x35, 0x49, 0x68, 0xcd, 0xc8, 0xdd, 0x2c, 0x61, 0x52, 0xfd, 0x95, 0xe0, 0x1b, 0xcd, 0xa3, 0xdf,
        0x00, 0x8e, 0xa3, 0xf9, 0xc2, 0x3a, 0x85, 0x23, 0x9e, 0xd9, 0xc0, 0x07, 0x81, 0x19, 0x8f, 0x78,
        0x66, 0x7d, 0x80, 0x47, 0xe2, 0xdb, 0x86, 0x6d, 0xed, 0x91, 0x0f, 0x82, 0xe3, 0xf0, 0x55, 0xdb,
        0x78, 0x27, 0x3b, 0x5a, 0x16, 0x9f, 0x50, 0x07, 0xa3, 0x58, 0xd3, 0xd6, 0x7b, 0x68, 0xca, 0x5d,
        0xc5, 0xec, 0x71, 0x27, 0x9b, 0xb6, 0x8d, 0x37, 0xd1, 0x32, 0x85, 0xa2, 0xb8, 0x23, 0xad, 0x25,
        0x84, 0xa9, 0x28, 0x0a, 0x2a, 0xd9, 0x96, 0x16, 0xb6, 0xe9, 0x83, 0x60, 0x72, 0x75, 0x8e, 0xf5,
        0x65, 0x58, 0x5d, 0x86, 0xfb, 0xcb, 0x70, 0x24, 0xf8, 0x26, 0x3c, 0xbf, 0x6f, 0x3c, 0xa3, 0x6d,
        0xbc, 0xd7, 0xda, 0x69, 0x58, 0x45, 0xf1, 0x13, 0x1f, 0x2b, 0x84, 0x66, 0xc6, 0x12, 0x69, 0x1f,
        0x3d, 0xe7, 0x77, 0xd6, 0xfb, 0xf5, 0x97, 0xa9, 0x25, 0x14, 0x77, 0xbb, 0x28, 0x83, 0x27, 0xd7,
        0x2a, 0x47, 0x34, 0x5f, 0x7c, 0xe1, 0xb5, 0xb4, 0x96, 0xf0, 0x58, 0xe5, 0xca, 0xa2, 0xf9, 0xa2,
        0xb6, 0x81, 0x3f, 0x0e, 0x26, 0x57, 0x17, 0xf8, 0x3f, 0x9f, 0x03, 0x5f, 0xf7, 0xaa, 0xf0, 0x5d,
        0x6f, 0x3e, 0x1d, 0xda, 0x51, 0x38, 0x8a, 0x07, 0x23, 0xb4, 0x82, 0x2f, 0x1f, 0xf5, 0xff, 0x14,
        0x1d, 0xc1, 0xe9, 0x90, 0x69, 0xf5, 0xa4, 0x4b, 0xa7, 0x6d, 0xbc, 0xb7, 0x7f, 0x37, 0xb0, 0xd2,
        0xb5, 0x9e, 0x0e, 0xc8, 0x72, 0x57, 0xb1, 0xf0, 0xf3, 0xfd, 0xde, 0x05, 0x0f, 0x7b, 0x17, 0xfc,
        0xda, 0xbb, 0xe0, 0xc7, 0xc1, 0x35, 0x1e, 0x0e, 0xae, 0xf1, 0xf3, 0xe0, 0x1a, 0x5f, 0x2f, 0x73,
        0x2e, 0x6f, 0x6e, 0x13, 0x95, 0x81, 0xe8, 0x1c, 0x97, 0x62, 0xbd, 0xe6, 0x29, 0xa7, 0x45, 0x3f,
        0x13, 0xfd, 0x0e, 0x95, 0x71, 0x9d, 0xbc, 0xe8, 0x5e, 0xc5, 0xc7, 0x3f, 0x01, 0x00, 0x00, 0xff,
        0xff, 0x91, 0x87, 0x6e, 0x9a, 0xa2, 0x02, 0x00, 0x00,
}

func (m *CDP) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *CDP) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CDP) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Debt.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintCdp(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x2a
        </span><span class="cov0" title="0">{
                size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintCdp(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if len(m.Type) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Type)
                copy(dAtA[i:], m.Type)
                i = encodeVarintCdp(dAtA, i, uint64(len(m.Type)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintCdp(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintCdp(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *OwnerCDPList) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *OwnerCDPList) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *OwnerCDPList) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.OwnedCDPs) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.OwnedCDPs) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.OwnedCDPs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintCdp(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *OwnedCDP) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *OwnedCDP) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *OwnedCDP) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintCdp(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintCdp(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintCdp(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovCdp(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *CDP) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovCdp(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCdp(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Type)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCdp(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Collateral.Size()
        n += 1 + l + sovCdp(uint64(l))
        l = m.Debt.Size()
        n += 1 + l + sovCdp(uint64(l))
        return n</span>
}

func (m *OwnerCDPList) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.OwnedCDPs) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.OwnedCDPs </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovCdp(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *OwnedCDP) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovCdp(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovCdp(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovCdp(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozCdp(x uint64) (n int) <span class="cov0" title="0">{
        return sovCdp(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *CDP) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCdp
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CDP: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CDP: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCdp
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCdp
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCdp
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Type = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCdp
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 5:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCdp
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Debt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCdp(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *OwnerCDPList) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCdp
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: OwnerCDPList: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: OwnerCDPList: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field OwnedCDPs", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCdp
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.OwnedCDPs = append(m.OwnedCDPs, OwnedCDP{})
                        if err := m.OwnedCDPs[len(m.OwnedCDPs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCdp(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *OwnedCDP) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowCdp
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: OwnedCDP: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: OwnedCDP: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCdp
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowCdp
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipCdp(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipCdp(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowCdp
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowCdp
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowCdp
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthCdp
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupCdp
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthCdp
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthCdp        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowCdp          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupCdp = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package types

import (
        "github.com/cosmos/cosmos-sdk/codec"
        cdctypes "github.com/cosmos/cosmos-sdk/codec/types"
        sdk "github.com/cosmos/cosmos-sdk/types"

        "github.com/cosmos/cosmos-sdk/types/msgservice"
)

func RegisterCodec(cdc *codec.LegacyAmino) {<span class="cov0" title="0">

}</span>

func RegisterInterfaces(registry cdctypes.InterfaceRegistry) <span class="cov0" title="0">{
        registry.RegisterImplementations(
                (*sdk.Msg)(nil),
                &amp;MsgCreateCDPRequest{},
                &amp;MsgDepositCollateralRequest{},
                &amp;MsgWithdrawCollateralRequest{},
                &amp;MsgDrawDebtRequest{},
                &amp;MsgRepayDebtRequest{},
                &amp;MsgLiquidateCDPRequest{},
        )

        msgservice.RegisterMsgServiceDesc(registry, &amp;_MsgService_serviceDesc)
}</span>

var (
        amino     = codec.NewLegacyAmino()
        ModuleCdc = codec.NewProtoCodec(cdctypes.NewInterfaceRegistry())
)
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/cdp/v1alpha1/events.proto

package types

import (
        fmt "fmt"
        types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EventCreateCDP struct {
        Sender         string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
        CollateralType string `protobuf:"bytes,2,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty"`
}

func (m *EventCreateCDP) Reset()         <span class="cov0" title="0">{ *m = EventCreateCDP{} }</span>
func (m *EventCreateCDP) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*EventCreateCDP) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*EventCreateCDP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_04ca7827fd5c462f, []int{0}
}</span>
func (m *EventCreateCDP) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *EventCreateCDP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_EventCreateCDP.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *EventCreateCDP) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_EventCreateCDP.Merge(m, src)
}</span>
func (m *EventCreateCDP) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *EventCreateCDP) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_EventCreateCDP.DiscardUnknown(m)
}</span>

var xxx_messageInfo_EventCreateCDP proto.InternalMessageInfo

func (m *EventCreateCDP) GetSender() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Sender
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EventCreateCDP) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type EventDepositCollateral struct {
        Owner          string     `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
        CollateralType string     `protobuf:"bytes,2,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty"`
        Collateral     types.Coin `protobuf:"bytes,3,opt,name=collateral,proto3" json:"collateral" yaml:"payment"`
}

func (m *EventDepositCollateral) Reset()         <span class="cov0" title="0">{ *m = EventDepositCollateral{} }</span>
func (m *EventDepositCollateral) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*EventDepositCollateral) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*EventDepositCollateral) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_04ca7827fd5c462f, []int{1}
}</span>
func (m *EventDepositCollateral) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *EventDepositCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_EventDepositCollateral.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *EventDepositCollateral) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_EventDepositCollateral.Merge(m, src)
}</span>
func (m *EventDepositCollateral) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *EventDepositCollateral) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_EventDepositCollateral.DiscardUnknown(m)
}</span>

var xxx_messageInfo_EventDepositCollateral proto.InternalMessageInfo

func (m *EventDepositCollateral) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EventDepositCollateral) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EventDepositCollateral) GetCollateral() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Collateral
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

type EventWithdrawCollateral struct {
        Owner          string     `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
        CollateralType string     `protobuf:"bytes,2,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty"`
        Collateral     types.Coin `protobuf:"bytes,3,opt,name=collateral,proto3" json:"collateral" yaml:"payment"`
}

func (m *EventWithdrawCollateral) Reset()         <span class="cov0" title="0">{ *m = EventWithdrawCollateral{} }</span>
func (m *EventWithdrawCollateral) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*EventWithdrawCollateral) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*EventWithdrawCollateral) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_04ca7827fd5c462f, []int{2}
}</span>
func (m *EventWithdrawCollateral) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *EventWithdrawCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_EventWithdrawCollateral.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *EventWithdrawCollateral) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_EventWithdrawCollateral.Merge(m, src)
}</span>
func (m *EventWithdrawCollateral) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *EventWithdrawCollateral) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_EventWithdrawCollateral.DiscardUnknown(m)
}</span>

var xxx_messageInfo_EventWithdrawCollateral proto.InternalMessageInfo

func (m *EventWithdrawCollateral) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EventWithdrawCollateral) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EventWithdrawCollateral) GetCollateral() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Collateral
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

type EventDrawDebt struct {
        Owner          string     `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
        CollateralType string     `protobuf:"bytes,2,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty"`
        Debt           types.Coin `protobuf:"bytes,3,opt,name=debt,proto3" json:"debt" yaml:"payment"`
}

func (m *EventDrawDebt) Reset()         <span class="cov0" title="0">{ *m = EventDrawDebt{} }</span>
func (m *EventDrawDebt) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*EventDrawDebt) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*EventDrawDebt) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_04ca7827fd5c462f, []int{3}
}</span>
func (m *EventDrawDebt) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *EventDrawDebt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_EventDrawDebt.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *EventDrawDebt) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_EventDrawDebt.Merge(m, src)
}</span>
func (m *EventDrawDebt) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *EventDrawDebt) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_EventDrawDebt.DiscardUnknown(m)
}</span>

var xxx_messageInfo_EventDrawDebt proto.InternalMessageInfo

func (m *EventDrawDebt) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EventDrawDebt) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EventDrawDebt) GetDebt() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Debt
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

type EventRepayDebt struct {
        Owner          string     `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
        CollateralType string     `protobuf:"bytes,2,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty"`
        Debt           types.Coin `protobuf:"bytes,3,opt,name=debt,proto3" json:"debt" yaml:"payment"`
}

func (m *EventRepayDebt) Reset()         <span class="cov0" title="0">{ *m = EventRepayDebt{} }</span>
func (m *EventRepayDebt) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*EventRepayDebt) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*EventRepayDebt) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_04ca7827fd5c462f, []int{4}
}</span>
func (m *EventRepayDebt) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *EventRepayDebt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_EventRepayDebt.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *EventRepayDebt) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_EventRepayDebt.Merge(m, src)
}</span>
func (m *EventRepayDebt) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *EventRepayDebt) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_EventRepayDebt.DiscardUnknown(m)
}</span>

var xxx_messageInfo_EventRepayDebt proto.InternalMessageInfo

func (m *EventRepayDebt) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EventRepayDebt) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EventRepayDebt) GetDebt() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Debt
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

type EventLiquidateCDP struct {
        Owner          string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
        CollateralType string `protobuf:"bytes,2,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty"`
}

func (m *EventLiquidateCDP) Reset()         <span class="cov0" title="0">{ *m = EventLiquidateCDP{} }</span>
func (m *EventLiquidateCDP) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*EventLiquidateCDP) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*EventLiquidateCDP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_04ca7827fd5c462f, []int{5}
}</span>
func (m *EventLiquidateCDP) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *EventLiquidateCDP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_EventLiquidateCDP.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *EventLiquidateCDP) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_EventLiquidateCDP.Merge(m, src)
}</span>
func (m *EventLiquidateCDP) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *EventLiquidateCDP) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_EventLiquidateCDP.DiscardUnknown(m)
}</span>

var xxx_messageInfo_EventLiquidateCDP proto.InternalMessageInfo

func (m *EventLiquidateCDP) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *EventLiquidateCDP) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*EventCreateCDP)(nil), "comdex.cdp.v1alpha1.EventCreateCDP")
        proto.RegisterType((*EventDepositCollateral)(nil), "comdex.cdp.v1alpha1.EventDepositCollateral")
        proto.RegisterType((*EventWithdrawCollateral)(nil), "comdex.cdp.v1alpha1.EventWithdrawCollateral")
        proto.RegisterType((*EventDrawDebt)(nil), "comdex.cdp.v1alpha1.EventDrawDebt")
        proto.RegisterType((*EventRepayDebt)(nil), "comdex.cdp.v1alpha1.EventRepayDebt")
        proto.RegisterType((*EventLiquidateCDP)(nil), "comdex.cdp.v1alpha1.EventLiquidateCDP")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/cdp/v1alpha1/events.proto", fileDescriptor_04ca7827fd5c462f) }</span>

var fileDescriptor_04ca7827fd5c462f = []byte{
        // 395 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x93, 0xcf, 0xae, 0xd2, 0x40,
        0x14, 0xc6, 0x3b, 0xfe, 0x21, 0x71, 0x8c, 0x18, 0x2b, 0x41, 0x64, 0x51, 0x48, 0x37, 0xb2, 0x61,
        0x26, 0xd5, 0x9d, 0x4b, 0x0a, 0x71, 0xe3, 0x42, 0x1a, 0x13, 0x13, 0x37, 0x66, 0x3a, 0x3d, 0xc0,
        0x24, 0x6d, 0x67, 0x6c, 0x07, 0xb0, 0x6f, 0xe1, 0x46, 0x1f, 0x42, 0x5f, 0x84, 0x25, 0x4b, 0x57,
        0xc4, 0xc0, 0x1b, 0xdc, 0x27, 0xb8, 0x69, 0xa7, 0x17, 0xee, 0xf2, 0xe6, 0xb2, 0x61, 0xd7, 0x73,
        0xce, 0xd7, 0x2f, 0xbf, 0x33, 0x39, 0x1f, 0xee, 0x73, 0x99, 0x44, 0xf0, 0x83, 0xf2, 0x48, 0xd1,
        0x95, 0xc7, 0x62, 0xb5, 0x60, 0x1e, 0x85, 0x15, 0xa4, 0x3a, 0x27, 0x2a, 0x93, 0x5a, 0xda, 0x2f,
        0x8d, 0x82, 0xf0, 0x48, 0x91, 0x1b, 0x45, 0xb7, 0x35, 0x97, 0x73, 0x59, 0xcd, 0x69, 0xf9, 0x65,
        0xa4, 0x5d, 0x87, 0xcb, 0x3c, 0x91, 0x39, 0x0d, 0x59, 0x0e, 0x74, 0xe5, 0x85, 0xa0, 0x99, 0x47,
        0xb9, 0x14, 0xa9, 0x99, 0xbb, 0x53, 0xdc, 0x9c, 0x94, 0xd6, 0x7e, 0x06, 0x4c, 0x83, 0x3f, 0xfe,
        0x64, 0xb7, 0x71, 0x23, 0x87, 0x34, 0x82, 0xac, 0x83, 0xfa, 0x68, 0xf0, 0x24, 0xa8, 0x2b, 0xfb,
        0x0d, 0x7e, 0xce, 0x65, 0x1c, 0x33, 0x0d, 0x19, 0x8b, 0xbf, 0xe9, 0x42, 0x41, 0xe7, 0x41, 0x25,
        0x68, 0x9e, 0xda, 0x9f, 0x0b, 0x05, 0xee, 0x1f, 0x84, 0xdb, 0x95, 0xe7, 0x18, 0x94, 0xcc, 0x85,
        0xf6, 0x8f, 0x63, 0xbb, 0x85, 0x1f, 0xcb, 0x75, 0x7a, 0xb4, 0x36, 0xc5, 0x9d, 0x9d, 0xed, 0x29,
        0xc6, 0xa7, 0x4e, 0xe7, 0x61, 0x1f, 0x0d, 0x9e, 0xbe, 0x7d, 0x4d, 0xcc, 0x86, 0xa4, 0xdc, 0x90,
        0xd4, 0x1b, 0x12, 0x5f, 0x8a, 0x74, 0xd4, 0xde, 0xec, 0x7a, 0xd6, 0xd5, 0xae, 0xd7, 0x2c, 0x58,
        0x12, 0xbf, 0x77, 0x15, 0x2b, 0x12, 0x48, 0xb5, 0x1b, 0xdc, 0x32, 0x71, 0xff, 0x22, 0xfc, 0xaa,
        0x82, 0xfd, 0x22, 0xf4, 0x22, 0xca, 0xd8, 0xfa, 0xa2, 0x69, 0x7f, 0x21, 0xfc, 0xcc, 0x3c, 0x6d,
        0xc6, 0xd6, 0x63, 0x08, 0xf5, 0xb9, 0x8c, 0x13, 0xfc, 0x28, 0x82, 0x50, 0xdf, 0x9f, 0xae, 0xfa,
        0xdd, 0xfd, 0x8d, 0xea, 0x33, 0x0a, 0x40, 0xb1, 0xe2, 0x82, 0xc0, 0x02, 0xfc, 0xa2, 0xe2, 0xfa,
        0x28, 0xbe, 0x2f, 0x45, 0x54, 0x5f, 0xf8, 0x79, 0x68, 0xa3, 0x0f, 0x9b, 0xbd, 0x83, 0xb6, 0x7b,
        0x07, 0xfd, 0xdf, 0x3b, 0xe8, 0xe7, 0xc1, 0xb1, 0xb6, 0x07, 0xc7, 0xfa, 0x77, 0x70, 0xac, 0xaf,
        0xc3, 0xb9, 0xd0, 0x8b, 0x65, 0x48, 0xb8, 0x4c, 0xa8, 0x89, 0xe8, 0x50, 0xce, 0x66, 0x82, 0x0b,
        0x16, 0xd7, 0x35, 0x35, 0xb1, 0x2e, 0xdd, 0xf3, 0xb0, 0x51, 0x45, 0xf0, 0xdd, 0x75, 0x00, 0x00,
        0x00, 0xff, 0xff, 0x4f, 0x6d, 0x17, 0xe6, 0xf1, 0x03, 0x00, 0x00,
}

func (m *EventCreateCDP) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *EventCreateCDP) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *EventCreateCDP) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Sender) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Sender)
                copy(dAtA[i:], m.Sender)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *EventDepositCollateral) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *EventDepositCollateral) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *EventDepositCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintEvents(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *EventWithdrawCollateral) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *EventWithdrawCollateral) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *EventWithdrawCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintEvents(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *EventDrawDebt) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *EventDrawDebt) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *EventDrawDebt) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Debt.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintEvents(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *EventRepayDebt) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *EventRepayDebt) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *EventRepayDebt) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Debt.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintEvents(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *EventLiquidateCDP) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *EventLiquidateCDP) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *EventLiquidateCDP) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovEvents(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *EventCreateCDP) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Sender)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *EventDepositCollateral) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Collateral.Size()
        n += 1 + l + sovEvents(uint64(l))
        return n</span>
}

func (m *EventWithdrawCollateral) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Collateral.Size()
        n += 1 + l + sovEvents(uint64(l))
        return n</span>
}

func (m *EventDrawDebt) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Debt.Size()
        n += 1 + l + sovEvents(uint64(l))
        return n</span>
}

func (m *EventRepayDebt) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Debt.Size()
        n += 1 + l + sovEvents(uint64(l))
        return n</span>
}

func (m *EventLiquidateCDP) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovEvents(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func sovEvents(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozEvents(x uint64) (n int) <span class="cov0" title="0">{
        return sovEvents(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *EventCreateCDP) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventCreateCDP: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventCreateCDP: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Sender = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipEvents(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *EventDepositCollateral) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventDepositCollateral: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventDepositCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipEvents(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *EventWithdrawCollateral) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventWithdrawCollateral: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventWithdrawCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipEvents(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *EventDrawDebt) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventDrawDebt: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventDrawDebt: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Debt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipEvents(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *EventRepayDebt) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventRepayDebt: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventRepayDebt: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Debt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipEvents(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *EventLiquidateCDP) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventLiquidateCDP: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: EventLiquidateCDP: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipEvents(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipEvents(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowEvents
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowEvents
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthEvents
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupEvents
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthEvents
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file4" style="display: none">package types

// DefaultIndex is the default capability global index
const DefaultIndex uint64 = 1

// DefaultGenesis returns the default Capability genesis state
func DefaultGenesis() *GenesisState <span class="cov8" title="1">{
        return &amp;GenesisState{}
}</span>

// Validate performs basic genesis state validation returning an error upon any
// failure.
func (m GenesisState) Validate() error <span class="cov8" title="1">{

        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/cdp/v1alpha1/genesis.proto

package types

import (
        fmt "fmt"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        _ "github.com/golang/protobuf/ptypes/timestamp"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GenesisState defines the cdp module's genesis state.
type GenesisState struct {
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params" yaml:"params"`
        Cdps   []CDP  `protobuf:"bytes,2,rep,name=cdps,proto3" json:"cdps" yaml:"cdps"`
}

func (m *GenesisState) Reset()         <span class="cov0" title="0">{ *m = GenesisState{} }</span>
func (m *GenesisState) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GenesisState) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GenesisState) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_0dab3778453fac25, []int{0}
}</span>
func (m *GenesisState) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *GenesisState) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.Merge(m, src)
}</span>
func (m *GenesisState) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *GenesisState) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GenesisState.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

func (m *GenesisState) GetCdps() []CDP <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cdps
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*GenesisState)(nil), "comdex.cdp.v1alpha1.GenesisState")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/cdp/v1alpha1/genesis.proto", fileDescriptor_0dab3778453fac25) }</span>

var fileDescriptor_0dab3778453fac25 = []byte{
        // 283 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x52, 0x4c, 0xce, 0xcf, 0x4d,
        0x49, 0xad, 0xd0, 0x4f, 0x4e, 0x29, 0xd0, 0x2f, 0x33, 0x4c, 0xcc, 0x29, 0xc8, 0x48, 0x34, 0xd4,
        0x4f, 0x4f, 0xcd, 0x4b, 0x2d, 0xce, 0x2c, 0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x86,
        0x28, 0xd1, 0x4b, 0x4e, 0x29, 0xd0, 0x83, 0x29, 0x91, 0x12, 0x49, 0xcf, 0x4f, 0xcf, 0x07, 0xcb,
        0xeb, 0x83, 0x58, 0x10, 0xa5, 0x52, 0xf2, 0xe9, 0xf9, 0xf9, 0xe9, 0x39, 0xa9, 0xfa, 0x60, 0x5e,
        0x52, 0x69, 0x9a, 0x7e, 0x49, 0x66, 0x6e, 0x6a, 0x71, 0x49, 0x62, 0x6e, 0x01, 0x54, 0x81, 0x2c,
        0x36, 0xeb, 0x40, 0x06, 0x43, 0xa4, 0x15, 0xb0, 0x49, 0x17, 0x24, 0x16, 0x25, 0xe6, 0x42, 0x1d,
        0xa3, 0x34, 0x97, 0x91, 0x8b, 0xc7, 0x1d, 0xe2, 0xbc, 0xe0, 0x92, 0xc4, 0x92, 0x54, 0x21, 0x2f,
        0x2e, 0x36, 0x88, 0x02, 0x09, 0x46, 0x05, 0x46, 0x0d, 0x6e, 0x23, 0x69, 0x3d, 0x2c, 0xce, 0xd5,
        0x0b, 0x00, 0x2b, 0x71, 0x12, 0x3d, 0x71, 0x4f, 0x9e, 0xe1, 0xd3, 0x3d, 0x79, 0xde, 0xca, 0xc4,
        0xdc, 0x1c, 0x2b, 0x25, 0x88, 0x46, 0xa5, 0x20, 0xa8, 0x09, 0x42, 0x8e, 0x5c, 0x2c, 0xc9, 0x29,
        0x05, 0xc5, 0x12, 0x4c, 0x0a, 0xcc, 0x1a, 0xdc, 0x46, 0x12, 0x58, 0x4d, 0x72, 0x76, 0x09, 0x70,
        0x12, 0x86, 0x1a, 0xc3, 0x0d, 0x31, 0x06, 0xa4, 0x47, 0x29, 0x08, 0xac, 0xd5, 0xc9, 0xfd, 0xc4,
        0x23, 0x39, 0xc6, 0x0b, 0x8f, 0xe4, 0x18, 0x1f, 0x3c, 0x92, 0x63, 0x9c, 0xf0, 0x58, 0x8e, 0xe1,
        0xc2, 0x63, 0x39, 0x86, 0x1b, 0x8f, 0xe5, 0x18, 0xa2, 0x74, 0xd3, 0x33, 0x4b, 0x32, 0x4a, 0x93,
        0x40, 0x86, 0xea, 0x43, 0x0c, 0xd6, 0xcd, 0x4f, 0x4b, 0xcb, 0x4c, 0xce, 0x4c, 0xcc, 0x81, 0xf2,
        0xf5, 0x21, 0x1e, 0x2f, 0xa9, 0x2c, 0x48, 0x2d, 0x4e, 0x62, 0x03, 0xfb, 0xd7, 0x18, 0x10, 0x00,
        0x00, 0xff, 0xff, 0x6b, 0x32, 0x2a, 0xcd, 0xa1, 0x01, 0x00, 0x00,
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Cdps) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Cdps) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Cdps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0x12</span>
                }
        }
        <span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintGenesis(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovGenesis(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *GenesisState) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovGenesis(uint64(l))
        if len(m.Cdps) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Cdps </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovGenesis(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func sovGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozGenesis(x uint64) (n int) <span class="cov0" title="0">{
        return sovGenesis(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *GenesisState) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Cdps", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Cdps = append(m.Cdps, CDP{})
                        if err := m.Cdps[len(m.Cdps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipGenesis(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipGenesis(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowGenesis
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowGenesis
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthGenesis
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupGenesis
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthGenesis
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file6" style="display: none">package types

import (
        sdk "github.com/cosmos/cosmos-sdk/types"
)

const (
        // ModuleName defines the module name
        ModuleName = "cdp"

        // StoreKey defines the primary module store key
        StoreKey = ModuleName

        // RouterKey is the message route for slashing
        RouterKey = ModuleName

        // QuerierRoute defines the module's query routing key
        QuerierRoute = ModuleName

        // MemStoreKey defines the in-memory store key
        MemStoreKey = "mem_cdp"
)

var (
        TypeMsgCreateCDPRequest          = ModuleName + ":create_cdp"
        TypeMsgDepositCollateralRequest  = ModuleName + ":deposit_collateral"
        TypeMsgWithdrawCollateralRequest = ModuleName + ":withdraw_collateral"
        TypeMsgDrawDebtRequest           = ModuleName + ":draw_debt"
        TypeMsgRepayDebtRequest          = ModuleName + ":repay_debt"
        TypeMsgLiquidateCDPRequest       = ModuleName + ":liquidate_cdp"
)

var (
        CdpIdIndexKeyPrefix = []byte{0x01}
        CdpKeyPrefix        = []byte{0x02}
        CdpIdKey            = []byte{0x03}
)

func GetCdpIDBytes(cdpID uint64) (cdpIDBz []byte) <span class="cov8" title="1">{
        return sdk.Uint64ToBigEndian(cdpID)
}</span>

func GetCdpIDFromBytes(bz []byte) (cdpID uint64) <span class="cov0" title="0">{
        return sdk.BigEndianToUint64(bz)
}</span>

func CdpKey(cdpID uint64) []byte <span class="cov8" title="1">{
        return append(CdpKeyPrefix, GetCdpIDBytes(cdpID)...)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package types

import (
        "fmt"
        "strings"

        sdk "github.com/cosmos/cosmos-sdk/types"
        "github.com/cosmos/cosmos-sdk/types/errors"
)

var (
        _ sdk.Msg = (*MsgCreateCDPRequest)(nil)
        _ sdk.Msg = (*MsgDepositCollateralRequest)(nil)
        _ sdk.Msg = (*MsgWithdrawCollateralRequest)(nil)
        _ sdk.Msg = (*MsgDrawDebtRequest)(nil)
        _ sdk.Msg = (*MsgRepayDebtRequest)(nil)
        _ sdk.Msg = (*MsgLiquidateCDPRequest)(nil)
)

// returns a new NewMsgCreateCDPRequest.
func NewMsgCreateCDPRequest(sender sdk.AccAddress, collateral sdk.Coin, debt sdk.Coin, collateralType string) *MsgCreateCDPRequest <span class="cov8" title="1">{
        return &amp;MsgCreateCDPRequest{
                Sender:         sender.String(),
                Collateral:     collateral,
                Debt:           debt,
                CollateralType: collateralType,
        }
}</span>

func (msg *MsgCreateCDPRequest) Route() string <span class="cov0" title="0">{ return RouterKey }</span>

func (msg *MsgCreateCDPRequest) Type() string <span class="cov0" title="0">{ return TypeMsgCreateCDPRequest }</span>

func (msg MsgCreateCDPRequest) ValidateBasic() error <span class="cov8" title="1">{
        if msg.Sender == "" </span><span class="cov8" title="1">{
                return errors.Wrap(errors.ErrInvalidAddress, "sender address cannot be empty")
        }</span>
        <span class="cov8" title="1">if !msg.Collateral.IsPositive() || !msg.Collateral.IsValid() </span><span class="cov8" title="1">{
                return errors.Wrapf(ErrorInvalidCoins, "collateral amount %s", msg.Collateral)
        }</span>
        <span class="cov8" title="1">if !msg.Debt.IsPositive() || !msg.Debt.IsValid() </span><span class="cov8" title="1">{
                return errors.Wrapf(ErrorInvalidCoins, "principal amount %s", msg.Debt)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(msg.CollateralType) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("collateral type cannot be empty")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (msg *MsgCreateCDPRequest) GetSignBytes() []byte <span class="cov0" title="0">{
        return sdk.MustSortJSON(ModuleCdc.MustMarshalJSON(msg))
}</span>

func (msg *MsgCreateCDPRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(msg.Sender)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

//returns new deposit request
func NewMsgDepositCollateralRequest(owner sdk.AccAddress, collateral sdk.Coin, collateralType string) *MsgDepositCollateralRequest <span class="cov0" title="0">{
        return &amp;MsgDepositCollateralRequest{
                Owner:          owner.String(),
                Collateral:     collateral,
                CollateralType: collateralType,
        }
}</span>

func (msg *MsgDepositCollateralRequest) Route() string <span class="cov0" title="0">{ return RouterKey }</span>

func (msg *MsgDepositCollateralRequest) Type() string <span class="cov0" title="0">{ return TypeMsgDepositCollateralRequest }</span>

func (msg MsgDepositCollateralRequest) ValidateBasic() error <span class="cov0" title="0">{
        if msg.Owner == "" </span><span class="cov0" title="0">{
                return errors.Wrap(errors.ErrInvalidAddress, "sender address cannot be empty")
        }</span>
        <span class="cov0" title="0">if !msg.Collateral.IsPositive() || !msg.Collateral.IsValid() </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidCoins, "collateral amount %s", msg.Collateral)
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(msg.CollateralType) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("collateral type cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (msg *MsgDepositCollateralRequest) GetSignBytes() []byte <span class="cov0" title="0">{
        return sdk.MustSortJSON(ModuleCdc.MustMarshalJSON(msg))
}</span>

func (msg *MsgDepositCollateralRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(msg.Owner)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

//returns new withdraw request
func NewMsgWithdrawCollateralRequest(owner sdk.AccAddress, collateral sdk.Coin, collateralType string) *MsgWithdrawCollateralRequest <span class="cov0" title="0">{
        return &amp;MsgWithdrawCollateralRequest{
                Owner:          owner.String(),
                Collateral:     collateral,
                CollateralType: collateralType,
        }
}</span>

func (msg *MsgWithdrawCollateralRequest) Route() string <span class="cov0" title="0">{ return RouterKey }</span>

func (msg *MsgWithdrawCollateralRequest) Type() string <span class="cov0" title="0">{ return TypeMsgWithdrawCollateralRequest }</span>

func (msg MsgWithdrawCollateralRequest) ValidateBasic() error <span class="cov0" title="0">{
        if msg.Owner == "" </span><span class="cov0" title="0">{
                return errors.Wrap(errors.ErrInvalidAddress, "sender address cannot be empty")
        }</span>
        <span class="cov0" title="0">if !msg.Collateral.IsPositive() || !msg.Collateral.IsValid() </span><span class="cov0" title="0">{
                return errors.Wrapf(ErrorInvalidCoins, "collateral amount %s", msg.Collateral)
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(msg.CollateralType) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("collateral type cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (msg *MsgWithdrawCollateralRequest) GetSignBytes() []byte <span class="cov0" title="0">{
        return sdk.MustSortJSON(ModuleCdc.MustMarshalJSON(msg))
}</span>

func (msg *MsgWithdrawCollateralRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(msg.Owner)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

//returns new draw debt request
func NewMsgDrawDebtRequest(owner sdk.AccAddress, collateralType string, debt sdk.Coin) *MsgDrawDebtRequest <span class="cov8" title="1">{
        return &amp;MsgDrawDebtRequest{
                Owner:          owner.String(),
                CollateralType: collateralType,
                Debt:           debt,
        }
}</span>

func (msg *MsgDrawDebtRequest) Route() string <span class="cov0" title="0">{ return RouterKey }</span>

func (msg *MsgDrawDebtRequest) Type() string <span class="cov0" title="0">{ return TypeMsgDrawDebtRequest }</span>

func (msg MsgDrawDebtRequest) ValidateBasic() error <span class="cov8" title="1">{
        if msg.Owner == "" </span><span class="cov8" title="1">{
                return errors.Wrap(errors.ErrInvalidAddress, "sender address cannot be empty")
        }</span>
        <span class="cov8" title="1">if !msg.Debt.IsPositive() || !msg.Debt.IsValid() </span><span class="cov8" title="1">{
                return errors.Wrapf(ErrorInvalidCoins, "Debt amount %s", msg.Debt)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(msg.CollateralType) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("collateral type cannot be empty")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (msg *MsgDrawDebtRequest) GetSignBytes() []byte <span class="cov0" title="0">{
        return sdk.MustSortJSON(ModuleCdc.MustMarshalJSON(msg))
}</span>

func (msg *MsgDrawDebtRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(msg.Owner)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

//returns new repay debt request
func NewMsgRepayDebtRequest(owner sdk.AccAddress, collateralType string, debt sdk.Coin) *MsgRepayDebtRequest <span class="cov8" title="1">{
        return &amp;MsgRepayDebtRequest{
                Owner:          owner.String(),
                CollateralType: collateralType,
                Debt:           debt,
        }
}</span>

func (msg *MsgRepayDebtRequest) Route() string <span class="cov0" title="0">{ return RouterKey }</span>

func (msg *MsgRepayDebtRequest) Type() string <span class="cov0" title="0">{ return TypeMsgRepayDebtRequest }</span>

func (msg MsgRepayDebtRequest) ValidateBasic() error <span class="cov8" title="1">{
        if msg.Owner == "" </span><span class="cov8" title="1">{
                return errors.Wrap(errors.ErrInvalidAddress, "sender address cannot be empty")
        }</span>
        <span class="cov8" title="1">if !msg.Debt.IsPositive() || !msg.Debt.IsValid() </span><span class="cov8" title="1">{
                return errors.Wrapf(ErrorInvalidCoins, "payment amount %s", msg.Debt)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(msg.CollateralType) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("collateral type cannot be empty")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (msg *MsgRepayDebtRequest) GetSignBytes() []byte <span class="cov0" title="0">{
        return sdk.MustSortJSON(ModuleCdc.MustMarshalJSON(msg))
}</span>

func (msg *MsgRepayDebtRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(msg.Owner)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}

//returns new liquidate request
func NewMsgLiquidateCDPRequest(sender sdk.AccAddress, collateralType string) *MsgLiquidateCDPRequest <span class="cov0" title="0">{
        return &amp;MsgLiquidateCDPRequest{
                Owner:          sender.String(),
                CollateralType: collateralType,
        }
}</span>

func (msg *MsgLiquidateCDPRequest) Route() string <span class="cov0" title="0">{ return RouterKey }</span>

func (msg *MsgLiquidateCDPRequest) Type() string <span class="cov0" title="0">{ return TypeMsgLiquidateCDPRequest }</span>

func (msg MsgLiquidateCDPRequest) ValidateBasic() error <span class="cov0" title="0">{
        if msg.Owner == "" </span><span class="cov0" title="0">{
                return errors.Wrap(errors.ErrInvalidAddress, "sender address cannot be empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(msg.CollateralType) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("collateral type cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (msg *MsgLiquidateCDPRequest) GetSignBytes() []byte <span class="cov0" title="0">{
        return sdk.MustSortJSON(ModuleCdc.MustMarshalJSON(msg))
}</span>

func (msg *MsgLiquidateCDPRequest) GetSigners() []sdk.AccAddress <span class="cov0" title="0">{
        from, err := sdk.AccAddressFromBech32(msg.Owner)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return []sdk.AccAddress{from}</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/cdp/v1alpha1/msg.proto

package types

import (
        context "context"
        fmt "fmt"
        types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/gogo/protobuf/gogoproto"
        grpc1 "github.com/gogo/protobuf/grpc"
        proto "github.com/gogo/protobuf/proto"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgCreateCDPRequest struct {
        Sender         string     `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
        Collateral     types.Coin `protobuf:"bytes,2,opt,name=collateral,proto3" json:"collateral" yaml:"collateral"`
        Debt           types.Coin `protobuf:"bytes,3,opt,name=debt,proto3" json:"debt" yaml:"debt"`
        CollateralType string     `protobuf:"bytes,4,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty" yaml:"collateral_type"`
}

func (m *MsgCreateCDPRequest) Reset()         <span class="cov0" title="0">{ *m = MsgCreateCDPRequest{} }</span>
func (m *MsgCreateCDPRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCreateCDPRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCreateCDPRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{0}
}</span>
func (m *MsgCreateCDPRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCreateCDPRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCreateCDPRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCreateCDPRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateCDPRequest.Merge(m, src)
}</span>
func (m *MsgCreateCDPRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCreateCDPRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateCDPRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCreateCDPRequest proto.InternalMessageInfo

func (m *MsgCreateCDPRequest) GetSender() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Sender
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgCreateCDPRequest) GetCollateral() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Collateral
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

func (m *MsgCreateCDPRequest) GetDebt() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Debt
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

func (m *MsgCreateCDPRequest) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MsgCreateCDPResponse struct {
}

func (m *MsgCreateCDPResponse) Reset()         <span class="cov0" title="0">{ *m = MsgCreateCDPResponse{} }</span>
func (m *MsgCreateCDPResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgCreateCDPResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgCreateCDPResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{1}
}</span>
func (m *MsgCreateCDPResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgCreateCDPResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgCreateCDPResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgCreateCDPResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateCDPResponse.Merge(m, src)
}</span>
func (m *MsgCreateCDPResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgCreateCDPResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgCreateCDPResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgCreateCDPResponse proto.InternalMessageInfo

type MsgDepositCollateralRequest struct {
        Owner          string     `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty" yaml:"sender"`
        Collateral     types.Coin `protobuf:"bytes,2,opt,name=collateral,proto3" json:"collateral" yaml:"collateral"`
        CollateralType string     `protobuf:"bytes,3,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty" yaml:"collateral_type"`
}

func (m *MsgDepositCollateralRequest) Reset()         <span class="cov0" title="0">{ *m = MsgDepositCollateralRequest{} }</span>
func (m *MsgDepositCollateralRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgDepositCollateralRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgDepositCollateralRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{2}
}</span>
func (m *MsgDepositCollateralRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgDepositCollateralRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgDepositCollateralRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgDepositCollateralRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgDepositCollateralRequest.Merge(m, src)
}</span>
func (m *MsgDepositCollateralRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgDepositCollateralRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgDepositCollateralRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgDepositCollateralRequest proto.InternalMessageInfo

func (m *MsgDepositCollateralRequest) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgDepositCollateralRequest) GetCollateral() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Collateral
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

func (m *MsgDepositCollateralRequest) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MsgDepositCollateralResponse struct {
}

func (m *MsgDepositCollateralResponse) Reset()         <span class="cov0" title="0">{ *m = MsgDepositCollateralResponse{} }</span>
func (m *MsgDepositCollateralResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgDepositCollateralResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgDepositCollateralResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{3}
}</span>
func (m *MsgDepositCollateralResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgDepositCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgDepositCollateralResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgDepositCollateralResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgDepositCollateralResponse.Merge(m, src)
}</span>
func (m *MsgDepositCollateralResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgDepositCollateralResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgDepositCollateralResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgDepositCollateralResponse proto.InternalMessageInfo

type MsgWithdrawCollateralRequest struct {
        Owner          string     `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty" yaml:"sender"`
        Collateral     types.Coin `protobuf:"bytes,2,opt,name=collateral,proto3" json:"collateral" yaml:"collateral"`
        CollateralType string     `protobuf:"bytes,3,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty" yaml:"collateral_type"`
}

func (m *MsgWithdrawCollateralRequest) Reset()         <span class="cov0" title="0">{ *m = MsgWithdrawCollateralRequest{} }</span>
func (m *MsgWithdrawCollateralRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgWithdrawCollateralRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgWithdrawCollateralRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{4}
}</span>
func (m *MsgWithdrawCollateralRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgWithdrawCollateralRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgWithdrawCollateralRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgWithdrawCollateralRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawCollateralRequest.Merge(m, src)
}</span>
func (m *MsgWithdrawCollateralRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgWithdrawCollateralRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawCollateralRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgWithdrawCollateralRequest proto.InternalMessageInfo

func (m *MsgWithdrawCollateralRequest) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgWithdrawCollateralRequest) GetCollateral() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Collateral
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

func (m *MsgWithdrawCollateralRequest) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MsgWithdrawCollateralResponse struct {
}

func (m *MsgWithdrawCollateralResponse) Reset()         <span class="cov0" title="0">{ *m = MsgWithdrawCollateralResponse{} }</span>
func (m *MsgWithdrawCollateralResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgWithdrawCollateralResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgWithdrawCollateralResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{5}
}</span>
func (m *MsgWithdrawCollateralResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgWithdrawCollateralResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgWithdrawCollateralResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgWithdrawCollateralResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawCollateralResponse.Merge(m, src)
}</span>
func (m *MsgWithdrawCollateralResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgWithdrawCollateralResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgWithdrawCollateralResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgWithdrawCollateralResponse proto.InternalMessageInfo

type MsgDrawDebtRequest struct {
        Owner          string     `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty" yaml:"sender"`
        CollateralType string     `protobuf:"bytes,2,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty" yaml:"collateral_type"`
        Debt           types.Coin `protobuf:"bytes,3,opt,name=debt,proto3" json:"debt" yaml:"debt"`
}

func (m *MsgDrawDebtRequest) Reset()         <span class="cov0" title="0">{ *m = MsgDrawDebtRequest{} }</span>
func (m *MsgDrawDebtRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgDrawDebtRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgDrawDebtRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{6}
}</span>
func (m *MsgDrawDebtRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgDrawDebtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgDrawDebtRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgDrawDebtRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgDrawDebtRequest.Merge(m, src)
}</span>
func (m *MsgDrawDebtRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgDrawDebtRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgDrawDebtRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgDrawDebtRequest proto.InternalMessageInfo

func (m *MsgDrawDebtRequest) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgDrawDebtRequest) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgDrawDebtRequest) GetDebt() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Debt
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

type MsgDrawDebtResponse struct {
}

func (m *MsgDrawDebtResponse) Reset()         <span class="cov0" title="0">{ *m = MsgDrawDebtResponse{} }</span>
func (m *MsgDrawDebtResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgDrawDebtResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgDrawDebtResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{7}
}</span>
func (m *MsgDrawDebtResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgDrawDebtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgDrawDebtResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgDrawDebtResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgDrawDebtResponse.Merge(m, src)
}</span>
func (m *MsgDrawDebtResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgDrawDebtResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgDrawDebtResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgDrawDebtResponse proto.InternalMessageInfo

type MsgRepayDebtRequest struct {
        Owner          string     `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty" yaml:"sender"`
        CollateralType string     `protobuf:"bytes,2,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty" yaml:"collateral_type"`
        Debt           types.Coin `protobuf:"bytes,3,opt,name=debt,proto3" json:"debt" yaml:"payment"`
}

func (m *MsgRepayDebtRequest) Reset()         <span class="cov0" title="0">{ *m = MsgRepayDebtRequest{} }</span>
func (m *MsgRepayDebtRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRepayDebtRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRepayDebtRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{8}
}</span>
func (m *MsgRepayDebtRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRepayDebtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRepayDebtRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRepayDebtRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRepayDebtRequest.Merge(m, src)
}</span>
func (m *MsgRepayDebtRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRepayDebtRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRepayDebtRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRepayDebtRequest proto.InternalMessageInfo

func (m *MsgRepayDebtRequest) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRepayDebtRequest) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgRepayDebtRequest) GetDebt() types.Coin <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Debt
        }</span>
        <span class="cov0" title="0">return types.Coin{}</span>
}

type MsgRepayDebtResponse struct {
}

func (m *MsgRepayDebtResponse) Reset()         <span class="cov0" title="0">{ *m = MsgRepayDebtResponse{} }</span>
func (m *MsgRepayDebtResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgRepayDebtResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgRepayDebtResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{9}
}</span>
func (m *MsgRepayDebtResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgRepayDebtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgRepayDebtResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgRepayDebtResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgRepayDebtResponse.Merge(m, src)
}</span>
func (m *MsgRepayDebtResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgRepayDebtResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgRepayDebtResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgRepayDebtResponse proto.InternalMessageInfo

type MsgLiquidateCDPRequest struct {
        Owner          string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty" yaml:"sender"`
        CollateralType string `protobuf:"bytes,2,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty" yaml:"collateral_type"`
}

func (m *MsgLiquidateCDPRequest) Reset()         <span class="cov0" title="0">{ *m = MsgLiquidateCDPRequest{} }</span>
func (m *MsgLiquidateCDPRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgLiquidateCDPRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgLiquidateCDPRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{10}
}</span>
func (m *MsgLiquidateCDPRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgLiquidateCDPRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgLiquidateCDPRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgLiquidateCDPRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgLiquidateCDPRequest.Merge(m, src)
}</span>
func (m *MsgLiquidateCDPRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgLiquidateCDPRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgLiquidateCDPRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgLiquidateCDPRequest proto.InternalMessageInfo

func (m *MsgLiquidateCDPRequest) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MsgLiquidateCDPRequest) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MsgLiquidateCDPResponse struct {
}

func (m *MsgLiquidateCDPResponse) Reset()         <span class="cov0" title="0">{ *m = MsgLiquidateCDPResponse{} }</span>
func (m *MsgLiquidateCDPResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MsgLiquidateCDPResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MsgLiquidateCDPResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_36e7dbbc8c8df5ed, []int{11}
}</span>
func (m *MsgLiquidateCDPResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *MsgLiquidateCDPResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_MsgLiquidateCDPResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *MsgLiquidateCDPResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MsgLiquidateCDPResponse.Merge(m, src)
}</span>
func (m *MsgLiquidateCDPResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *MsgLiquidateCDPResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MsgLiquidateCDPResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MsgLiquidateCDPResponse proto.InternalMessageInfo

func init() <span class="cov8" title="1">{
        proto.RegisterType((*MsgCreateCDPRequest)(nil), "comdex.cdp.v1alpha1.MsgCreateCDPRequest")
        proto.RegisterType((*MsgCreateCDPResponse)(nil), "comdex.cdp.v1alpha1.MsgCreateCDPResponse")
        proto.RegisterType((*MsgDepositCollateralRequest)(nil), "comdex.cdp.v1alpha1.MsgDepositCollateralRequest")
        proto.RegisterType((*MsgDepositCollateralResponse)(nil), "comdex.cdp.v1alpha1.MsgDepositCollateralResponse")
        proto.RegisterType((*MsgWithdrawCollateralRequest)(nil), "comdex.cdp.v1alpha1.MsgWithdrawCollateralRequest")
        proto.RegisterType((*MsgWithdrawCollateralResponse)(nil), "comdex.cdp.v1alpha1.MsgWithdrawCollateralResponse")
        proto.RegisterType((*MsgDrawDebtRequest)(nil), "comdex.cdp.v1alpha1.MsgDrawDebtRequest")
        proto.RegisterType((*MsgDrawDebtResponse)(nil), "comdex.cdp.v1alpha1.MsgDrawDebtResponse")
        proto.RegisterType((*MsgRepayDebtRequest)(nil), "comdex.cdp.v1alpha1.MsgRepayDebtRequest")
        proto.RegisterType((*MsgRepayDebtResponse)(nil), "comdex.cdp.v1alpha1.MsgRepayDebtResponse")
        proto.RegisterType((*MsgLiquidateCDPRequest)(nil), "comdex.cdp.v1alpha1.MsgLiquidateCDPRequest")
        proto.RegisterType((*MsgLiquidateCDPResponse)(nil), "comdex.cdp.v1alpha1.MsgLiquidateCDPResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/cdp/v1alpha1/msg.proto", fileDescriptor_36e7dbbc8c8df5ed) }</span>

var fileDescriptor_36e7dbbc8c8df5ed = []byte{
        // 634 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0x4d, 0x6f, 0xd3, 0x4c,
        0x10, 0x8e, 0xfb, 0x25, 0xbd, 0xdb, 0x97, 0x56, 0xdd, 0xb4, 0x21, 0x31, 0xd4, 0xa9, 0x7c, 0x69,
        0x2a, 0xa8, 0x4d, 0xc2, 0x8d, 0x63, 0x12, 0xc4, 0x85, 0x48, 0xc8, 0x54, 0x42, 0xe2, 0x02, 0x6b,
        0x7b, 0xeb, 0x58, 0x72, 0xbc, 0xae, 0x77, 0x93, 0x10, 0x21, 0x71, 0xe4, 0xcc, 0x3f, 0xe0, 0xc0,
        0x7f, 0x41, 0x15, 0xa7, 0x1e, 0x39, 0x45, 0x90, 0xfc, 0x83, 0xfc, 0x02, 0x64, 0xef, 0x36, 0x9f,
        0x36, 0x4d, 0x24, 0x3e, 0x24, 0x6e, 0xeb, 0xd9, 0x99, 0x67, 0xe6, 0x79, 0x76, 0x67, 0xbc, 0xe0,
        0xd0, 0x22, 0x2d, 0x1b, 0xbf, 0xd1, 0x2d, 0x3b, 0xd0, 0x3b, 0x65, 0xe4, 0x05, 0x4d, 0x54, 0xd6,
        0x5b, 0xd4, 0xd1, 0x82, 0x90, 0x30, 0x02, 0xb3, 0x7c, 0x5b, 0xb3, 0xec, 0x40, 0xbb, 0xde, 0x96,
        0x15, 0x8b, 0xd0, 0x16, 0xa1, 0xba, 0x89, 0x28, 0xd6, 0x3b, 0x65, 0x13, 0x33, 0x54, 0xd6, 0x2d,
        0xe2, 0xfa, 0x3c, 0x48, 0xde, 0x77, 0x88, 0x43, 0xe2, 0xa5, 0x1e, 0xad, 0xb8, 0x55, 0xfd, 0xb8,
        0x06, 0xb2, 0x0d, 0xea, 0xd4, 0x42, 0x8c, 0x18, 0xae, 0xd5, 0x9f, 0x19, 0xf8, 0xa2, 0x8d, 0x29,
        0x83, 0x27, 0x60, 0x8b, 0x62, 0xdf, 0xc6, 0x61, 0x5e, 0x3a, 0x92, 0x4a, 0xff, 0x55, 0xf7, 0x46,
        0xfd, 0xe2, 0xad, 0x1e, 0x6a, 0x79, 0x8f, 0x54, 0x6e, 0x57, 0x0d, 0xe1, 0x00, 0xcf, 0x00, 0xb0,
        0x88, 0xe7, 0x21, 0x86, 0x43, 0xe4, 0xe5, 0xd7, 0x8e, 0xa4, 0xd2, 0x76, 0xa5, 0xa0, 0xf1, 0x6a,
        0xb4, 0xa8, 0x1a, 0x4d, 0x54, 0xa3, 0xd5, 0x88, 0xeb, 0x57, 0x0b, 0x97, 0xfd, 0x62, 0x66, 0xd4,
        0x2f, 0xee, 0x71, 0xb4, 0x49, 0xa8, 0x6a, 0x4c, 0xe1, 0xc0, 0x2a, 0xd8, 0xb0, 0xb1, 0xc9, 0xf2,
        0xeb, 0x37, 0xe1, 0x65, 0x05, 0xde, 0x36, 0xc7, 0x8b, 0x82, 0x54, 0x23, 0x8e, 0x85, 0x35, 0xb0,
        0x3b, 0x41, 0x7c, 0xc5, 0x7a, 0x01, 0xce, 0x6f, 0xc4, 0x6c, 0xe4, 0x51, 0xbf, 0x98, 0x9b, 0xcf,
        0x1f, 0x3b, 0xa8, 0xc6, 0xce, 0xc4, 0x72, 0x16, 0x19, 0x72, 0x60, 0x7f, 0x56, 0x20, 0x1a, 0x10,
        0x9f, 0x62, 0xf5, 0xbb, 0x04, 0xee, 0x34, 0xa8, 0x53, 0xc7, 0x01, 0xa1, 0x2e, 0xab, 0x8d, 0x83,
        0xae, 0x15, 0x3c, 0x06, 0x9b, 0xa4, 0xeb, 0xff, 0x4c, 0x40, 0xbe, 0xff, 0x9b, 0xf4, 0x4b, 0xe0,
        0xbe, 0xbe, 0x32, 0x77, 0x05, 0xdc, 0x4d, 0xa6, 0x28, 0x34, 0x18, 0x48, 0xb1, 0xc3, 0x0b, 0x97,
        0x35, 0xed, 0x10, 0x75, 0xff, 0x4d, 0x11, 0x8a, 0xe0, 0x30, 0x85, 0xa3, 0x50, 0xe1, 0xb3, 0x04,
        0x60, 0x24, 0x53, 0x88, 0xba, 0x75, 0x6c, 0xb2, 0x95, 0xb9, 0x27, 0x54, 0xb9, 0xb6, 0x6a, 0x95,
        0xbf, 0xa2, 0x5f, 0xd4, 0x83, 0x78, 0x16, 0x4c, 0x78, 0x08, 0x7e, 0x5f, 0xa4, 0xd8, 0x6e, 0xe0,
        0x00, 0xf5, 0xfe, 0x1e, 0xc1, 0xc7, 0xcb, 0x12, 0xcc, 0x09, 0x82, 0x3b, 0x1c, 0x38, 0x40, 0xbd,
        0x16, 0xf6, 0xc7, 0x1c, 0x79, 0x3b, 0x4f, 0x71, 0x11, 0x24, 0xdf, 0x4b, 0x20, 0xd7, 0xa0, 0xce,
        0x53, 0xf7, 0xa2, 0xed, 0xda, 0xb3, 0xb3, 0xf0, 0x8f, 0xf2, 0x54, 0x0b, 0xe0, 0xf6, 0x42, 0x1d,
        0xbc, 0xc6, 0xca, 0xa7, 0x4d, 0x00, 0x1a, 0xd4, 0x79, 0x8e, 0xc3, 0x8e, 0x6b, 0x61, 0x68, 0x81,
        0xff, 0xa7, 0x27, 0x13, 0x2c, 0x69, 0x09, 0xff, 0x05, 0x2d, 0x61, 0xba, 0xcb, 0x27, 0x4b, 0x78,
        0xf2, 0x9c, 0xf0, 0x6d, 0xac, 0xd7, 0xc2, 0x08, 0x80, 0x0f, 0xd2, 0x20, 0xd2, 0x06, 0xa2, 0x5c,
        0x5e, 0x21, 0x42, 0x24, 0x7f, 0x07, 0x0e, 0x12, 0x5b, 0x0f, 0xa6, 0x62, 0xa5, 0x8e, 0x22, 0xb9,
        0xb2, 0x4a, 0x88, 0xc8, 0xff, 0x1a, 0x6c, 0x4f, 0x35, 0x04, 0x3c, 0x4e, 0x65, 0x30, 0xdb, 0xfa,
        0x72, 0xe9, 0x66, 0x47, 0x91, 0x81, 0x9f, 0xe1, 0xf8, 0x3a, 0xa6, 0x9f, 0xe1, 0x7c, 0xf7, 0xa5,
        0x9f, 0xe1, 0xc2, 0xdd, 0x86, 0x1e, 0xd8, 0x9d, 0xbb, 0x52, 0xf0, 0x5e, 0x5a, 0x74, 0x42, 0x03,
        0xc8, 0xf7, 0x97, 0x73, 0xe6, 0xd9, 0xaa, 0x4f, 0x2e, 0x07, 0x8a, 0x74, 0x35, 0x50, 0xa4, 0x6f,
        0x03, 0x45, 0xfa, 0x30, 0x54, 0x32, 0x57, 0x43, 0x25, 0xf3, 0x75, 0xa8, 0x64, 0x5e, 0x9e, 0x3a,
        0x2e, 0x6b, 0xb6, 0xcd, 0x08, 0x4d, 0xe7, 0x88, 0xa7, 0xe4, 0xfc, 0xdc, 0xb5, 0x5c, 0xe4, 0x89,
        0x6f, 0x9d, 0xbf, 0x79, 0xa2, 0xce, 0xa0, 0xe6, 0x56, 0xfc, 0x44, 0x79, 0xf8, 0x23, 0x00, 0x00,
        0xff, 0xff, 0x08, 0x17, 0x8f, 0x0e, 0x0e, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgServiceClient is the client API for MsgService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgServiceClient interface {
        MsgCreateCDP(ctx context.Context, in *MsgCreateCDPRequest, opts ...grpc.CallOption) (*MsgCreateCDPResponse, error)
        MsgDepositCollateral(ctx context.Context, in *MsgDepositCollateralRequest, opts ...grpc.CallOption) (*MsgDepositCollateralResponse, error)
        MsgWithdrawCollateral(ctx context.Context, in *MsgWithdrawCollateralRequest, opts ...grpc.CallOption) (*MsgWithdrawCollateralResponse, error)
        MsgDrawDebt(ctx context.Context, in *MsgDrawDebtRequest, opts ...grpc.CallOption) (*MsgDrawDebtResponse, error)
        MsgRepayDebt(ctx context.Context, in *MsgRepayDebtRequest, opts ...grpc.CallOption) (*MsgRepayDebtResponse, error)
        MsgLiquidateCDP(ctx context.Context, in *MsgLiquidateCDPRequest, opts ...grpc.CallOption) (*MsgLiquidateCDPResponse, error)
}

type msgServiceClient struct {
        cc grpc1.ClientConn
}

func NewMsgServiceClient(cc grpc1.ClientConn) MsgServiceClient <span class="cov0" title="0">{
        return &amp;msgServiceClient{cc}
}</span>

func (c *msgServiceClient) MsgCreateCDP(ctx context.Context, in *MsgCreateCDPRequest, opts ...grpc.CallOption) (*MsgCreateCDPResponse, error) <span class="cov0" title="0">{
        out := new(MsgCreateCDPResponse)
        err := c.cc.Invoke(ctx, "/comdex.cdp.v1alpha1.MsgService/MsgCreateCDP", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgDepositCollateral(ctx context.Context, in *MsgDepositCollateralRequest, opts ...grpc.CallOption) (*MsgDepositCollateralResponse, error) <span class="cov0" title="0">{
        out := new(MsgDepositCollateralResponse)
        err := c.cc.Invoke(ctx, "/comdex.cdp.v1alpha1.MsgService/MsgDepositCollateral", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgWithdrawCollateral(ctx context.Context, in *MsgWithdrawCollateralRequest, opts ...grpc.CallOption) (*MsgWithdrawCollateralResponse, error) <span class="cov0" title="0">{
        out := new(MsgWithdrawCollateralResponse)
        err := c.cc.Invoke(ctx, "/comdex.cdp.v1alpha1.MsgService/MsgWithdrawCollateral", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgDrawDebt(ctx context.Context, in *MsgDrawDebtRequest, opts ...grpc.CallOption) (*MsgDrawDebtResponse, error) <span class="cov0" title="0">{
        out := new(MsgDrawDebtResponse)
        err := c.cc.Invoke(ctx, "/comdex.cdp.v1alpha1.MsgService/MsgDrawDebt", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgRepayDebt(ctx context.Context, in *MsgRepayDebtRequest, opts ...grpc.CallOption) (*MsgRepayDebtResponse, error) <span class="cov0" title="0">{
        out := new(MsgRepayDebtResponse)
        err := c.cc.Invoke(ctx, "/comdex.cdp.v1alpha1.MsgService/MsgRepayDebt", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *msgServiceClient) MsgLiquidateCDP(ctx context.Context, in *MsgLiquidateCDPRequest, opts ...grpc.CallOption) (*MsgLiquidateCDPResponse, error) <span class="cov0" title="0">{
        out := new(MsgLiquidateCDPResponse)
        err := c.cc.Invoke(ctx, "/comdex.cdp.v1alpha1.MsgService/MsgLiquidateCDP", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// MsgServiceServer is the server API for MsgService service.
type MsgServiceServer interface {
        MsgCreateCDP(context.Context, *MsgCreateCDPRequest) (*MsgCreateCDPResponse, error)
        MsgDepositCollateral(context.Context, *MsgDepositCollateralRequest) (*MsgDepositCollateralResponse, error)
        MsgWithdrawCollateral(context.Context, *MsgWithdrawCollateralRequest) (*MsgWithdrawCollateralResponse, error)
        MsgDrawDebt(context.Context, *MsgDrawDebtRequest) (*MsgDrawDebtResponse, error)
        MsgRepayDebt(context.Context, *MsgRepayDebtRequest) (*MsgRepayDebtResponse, error)
        MsgLiquidateCDP(context.Context, *MsgLiquidateCDPRequest) (*MsgLiquidateCDPResponse, error)
}

// UnimplementedMsgServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServiceServer struct {
}

func (*UnimplementedMsgServiceServer) MsgCreateCDP(ctx context.Context, req *MsgCreateCDPRequest) (*MsgCreateCDPResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgCreateCDP not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgDepositCollateral(ctx context.Context, req *MsgDepositCollateralRequest) (*MsgDepositCollateralResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgDepositCollateral not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgWithdrawCollateral(ctx context.Context, req *MsgWithdrawCollateralRequest) (*MsgWithdrawCollateralResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgWithdrawCollateral not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgDrawDebt(ctx context.Context, req *MsgDrawDebtRequest) (*MsgDrawDebtResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgDrawDebt not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgRepayDebt(ctx context.Context, req *MsgRepayDebtRequest) (*MsgRepayDebtResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgRepayDebt not implemented")
}</span>
func (*UnimplementedMsgServiceServer) MsgLiquidateCDP(ctx context.Context, req *MsgLiquidateCDPRequest) (*MsgLiquidateCDPResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MsgLiquidateCDP not implemented")
}</span>

func RegisterMsgServiceServer(s grpc1.Server, srv MsgServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_MsgService_serviceDesc, srv)
}</span>

func _MsgService_MsgCreateCDP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgCreateCDPRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgCreateCDP(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.cdp.v1alpha1.MsgService/MsgCreateCDP",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgCreateCDP(ctx, req.(*MsgCreateCDPRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgDepositCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgDepositCollateralRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgDepositCollateral(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.cdp.v1alpha1.MsgService/MsgDepositCollateral",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgDepositCollateral(ctx, req.(*MsgDepositCollateralRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgWithdrawCollateral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgWithdrawCollateralRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgWithdrawCollateral(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.cdp.v1alpha1.MsgService/MsgWithdrawCollateral",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgWithdrawCollateral(ctx, req.(*MsgWithdrawCollateralRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgDrawDebt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgDrawDebtRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgDrawDebt(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.cdp.v1alpha1.MsgService/MsgDrawDebt",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgDrawDebt(ctx, req.(*MsgDrawDebtRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgRepayDebt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgRepayDebtRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgRepayDebt(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.cdp.v1alpha1.MsgService/MsgRepayDebt",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgRepayDebt(ctx, req.(*MsgRepayDebtRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MsgService_MsgLiquidateCDP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MsgLiquidateCDPRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgLiquidateCDP(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.cdp.v1alpha1.MsgService/MsgLiquidateCDP",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MsgServiceServer).MsgLiquidateCDP(ctx, req.(*MsgLiquidateCDPRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _MsgService_serviceDesc = grpc.ServiceDesc{
        ServiceName: "comdex.cdp.v1alpha1.MsgService",
        HandlerType: (*MsgServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "MsgCreateCDP",
                        Handler:    _MsgService_MsgCreateCDP_Handler,
                },
                {
                        MethodName: "MsgDepositCollateral",
                        Handler:    _MsgService_MsgDepositCollateral_Handler,
                },
                {
                        MethodName: "MsgWithdrawCollateral",
                        Handler:    _MsgService_MsgWithdrawCollateral_Handler,
                },
                {
                        MethodName: "MsgDrawDebt",
                        Handler:    _MsgService_MsgDrawDebt_Handler,
                },
                {
                        MethodName: "MsgRepayDebt",
                        Handler:    _MsgService_MsgRepayDebt_Handler,
                },
                {
                        MethodName: "MsgLiquidateCDP",
                        Handler:    _MsgService_MsgLiquidateCDP_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "comdex/cdp/v1alpha1/msg.proto",
}

func (m *MsgCreateCDPRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCreateCDPRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCreateCDPRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x22
        }</span>
        <span class="cov0" title="0">{
                size, err := m.Debt.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        </span><span class="cov0" title="0">{
                size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.Sender) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Sender)
                copy(dAtA[i:], m.Sender)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Sender)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgCreateCDPResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgCreateCDPResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgCreateCDPResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgDepositCollateralRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgDepositCollateralRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgDepositCollateralRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">{
                size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgDepositCollateralResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgDepositCollateralResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgDepositCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgWithdrawCollateralRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgWithdrawCollateralRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgWithdrawCollateralRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">{
                size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x12
        if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgWithdrawCollateralResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgWithdrawCollateralResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgWithdrawCollateralResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgDrawDebtRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgDrawDebtRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgDrawDebtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Debt.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgDrawDebtResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgDrawDebtResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgDrawDebtResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgRepayDebtRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRepayDebtRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRepayDebtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Debt.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintMsg(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x1a
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgRepayDebtResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgRepayDebtResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgRepayDebtResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *MsgLiquidateCDPRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgLiquidateCDPRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgLiquidateCDPRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintMsg(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *MsgLiquidateCDPResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *MsgLiquidateCDPResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *MsgLiquidateCDPResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func encodeVarintMsg(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovMsg(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *MsgCreateCDPRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Sender)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Collateral.Size()
        n += 1 + l + sovMsg(uint64(l))
        l = m.Debt.Size()
        n += 1 + l + sovMsg(uint64(l))
        l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgCreateCDPResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgDepositCollateralRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Collateral.Size()
        n += 1 + l + sovMsg(uint64(l))
        l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgDepositCollateralResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgWithdrawCollateralRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Collateral.Size()
        n += 1 + l + sovMsg(uint64(l))
        l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgWithdrawCollateralResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgDrawDebtRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Debt.Size()
        n += 1 + l + sovMsg(uint64(l))
        return n</span>
}

func (m *MsgDrawDebtResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgRepayDebtRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.Debt.Size()
        n += 1 + l + sovMsg(uint64(l))
        return n</span>
}

func (m *MsgRepayDebtResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *MsgLiquidateCDPRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovMsg(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *MsgLiquidateCDPResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func sovMsg(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozMsg(x uint64) (n int) <span class="cov0" title="0">{
        return sovMsg(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *MsgCreateCDPRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateCDPRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateCDPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Sender = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Debt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgCreateCDPResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateCDPResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgCreateCDPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgDepositCollateralRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDepositCollateralRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDepositCollateralRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgDepositCollateralResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDepositCollateralResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDepositCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgWithdrawCollateralRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawCollateralRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawCollateralRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgWithdrawCollateralResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawCollateralResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgWithdrawCollateralResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgDrawDebtRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDrawDebtRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDrawDebtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Debt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgDrawDebtResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDrawDebtResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgDrawDebtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgRepayDebtRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRepayDebtRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRepayDebtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Debt", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Debt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgRepayDebtResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRepayDebtResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgRepayDebtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgLiquidateCDPRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgLiquidateCDPRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgLiquidateCDPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *MsgLiquidateCDPResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgLiquidateCDPResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: MsgLiquidateCDPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipMsg(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipMsg(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowMsg
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowMsg
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthMsg
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupMsg
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthMsg
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthMsg        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowMsg          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupMsg = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file9" style="display: none">package types

import (
        paramTypes "github.com/cosmos/cosmos-sdk/x/params/types"
)

var (
        KeyCollateralParams = []byte("CollateralParams")
)

func ParamKeyTable() paramTypes.KeyTable <span class="cov8" title="1">{
        return paramTypes.NewKeyTable().RegisterParamSet(&amp;Params{})
}</span>

func (p *Params) ParamSetPairs() paramTypes.ParamSetPairs <span class="cov8" title="1">{
        return paramTypes.ParamSetPairs{
                paramTypes.NewParamSetPair(KeyCollateralParams, &amp;p.CollateralParams, validateCollateralParams),
        }
}</span>

func validateCollateralParams(i interface{}) error <span class="cov0" title="0">{
        //TODO
        return nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/cdp/v1alpha1/params.proto

package types

import (
        fmt "fmt"
        _ "github.com/cosmos/cosmos-sdk/types"
        github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/gogo/protobuf/gogoproto"
        proto "github.com/gogo/protobuf/proto"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Params struct {
        CollateralParams []CollateralParam `protobuf:"bytes,1,rep,name=collateral_params,json=collateralParams,proto3" json:"collateral_params" yaml:"collateral_params"`
}

func (m *Params) Reset()         <span class="cov0" title="0">{ *m = Params{} }</span>
func (m *Params) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Params) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Params) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bf9893c9be4c20a1, []int{0}
}</span>
func (m *Params) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_Params.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *Params) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Params.Merge(m, src)
}</span>
func (m *Params) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *Params) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Params.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetCollateralParams() []CollateralParam <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralParams
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CollateralParam struct {
        CollateralDenom  string                                 `protobuf:"bytes,1,opt,name=collateral_denom,json=collateralDenom,proto3" json:"collateral_denom,omitempty"`
        DebtDenom        string                                 `protobuf:"bytes,2,opt,name=debt_denom,json=debtDenom,proto3" json:"debt_denom,omitempty"`
        Type             string                                 `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
        LiquidationRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=liquidation_ratio,json=liquidationRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_ratio" yaml:"liquidation_ratio"`
}

func (m *CollateralParam) Reset()         <span class="cov0" title="0">{ *m = CollateralParam{} }</span>
func (m *CollateralParam) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CollateralParam) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CollateralParam) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_bf9893c9be4c20a1, []int{1}
}</span>
func (m *CollateralParam) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *CollateralParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_CollateralParam.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *CollateralParam) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CollateralParam.Merge(m, src)
}</span>
func (m *CollateralParam) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *CollateralParam) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CollateralParam.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CollateralParam proto.InternalMessageInfo

func (m *CollateralParam) GetCollateralDenom() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralDenom
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CollateralParam) GetDebtDenom() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DebtDenom
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CollateralParam) GetType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Params)(nil), "comdex.cdp.v1alpha1.Params")
        proto.RegisterType((*CollateralParam)(nil), "comdex.cdp.v1alpha1.CollateralParam")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/cdp/v1alpha1/params.proto", fileDescriptor_bf9893c9be4c20a1) }</span>

var fileDescriptor_bf9893c9be4c20a1 = []byte{
        // 358 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0x41, 0x4f, 0xf2, 0x30,
        0x1c, 0xc6, 0xb7, 0x17, 0x42, 0x42, 0xdf, 0x03, 0xb0, 0xf7, 0x3d, 0x2c, 0x24, 0x8e, 0x65, 0x31,
        0x06, 0x0f, 0xac, 0x99, 0xde, 0x3c, 0x22, 0x89, 0x89, 0x27, 0xb3, 0xa3, 0x17, 0xd2, 0x75, 0x05,
        0x1a, 0x3b, 0x3a, 0xd7, 0x82, 0x72, 0xf0, 0x3b, 0xf8, 0xb1, 0x38, 0x72, 0x34, 0x1e, 0x88, 0x81,
        0x8b, 0x67, 0x3f, 0x81, 0x69, 0x8b, 0x02, 0xe2, 0x65, 0xed, 0x9e, 0xe7, 0xb7, 0xe7, 0xc9, 0xbf,
        0x2b, 0xf0, 0x31, 0xcf, 0x52, 0xf2, 0x08, 0x71, 0x9a, 0xc3, 0x69, 0x84, 0x58, 0x3e, 0x42, 0x11,
        0xcc, 0x51, 0x81, 0x32, 0x11, 0xe6, 0x05, 0x97, 0xdc, 0xf9, 0x67, 0x88, 0x10, 0xa7, 0x79, 0xf8,
        0x45, 0x34, 0xff, 0x0f, 0xf9, 0x90, 0x6b, 0x1f, 0xaa, 0x9d, 0x41, 0x9b, 0x1e, 0xe6, 0x22, 0xe3,
        0x02, 0x26, 0x48, 0x10, 0x38, 0x8d, 0x12, 0x22, 0x51, 0x04, 0x31, 0xa7, 0x63, 0xe3, 0x07, 0x4f,
        0xa0, 0x72, 0xa3, 0xa3, 0x1d, 0x01, 0x1a, 0x98, 0x33, 0x86, 0x24, 0x29, 0x10, 0xeb, 0x9b, 0x3e,
        0xd7, 0xf6, 0x4b, 0xed, 0xbf, 0x67, 0xc7, 0xe1, 0x2f, 0x85, 0xe1, 0xe5, 0x37, 0xad, 0x13, 0xba,
        0xfe, 0x7c, 0xd9, 0xb2, 0x3e, 0x96, 0x2d, 0x77, 0x86, 0x32, 0x76, 0x11, 0x1c, 0x84, 0x05, 0x71,
        0x1d, 0xef, 0x7f, 0x22, 0x82, 0x77, 0x1b, 0xd4, 0x7e, 0xe4, 0x38, 0xa7, 0x60, 0x87, 0xeb, 0xa7,
        0x64, 0xcc, 0x33, 0xd7, 0xf6, 0xed, 0x76, 0x35, 0xae, 0x6d, 0xf5, 0x9e, 0x92, 0x9d, 0x23, 0x00,
        0x52, 0x92, 0xc8, 0x0d, 0xf4, 0x47, 0x43, 0x55, 0xa5, 0x18, 0xdb, 0x01, 0x65, 0x39, 0xcb, 0x89,
        0x5b, 0xd2, 0x86, 0xde, 0x3b, 0x0f, 0xa0, 0xc1, 0xe8, 0xfd, 0x84, 0xa6, 0x48, 0x52, 0x3e, 0xee,
        0x17, 0x6a, 0x71, 0xcb, 0x0a, 0xe8, 0x5e, 0xab, 0x01, 0x5e, 0x97, 0xad, 0x93, 0x21, 0x95, 0xa3,
        0x49, 0xa2, 0x86, 0x86, 0x9b, 0xe3, 0x33, 0x4b, 0x47, 0xa4, 0x77, 0x50, 0xa5, 0x88, 0xb0, 0x47,
        0xf0, 0x76, 0xd4, 0x83, 0xc0, 0x20, 0xae, 0xef, 0x68, 0xb1, 0x7a, 0x76, 0xaf, 0xe6, 0x2b, 0xcf,
        0x5e, 0xac, 0x3c, 0xfb, 0x6d, 0xe5, 0xd9, 0xcf, 0x6b, 0xcf, 0x5a, 0xac, 0x3d, 0xeb, 0x65, 0xed,
        0x59, 0xb7, 0x9d, 0xbd, 0x3e, 0x75, 0xd0, 0x1d, 0x3e, 0x18, 0x50, 0x4c, 0x11, 0xdb, 0xbc, 0x43,
        0x73, 0x1b, 0x74, 0x75, 0x52, 0xd1, 0x7f, 0xee, 0xfc, 0x33, 0x00, 0x00, 0xff, 0xff, 0xf8, 0x4d,
        0x6d, 0xed, 0x28, 0x02, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.CollateralParams) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.CollateralParams) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.CollateralParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintParams(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *CollateralParam) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *CollateralParam) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *CollateralParam) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size := m.LiquidationRatio.Size()
                i -= size
                if _, err := m.LiquidationRatio.MarshalTo(dAtA[i:]); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i = encodeVarintParams(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0x22
        if len(m.Type) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Type)
                copy(dAtA[i:], m.Type)
                i = encodeVarintParams(dAtA, i, uint64(len(m.Type)))
                i--
                dAtA[i] = 0x1a
        }</span>
        <span class="cov0" title="0">if len(m.DebtDenom) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.DebtDenom)
                copy(dAtA[i:], m.DebtDenom)
                i = encodeVarintParams(dAtA, i, uint64(len(m.DebtDenom)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.CollateralDenom) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralDenom)
                copy(dAtA[i:], m.CollateralDenom)
                i = encodeVarintParams(dAtA, i, uint64(len(m.CollateralDenom)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovParams(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *Params) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.CollateralParams) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.CollateralParams </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovParams(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *CollateralParam) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.CollateralDenom)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovParams(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.DebtDenom)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovParams(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Type)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovParams(uint64(l))
        }</span>
        <span class="cov0" title="0">l = m.LiquidationRatio.Size()
        n += 1 + l + sovParams(uint64(l))
        return n</span>
}

func sovParams(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozParams(x uint64) (n int) <span class="cov0" title="0">{
        return sovParams(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *Params) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralParams", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralParams = append(m.CollateralParams, CollateralParam{})
                        if err := m.CollateralParams[len(m.CollateralParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *CollateralParam) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CollateralParam: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: CollateralParam: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralDenom", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralDenom = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field DebtDenom", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.DebtDenom = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 3:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Type = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 4:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field LiquidationRatio", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.LiquidationRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipParams(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipParams(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowParams
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowParams
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthParams
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupParams
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthParams
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file11" style="display: none">package types

import "fmt"

type PricefeedType string

const (
        Spot        PricefeedType = "spot"
        liquidation PricefeedType = "liquidation"
)

func (pft PricefeedType) IsValid() error <span class="cov0" title="0">{
        switch pft </span>{
        case Spot, liquidation:<span class="cov0" title="0">
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid pricefeed type: %s", pft)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: comdex/cdp/v1alpha1/query.proto

package types

import (
        context "context"
        fmt "fmt"
        _ "github.com/cosmos/cosmos-sdk/types"
        _ "github.com/cosmos/cosmos-sdk/types/query"
        _ "github.com/gogo/protobuf/gogoproto"
        grpc1 "github.com/gogo/protobuf/grpc"
        proto "github.com/gogo/protobuf/proto"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        io "io"
        math "math"
        math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type QueryCDPRequest struct {
        CollateralType string `protobuf:"bytes,1,opt,name=collateral_type,json=collateralType,proto3" json:"collateral_type,omitempty" yaml:"collateral_type"`
        Owner          string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty" yaml:"owner"`
}

func (m *QueryCDPRequest) Reset()         <span class="cov0" title="0">{ *m = QueryCDPRequest{} }</span>
func (m *QueryCDPRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryCDPRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryCDPRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_b888451e45daea73, []int{0}
}</span>
func (m *QueryCDPRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryCDPRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryCDPRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryCDPRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPRequest.Merge(m, src)
}</span>
func (m *QueryCDPRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryCDPRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryCDPRequest proto.InternalMessageInfo

func (m *QueryCDPRequest) GetCollateralType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CollateralType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *QueryCDPRequest) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryCDPResponse struct {
        Cdp CDP `protobuf:"bytes,1,opt,name=cdp,proto3" json:"cdp" yaml:"cdp"`
}

func (m *QueryCDPResponse) Reset()         <span class="cov0" title="0">{ *m = QueryCDPResponse{} }</span>
func (m *QueryCDPResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryCDPResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryCDPResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_b888451e45daea73, []int{1}
}</span>
func (m *QueryCDPResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryCDPResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryCDPResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryCDPResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPResponse.Merge(m, src)
}</span>
func (m *QueryCDPResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryCDPResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryCDPResponse proto.InternalMessageInfo

func (m *QueryCDPResponse) GetCdp() CDP <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cdp
        }</span>
        <span class="cov0" title="0">return CDP{}</span>
}

type QueryCDPsRequest struct {
        Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty" yaml:"owner"`
}

func (m *QueryCDPsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryCDPsRequest{} }</span>
func (m *QueryCDPsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryCDPsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryCDPsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_b888451e45daea73, []int{2}
}</span>
func (m *QueryCDPsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryCDPsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryCDPsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryCDPsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPsRequest.Merge(m, src)
}</span>
func (m *QueryCDPsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryCDPsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryCDPsRequest proto.InternalMessageInfo

func (m *QueryCDPsRequest) GetOwner() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryCDPsResponse struct {
        Cdps []CDP `protobuf:"bytes,1,rep,name=cdps,proto3" json:"cdps" yaml:"cdps"`
}

func (m *QueryCDPsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryCDPsResponse{} }</span>
func (m *QueryCDPsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryCDPsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryCDPsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_b888451e45daea73, []int{3}
}</span>
func (m *QueryCDPsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryCDPsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryCDPsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryCDPsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPsResponse.Merge(m, src)
}</span>
func (m *QueryCDPsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryCDPsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryCDPsResponse proto.InternalMessageInfo

func (m *QueryCDPsResponse) GetCdps() []CDP <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cdps
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryCDPByIdRequest struct {
        Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *QueryCDPByIdRequest) Reset()         <span class="cov0" title="0">{ *m = QueryCDPByIdRequest{} }</span>
func (m *QueryCDPByIdRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryCDPByIdRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryCDPByIdRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_b888451e45daea73, []int{4}
}</span>
func (m *QueryCDPByIdRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryCDPByIdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryCDPByIdRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryCDPByIdRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPByIdRequest.Merge(m, src)
}</span>
func (m *QueryCDPByIdRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryCDPByIdRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPByIdRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryCDPByIdRequest proto.InternalMessageInfo

func (m *QueryCDPByIdRequest) GetId() uint64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type QueryCDPByIdResponse struct {
        Cdp CDP `protobuf:"bytes,1,opt,name=cdp,proto3" json:"cdp" yaml:"cdp"`
}

func (m *QueryCDPByIdResponse) Reset()         <span class="cov0" title="0">{ *m = QueryCDPByIdResponse{} }</span>
func (m *QueryCDPByIdResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryCDPByIdResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryCDPByIdResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_b888451e45daea73, []int{5}
}</span>
func (m *QueryCDPByIdResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryCDPByIdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryCDPByIdResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryCDPByIdResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPByIdResponse.Merge(m, src)
}</span>
func (m *QueryCDPByIdResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryCDPByIdResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryCDPByIdResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryCDPByIdResponse proto.InternalMessageInfo

func (m *QueryCDPByIdResponse) GetCdp() CDP <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cdp
        }</span>
        <span class="cov0" title="0">return CDP{}</span>
}

type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         <span class="cov0" title="0">{ *m = QueryParamsRequest{} }</span>
func (m *QueryParamsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_b888451e45daea73, []int{6}
}</span>
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}</span>
func (m *QueryParamsRequest) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

type QueryParamsResponse struct {
        Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         <span class="cov0" title="0">{ *m = QueryParamsResponse{} }</span>
func (m *QueryParamsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*QueryParamsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*QueryParamsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_b888451e45daea73, []int{7}
}</span>
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return m.Unmarshal(b)
}</span>
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        if deterministic </span><span class="cov0" title="0">{
                return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
        }</span> else<span class="cov0" title="0"> {
                b = b[:cap(b)]
                n, err := m.MarshalToSizedBuffer(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return b[:n], nil</span>
        }
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}</span>
func (m *QueryParamsResponse) XXX_Size() int <span class="cov0" title="0">{
        return m.Size()
}</span>
func (m *QueryParamsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Params
        }</span>
        <span class="cov0" title="0">return Params{}</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*QueryCDPRequest)(nil), "comdex.cdp.v1alpha1.QueryCDPRequest")
        proto.RegisterType((*QueryCDPResponse)(nil), "comdex.cdp.v1alpha1.QueryCDPResponse")
        proto.RegisterType((*QueryCDPsRequest)(nil), "comdex.cdp.v1alpha1.QueryCDPsRequest")
        proto.RegisterType((*QueryCDPsResponse)(nil), "comdex.cdp.v1alpha1.QueryCDPsResponse")
        proto.RegisterType((*QueryCDPByIdRequest)(nil), "comdex.cdp.v1alpha1.QueryCDPByIdRequest")
        proto.RegisterType((*QueryCDPByIdResponse)(nil), "comdex.cdp.v1alpha1.QueryCDPByIdResponse")
        proto.RegisterType((*QueryParamsRequest)(nil), "comdex.cdp.v1alpha1.QueryParamsRequest")
        proto.RegisterType((*QueryParamsResponse)(nil), "comdex.cdp.v1alpha1.QueryParamsResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("comdex/cdp/v1alpha1/query.proto", fileDescriptor_b888451e45daea73) }</span>

var fileDescriptor_b888451e45daea73 = []byte{
        // 609 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0x4f, 0x6f, 0xda, 0x30,
        0x18, 0xc6, 0x09, 0xa5, 0xd5, 0x6a, 0xaa, 0xfe, 0x31, 0xa8, 0x62, 0x59, 0x17, 0x50, 0xb4, 0x32,
        0x36, 0xa9, 0xb1, 0xe8, 0x4e, 0xeb, 0x61, 0xd2, 0xa0, 0xd2, 0xb4, 0x1b, 0xcb, 0xa6, 0x1e, 0x76,
        0x99, 0x4c, 0xe2, 0xa6, 0x91, 0x42, 0xec, 0xc6, 0x81, 0x15, 0x75, 0xf4, 0xb0, 0xcb, 0xae, 0x95,
        0xf6, 0xa5, 0x7a, 0xac, 0xb4, 0xcb, 0x4e, 0x68, 0x82, 0x7d, 0x02, 0x3e, 0xc1, 0x14, 0xc7, 0x29,
        0x7f, 0xc4, 0xa0, 0x87, 0x9e, 0x40, 0xf6, 0xf3, 0x3e, 0xcf, 0xcf, 0x7e, 0xdf, 0x18, 0x14, 0x2d,
        0xda, 0xb2, 0xc9, 0x05, 0xb2, 0x6c, 0x86, 0x3a, 0x55, 0xec, 0xb1, 0x33, 0x5c, 0x45, 0xe7, 0x6d,
        0x12, 0x74, 0x0d, 0x16, 0xd0, 0x90, 0xc2, 0x5c, 0x2c, 0x30, 0x2c, 0x9b, 0x19, 0x89, 0x40, 0xcd,
        0x3b, 0xd4, 0xa1, 0x62, 0x1f, 0x45, 0xff, 0x62, 0xa9, 0xba, 0xe7, 0x50, 0xea, 0x78, 0x04, 0x61,
        0xe6, 0x22, 0xec, 0xfb, 0x34, 0xc4, 0xa1, 0x4b, 0x7d, 0x2e, 0x77, 0x5f, 0x5a, 0x94, 0xb7, 0x28,
        0x47, 0x4d, 0xcc, 0x49, 0x9c, 0x80, 0x3a, 0xd5, 0x26, 0x09, 0x71, 0x15, 0x31, 0xec, 0xb8, 0xbe,
        0x10, 0x4b, 0xed, 0xd3, 0x79, 0x54, 0x11, 0x41, 0xbc, 0x5d, 0x9a, 0xb7, 0xcd, 0x70, 0x80, 0x5b,
        0x49, 0x98, 0x36, 0x19, 0x96, 0xc4, 0x58, 0xd4, 0x95, 0x01, 0xfa, 0x15, 0xd8, 0xfa, 0x10, 0x21,
        0xd4, 0x8f, 0x1b, 0x26, 0x39, 0x6f, 0x13, 0x1e, 0xc2, 0x3a, 0xd8, 0xb2, 0xa8, 0xe7, 0xe1, 0x90,
        0x04, 0xd8, 0xfb, 0x12, 0x76, 0x19, 0x29, 0x28, 0x25, 0xa5, 0xb2, 0x5e, 0x53, 0x47, 0xfd, 0xe2,
        0x6e, 0x17, 0xb7, 0xbc, 0x23, 0x7d, 0x46, 0xa0, 0x9b, 0x9b, 0xe3, 0x95, 0x4f, 0x5d, 0x46, 0x60,
        0x19, 0xac, 0xd2, 0xaf, 0x3e, 0x09, 0x0a, 0x69, 0x51, 0xba, 0x3d, 0xea, 0x17, 0x37, 0xe2, 0x52,
        0xb1, 0xac, 0x9b, 0xab, 0xf2, 0x17, 0x6c, 0x8f, 0xf3, 0x39, 0xa3, 0x3e, 0x27, 0xf0, 0x0d, 0x58,
        0xb1, 0x6c, 0x26, 0x42, 0xb3, 0x87, 0x05, 0x63, 0xce, 0xbd, 0x1b, 0xf5, 0xe3, 0x46, 0x0d, 0xde,
        0xf4, 0x8b, 0xa9, 0x51, 0xbf, 0x08, 0x24, 0x92, 0xcd, 0x74, 0x33, 0x2a, 0xd4, 0x8f, 0xc6, 0x9e,
        0x3c, 0x39, 0xd4, 0x7d, 0x79, 0x4e, 0xc0, 0xce, 0x44, 0xad, 0x04, 0x7a, 0x0b, 0x32, 0x96, 0xcd,
        0x78, 0x41, 0x29, 0xad, 0x2c, 0x24, 0xca, 0x49, 0xa2, 0xec, 0x1d, 0x11, 0xd7, 0x4d, 0x51, 0xaa,
        0xef, 0x83, 0x5c, 0xe2, 0x5b, 0xeb, 0xbe, 0xb7, 0x13, 0xac, 0x4d, 0x90, 0x76, 0x6d, 0x71, 0xd2,
        0x8c, 0x99, 0x76, 0x6d, 0xfd, 0x04, 0xe4, 0xa7, 0x65, 0x0f, 0x74, 0x25, 0x79, 0x00, 0x85, 0x6f,
        0x43, 0xcc, 0x86, 0x4c, 0xd7, 0x1b, 0x12, 0x2a, 0x59, 0x95, 0x61, 0xaf, 0xc1, 0x5a, 0x3c, 0x43,
        0x32, 0xef, 0xc9, 0xdc, 0xbc, 0xb8, 0xa8, 0x96, 0x89, 0x22, 0x4d, 0x59, 0x70, 0x78, 0x9d, 0x01,
        0x1b, 0xc2, 0xf2, 0x23, 0x09, 0x3a, 0xae, 0x45, 0xe0, 0x0f, 0x05, 0x3c, 0x4a, 0x4e, 0x04, 0x9f,
        0xcd, 0x35, 0x9a, 0x99, 0x3f, 0x75, 0x7f, 0x89, 0x2a, 0xa6, 0xd4, 0x8d, 0xef, 0xbf, 0xfe, 0xfe,
        0x4c, 0x57, 0x60, 0x19, 0x8d, 0x3f, 0x02, 0x8e, 0x2e, 0x67, 0x26, 0xb3, 0x87, 0x2e, 0x45, 0x63,
        0x7b, 0xf0, 0x02, 0xac, 0xdf, 0x75, 0x16, 0x2e, 0xce, 0x48, 0x2e, 0x48, 0x2d, 0x2f, 0x93, 0x49,
        0x96, 0x3d, 0xc1, 0xb2, 0x0b, 0xf3, 0xd3, 0x2c, 0x32, 0xf9, 0x4a, 0xde, 0x89, 0x6c, 0x2a, 0xac,
        0x2c, 0x74, 0x9d, 0x18, 0x0f, 0xf5, 0xc5, 0x3d, 0x94, 0x12, 0xe1, 0xb1, 0x40, 0xc8, 0xc1, 0x9d,
        0x69, 0x04, 0xd7, 0xee, 0xc1, 0x6f, 0x20, 0x3b, 0xd1, 0x66, 0xf8, 0xfc, 0xff, 0xa6, 0x53, 0xe3,
        0xa1, 0x56, 0x96, 0x0b, 0x65, 0xb8, 0x2a, 0xc2, 0xf3, 0x10, 0x4e, 0x84, 0xcb, 0x77, 0xa8, 0xf6,
        0xee, 0x66, 0xa0, 0x29, 0xb7, 0x03, 0x4d, 0xf9, 0x33, 0xd0, 0x94, 0xeb, 0xa1, 0x96, 0xba, 0x1d,
        0x6a, 0xa9, 0xdf, 0x43, 0x2d, 0xf5, 0xf9, 0xc0, 0x71, 0xc3, 0xb3, 0x76, 0x33, 0x4a, 0x91, 0x75,
        0x07, 0xf4, 0xf4, 0xd4, 0xb5, 0x5c, 0xec, 0x25, 0x3e, 0xb1, 0x53, 0xd4, 0x48, 0xde, 0x5c, 0x13,
        0x2f, 0xd6, 0xab, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa3, 0x62, 0xc9, 0x26, 0xaa, 0x05, 0x00,
        0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryServiceClient is the client API for QueryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryServiceClient interface {
        QueryCDP(ctx context.Context, in *QueryCDPRequest, opts ...grpc.CallOption) (*QueryCDPResponse, error)
        QueryCDPs(ctx context.Context, in *QueryCDPsRequest, opts ...grpc.CallOption) (*QueryCDPsResponse, error)
        QueryCDPById(ctx context.Context, in *QueryCDPByIdRequest, opts ...grpc.CallOption) (*QueryCDPByIdResponse, error)
        QueryParams(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
}

type queryServiceClient struct {
        cc grpc1.ClientConn
}

func NewQueryServiceClient(cc grpc1.ClientConn) QueryServiceClient <span class="cov0" title="0">{
        return &amp;queryServiceClient{cc}
}</span>

func (c *queryServiceClient) QueryCDP(ctx context.Context, in *QueryCDPRequest, opts ...grpc.CallOption) (*QueryCDPResponse, error) <span class="cov0" title="0">{
        out := new(QueryCDPResponse)
        err := c.cc.Invoke(ctx, "/comdex.cdp.v1alpha1.QueryService/QueryCDP", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryCDPs(ctx context.Context, in *QueryCDPsRequest, opts ...grpc.CallOption) (*QueryCDPsResponse, error) <span class="cov0" title="0">{
        out := new(QueryCDPsResponse)
        err := c.cc.Invoke(ctx, "/comdex.cdp.v1alpha1.QueryService/QueryCDPs", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryCDPById(ctx context.Context, in *QueryCDPByIdRequest, opts ...grpc.CallOption) (*QueryCDPByIdResponse, error) <span class="cov0" title="0">{
        out := new(QueryCDPByIdResponse)
        err := c.cc.Invoke(ctx, "/comdex.cdp.v1alpha1.QueryService/QueryCDPById", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *queryServiceClient) QueryParams(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        out := new(QueryParamsResponse)
        err := c.cc.Invoke(ctx, "/comdex.cdp.v1alpha1.QueryService/QueryParams", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// QueryServiceServer is the server API for QueryService service.
type QueryServiceServer interface {
        QueryCDP(context.Context, *QueryCDPRequest) (*QueryCDPResponse, error)
        QueryCDPs(context.Context, *QueryCDPsRequest) (*QueryCDPsResponse, error)
        QueryCDPById(context.Context, *QueryCDPByIdRequest) (*QueryCDPByIdResponse, error)
        QueryParams(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
}

// UnimplementedQueryServiceServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServiceServer struct {
}

func (*UnimplementedQueryServiceServer) QueryCDP(ctx context.Context, req *QueryCDPRequest) (*QueryCDPResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryCDP not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryCDPs(ctx context.Context, req *QueryCDPsRequest) (*QueryCDPsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryCDPs not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryCDPById(ctx context.Context, req *QueryCDPByIdRequest) (*QueryCDPByIdResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryCDPById not implemented")
}</span>
func (*UnimplementedQueryServiceServer) QueryParams(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method QueryParams not implemented")
}</span>

func RegisterQueryServiceServer(s grpc1.Server, srv QueryServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;_QueryService_serviceDesc, srv)
}</span>

func _QueryService_QueryCDP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryCDPRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryCDP(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.cdp.v1alpha1.QueryService/QueryCDP",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryCDP(ctx, req.(*QueryCDPRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryCDPs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryCDPsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryCDPs(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.cdp.v1alpha1.QueryService/QueryCDPs",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryCDPs(ctx, req.(*QueryCDPsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryCDPById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryCDPByIdRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryCDPById(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.cdp.v1alpha1.QueryService/QueryCDPById",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryCDPById(ctx, req.(*QueryCDPByIdRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _QueryService_QueryParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryParamsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryParams(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/comdex.cdp.v1alpha1.QueryService/QueryParams",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(QueryServiceServer).QueryParams(ctx, req.(*QueryParamsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

var _QueryService_serviceDesc = grpc.ServiceDesc{
        ServiceName: "comdex.cdp.v1alpha1.QueryService",
        HandlerType: (*QueryServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "QueryCDP",
                        Handler:    _QueryService_QueryCDP_Handler,
                },
                {
                        MethodName: "QueryCDPs",
                        Handler:    _QueryService_QueryCDPs_Handler,
                },
                {
                        MethodName: "QueryCDPById",
                        Handler:    _QueryService_QueryCDPById_Handler,
                },
                {
                        MethodName: "QueryParams",
                        Handler:    _QueryService_QueryParams_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "comdex/cdp/v1alpha1/query.proto",
}

func (m *QueryCDPRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryCDPRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryCDPRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">if len(m.CollateralType) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.CollateralType)
                copy(dAtA[i:], m.CollateralType)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.CollateralType)))
                i--
                dAtA[i] = 0xa
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryCDPResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryCDPResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryCDPResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Cdp.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryCDPsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryCDPsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryCDPsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Owner) &gt; 0 </span><span class="cov0" title="0">{
                i -= len(m.Owner)
                copy(dAtA[i:], m.Owner)
                i = encodeVarintQuery(dAtA, i, uint64(len(m.Owner)))
                i--
                dAtA[i] = 0x12
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryCDPsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryCDPsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryCDPsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if len(m.Cdps) &gt; 0 </span><span class="cov0" title="0">{
                for iNdEx := len(m.Cdps) - 1; iNdEx &gt;= 0; iNdEx-- </span><span class="cov0" title="0">{
                        </span><span class="cov0" title="0">{
                                size, err := m.Cdps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return 0, err
                                }</span>
                                <span class="cov0" title="0">i -= size
                                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
                        }
                        <span class="cov0" title="0">i--
                        dAtA[i] = 0xa</span>
                }
        }
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryCDPByIdRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryCDPByIdRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryCDPByIdRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                i = encodeVarintQuery(dAtA, i, uint64(m.Id))
                i--
                dAtA[i] = 0x8
        }</span>
        <span class="cov0" title="0">return len(dAtA) - i, nil</span>
}

func (m *QueryCDPByIdResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryCDPByIdResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryCDPByIdResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Cdp.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        return len(dAtA) - i, nil
}</span>

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) <span class="cov0" title="0">{
        size := m.Size()
        dAtA = make([]byte, size)
        n, err := m.MarshalToSizedBuffer(dAtA[:size])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return dAtA[:n], nil</span>
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) <span class="cov0" title="0">{
        size := m.Size()
        return m.MarshalToSizedBuffer(dAtA[:size])
}</span>

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) <span class="cov0" title="0">{
        i := len(dAtA)
        _ = i
        var l int
        _ = l
        </span><span class="cov0" title="0">{
                size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">i -= size
                i = encodeVarintQuery(dAtA, i, uint64(size))</span>
        }
        <span class="cov0" title="0">i--
        dAtA[i] = 0xa
        return len(dAtA) - i, nil</span>
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int <span class="cov0" title="0">{
        offset -= sovQuery(v)
        base := offset
        for v &gt;= 1&lt;&lt;7 </span><span class="cov0" title="0">{
                dAtA[offset] = uint8(v&amp;0x7f | 0x80)
                v &gt;&gt;= 7
                offset++
        }</span>
        <span class="cov0" title="0">dAtA[offset] = uint8(v)
        return base</span>
}
func (m *QueryCDPRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.CollateralType)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryCDPResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Cdp.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryCDPsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = len(m.Owner)
        if l &gt; 0 </span><span class="cov0" title="0">{
                n += 1 + l + sovQuery(uint64(l))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryCDPsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if len(m.Cdps) &gt; 0 </span><span class="cov0" title="0">{
                for _, e := range m.Cdps </span><span class="cov0" title="0">{
                        l = e.Size()
                        n += 1 + l + sovQuery(uint64(l))
                }</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (m *QueryCDPByIdRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        if m.Id != 0 </span><span class="cov0" title="0">{
                n += 1 + sovQuery(uint64(m.Id))
        }</span>
        <span class="cov0" title="0">return n</span>
}

func (m *QueryCDPByIdResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Cdp.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func (m *QueryParamsRequest) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        return n</span>
}

func (m *QueryParamsResponse) Size() (n int) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">var l int
        _ = l
        l = m.Params.Size()
        n += 1 + l + sovQuery(uint64(l))
        return n</span>
}

func sovQuery(x uint64) (n int) <span class="cov0" title="0">{
        return (math_bits.Len64(x|1) + 6) / 7
}</span>
func sozQuery(x uint64) (n int) <span class="cov0" title="0">{
        return sovQuery(uint64((x &lt;&lt; 1) ^ uint64((int64(x) &gt;&gt; 63))))
}</span>
func (m *QueryCDPRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field CollateralType", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.CollateralType = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryCDPResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Cdp", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Cdp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryCDPsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 2:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
                        }</span>
                        <span class="cov0" title="0">var stringLen uint64
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                stringLen |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">intStringLen := int(stringLen)
                        if intStringLen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + intStringLen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Owner = string(dAtA[iNdEx:postIndex])
                        iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryCDPsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Cdps", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">m.Cdps = append(m.Cdps, CDP{})
                        if err := m.Cdps[len(m.Cdps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryCDPByIdRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPByIdRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
                        }</span>
                        <span class="cov0" title="0">m.Id = 0
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                m.Id |= uint64(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryCDPByIdResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPByIdResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryCDPByIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Cdp", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Cdp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                preIndex := iNdEx
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= uint64(b&amp;0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">fieldNum := int32(wire &gt;&gt; 3)
                wireType := int(wire &amp; 0x7)
                if wireType == 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
                }</span>
                <span class="cov0" title="0">if fieldNum &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
                }</span>
                <span class="cov0" title="0">switch fieldNum </span>{
                case 1:<span class="cov0" title="0">
                        if wireType != 2 </span><span class="cov0" title="0">{
                                return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
                        }</span>
                        <span class="cov0" title="0">var msglen int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                msglen |= int(b&amp;0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if msglen &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">postIndex := iNdEx + msglen
                        if postIndex &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if postIndex &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">iNdEx = postIndex</span>
                default:<span class="cov0" title="0">
                        iNdEx = preIndex
                        skippy, err := skipQuery(dAtA[iNdEx:])
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if (skippy &lt; 0) || (iNdEx+skippy) &lt; 0 </span><span class="cov0" title="0">{
                                return ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">if (iNdEx + skippy) &gt; l </span><span class="cov0" title="0">{
                                return io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">iNdEx += skippy</span>
                }
        }

        <span class="cov0" title="0">if iNdEx &gt; l </span><span class="cov0" title="0">{
                return io.ErrUnexpectedEOF
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func skipQuery(dAtA []byte) (n int, err error) <span class="cov0" title="0">{
        l := len(dAtA)
        iNdEx := 0
        depth := 0
        for iNdEx &lt; l </span><span class="cov0" title="0">{
                var wire uint64
                for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                        if shift &gt;= 64 </span><span class="cov0" title="0">{
                                return 0, ErrIntOverflowQuery
                        }</span>
                        <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">b := dAtA[iNdEx]
                        iNdEx++
                        wire |= (uint64(b) &amp; 0x7F) &lt;&lt; shift
                        if b &lt; 0x80 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">wireType := int(wire &amp; 0x7)
                switch wireType </span>{
                case 0:<span class="cov0" title="0">
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">iNdEx++
                                if dAtA[iNdEx-1] &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                case 1:<span class="cov0" title="0">
                        iNdEx += 8</span>
                case 2:<span class="cov0" title="0">
                        var length int
                        for shift := uint(0); ; shift += 7 </span><span class="cov0" title="0">{
                                if shift &gt;= 64 </span><span class="cov0" title="0">{
                                        return 0, ErrIntOverflowQuery
                                }</span>
                                <span class="cov0" title="0">if iNdEx &gt;= l </span><span class="cov0" title="0">{
                                        return 0, io.ErrUnexpectedEOF
                                }</span>
                                <span class="cov0" title="0">b := dAtA[iNdEx]
                                iNdEx++
                                length |= (int(b) &amp; 0x7F) &lt;&lt; shift
                                if b &lt; 0x80 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if length &lt; 0 </span><span class="cov0" title="0">{
                                return 0, ErrInvalidLengthQuery
                        }</span>
                        <span class="cov0" title="0">iNdEx += length</span>
                case 3:<span class="cov0" title="0">
                        depth++</span>
                case 4:<span class="cov0" title="0">
                        if depth == 0 </span><span class="cov0" title="0">{
                                return 0, ErrUnexpectedEndOfGroupQuery
                        }</span>
                        <span class="cov0" title="0">depth--</span>
                case 5:<span class="cov0" title="0">
                        iNdEx += 4</span>
                default:<span class="cov0" title="0">
                        return 0, fmt.Errorf("proto: illegal wireType %d", wireType)</span>
                }
                <span class="cov0" title="0">if iNdEx &lt; 0 </span><span class="cov0" title="0">{
                        return 0, ErrInvalidLengthQuery
                }</span>
                <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                        return iNdEx, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, io.ErrUnexpectedEOF</span>
}

var (
        ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
        ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
        ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: comdex/cdp/v1alpha1/query.proto

/*
Package types is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package types

import (
        "context"
        "io"
        "net/http"

        "github.com/golang/protobuf/descriptor"
        "github.com/golang/protobuf/proto"
        "github.com/grpc-ecosystem/grpc-gateway/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = descriptor.ForMessage
var _ = metadata.Join

func request_QueryService_QueryCDP_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryCDPRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["collateral_type"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "collateral_type")
        }</span>

        <span class="cov0" title="0">protoReq.CollateralType, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "collateral_type", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["owner"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "owner")
        }</span>

        <span class="cov0" title="0">protoReq.Owner, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "owner", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryCDP(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryCDP_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryCDPRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["collateral_type"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "collateral_type")
        }</span>

        <span class="cov0" title="0">protoReq.CollateralType, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "collateral_type", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["owner"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "owner")
        }</span>

        <span class="cov0" title="0">protoReq.Owner, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "owner", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryCDP(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_QueryService_QueryCDPs_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryCDPsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["owner"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "owner")
        }</span>

        <span class="cov0" title="0">protoReq.Owner, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "owner", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryCDPs(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryCDPs_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryCDPsRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["owner"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "owner")
        }</span>

        <span class="cov0" title="0">protoReq.Owner, err = runtime.String(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "owner", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryCDPs(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_QueryService_QueryCDPById_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryCDPByIdRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
        }</span>

        <span class="cov0" title="0">protoReq.Id, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.QueryCDPById(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_QueryService_QueryCDPById_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryCDPByIdRequest
        var metadata runtime.ServerMetadata

        var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
        }</span>

        <span class="cov0" title="0">protoReq.Id, err = runtime.Uint64(val)

        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.QueryCDPById(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_QueryService_QueryParams_0(ctx context.Context, marshaler runtime.Marshaler, client QueryServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := client.QueryParams(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_QueryService_QueryParams_0(ctx context.Context, marshaler runtime.Marshaler, server QueryServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq QueryParamsRequest
        var metadata runtime.ServerMetadata

        msg, err := server.QueryParams(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

// RegisterQueryServiceHandlerServer registers the http handlers for service QueryService to "mux".
// UnaryRPC     :call QueryServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterQueryServiceHandlerFromEndpoint instead.
func RegisterQueryServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server QueryServiceServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_QueryService_QueryCDP_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryCDP_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryCDP_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryCDPs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryCDPs_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryCDPs_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryCDPById_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryCDPById_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryCDPById_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryParams_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateIncomingContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_QueryService_QueryParams_0(rctx, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryParams_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterQueryServiceHandlerFromEndpoint is same as RegisterQueryServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterQueryServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterQueryServiceHandler(ctx, mux, conn)</span>
}

// RegisterQueryServiceHandler registers the http handlers for service QueryService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterQueryServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterQueryServiceHandlerClient(ctx, mux, NewQueryServiceClient(conn))
}</span>

// RegisterQueryServiceHandlerClient registers the http handlers for service QueryService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "QueryServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "QueryServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "QueryServiceClient" to call the correct interceptors.
func RegisterQueryServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client QueryServiceClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_QueryService_QueryCDP_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryCDP_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryCDP_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryCDPs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryCDPs_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryCDPs_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryCDPById_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryCDPById_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryCDPById_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_QueryService_QueryParams_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                rctx, err := runtime.AnnotateContext(ctx, mux, req)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_QueryService_QueryParams_0(rctx, inboundMarshaler, client, req, pathParams)
                ctx = runtime.NewServerMetadataContext(ctx, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_QueryService_QueryParams_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_QueryService_QueryCDP_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 4, 1, 5, 2, 1, 0, 4, 1, 5, 3}, []string{"comdex", "cdps", "collateral_type", "owner"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryCDPs_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 4, 1, 5, 2}, []string{"comdex", "cdps", "owner"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryCDPById_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 4, 1, 5, 2}, []string{"comdex", "cdps", "id"}, "", runtime.AssumeColonVerbOpt(true)))

        pattern_QueryService_QueryParams_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"comdex", "cdp", "params"}, "", runtime.AssumeColonVerbOpt(true)))
)

var (
        forward_QueryService_QueryCDP_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryCDPs_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryCDPById_0 = runtime.ForwardResponseMessage

        forward_QueryService_QueryParams_0 = runtime.ForwardResponseMessage
)
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
